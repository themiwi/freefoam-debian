Removed userd plugin because of non-free files
--- a/applications/utilities/postProcessing/graphics/CMakeLists.txt
+++ b/applications/utilities/postProcessing/graphics/CMakeLists.txt
@@ -29,6 +29,5 @@
 #-------------------------------------------------------------------------------
 
 add_subdirectory(fieldview9Reader)
-add_subdirectory(ensightFoamReader)
 
 # ------------------------- vim: set sw=2 sts=2 et: --------------- end-of-file
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/CMakeLists.txt
+++ /dev/null
@@ -1,47 +0,0 @@
-#-------------------------------------------------------------------------------
-#               ______                _     ____          __  __
-#              |  ____|             _| |_  / __ \   /\   |  \/  |
-#              | |__ _ __ ___  ___ /     \| |  | | /  \  | \  / |
-#              |  __| '__/ _ \/ _ ( (| |) ) |  | |/ /\ \ | |\/| |
-#              | |  | | |  __/  __/\_   _/| |__| / ____ \| |  | |
-#              |_|  |_|  \___|\___|  |_|   \____/_/    \_\_|  |_|
-#
-#                   FreeFOAM: The Cross-Platform CFD Toolkit
-#
-# Copyright (C) 2008-2012 Michael Wild <themiwi@users.sf.net>
-#                         Gerber van der Graaf <gerber_graaf@users.sf.net>
-#-------------------------------------------------------------------------------
-# License
-#   This file is part of FreeFOAM.
-#
-#   FreeFOAM is free software: you can redistribute it and/or modify it
-#   under the terms of the GNU General Public License as published by the
-#   Free Software Foundation, either version 3 of the License, or (at your
-#   option) any later version.
-#
-#   FreeFOAM is distributed in the hope that it will be useful, but WITHOUT
-#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-#   for more details.
-#
-#   You should have received a copy of the GNU General Public License
-#   along with FreeFOAM.  If not, see <http://www.gnu.org/licenses/>.
-#-------------------------------------------------------------------------------
-
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${FOAM_LIBRARY_OUTPUT_DIRECTORY}/plugins/ensightReader)
-
-foam_add_library(userd MODULE SKIP_EXPORT)
-
-foam_target_link_libraries(userd
-  OpenFOAM
-  finiteVolume
-  lagrangian
-  genericPatchFields
-  )
-
-foam_install_targets(userd
-  RUNTIME DESTINATION "${FOAM_INSTALL_USERDFOAM_PATH}" COMPONENT plugins
-  LIBRARY DESTINATION "${FOAM_INSTALL_USERDFOAM_PATH}" COMPONENT plugins
-  )
-
-# ------------------------- vim: set sw=2 sts=2 et: --------------- end-of-file
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README
+++ /dev/null
@@ -1,1847 +0,0 @@
---------------------------------------
-EnSight User Defined Reader Capability
---------------------------------------
-
-A user defined reader capability is included in EnSight which allows otherwise
-unsupported structured or unstructured data to be read.  The user defined
-reader utilizes a dynamic shared library composed of routines defined in this
-document, but produced by the user (or some third party). This capability is
-currently available for dec, ibm, hp, sgi, and sun servers.
-
-****************************************************************************
-Note: Several user defined readers have been included with your EnSight
-      release and can be accessed by changing the ENSIGHT6_READER
-      environment variable as outlined in step 3. below.   Please be aware
-      that these are "unsupported" readers, but many of them are being used
-      successfully.
-****************************************************************************
-
-
-The process for producing a user defined reader is:
---------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy library and for various other working or
-        sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $ENSIGHT6_HOME/ensight62/user_defined_src/readers
-
-        examples:
-        --------
-        The default library. Basic dummy routines.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/dummy
-
-        Sample library which reads unstructured binary EnSight6 data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/ensight6
-
-        Sample library which reads binary static plot3d data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/plot3d
-
-        Reads binary LS-DYNA3D state database.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/ls-dyna3d
-
-        Reads FORTRAN binary Unstrutured dytran data base.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/dytran
-
-        Reads FlowScience "flsgrf" flow3d data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/flow3d
-
-        Reads Tecplot "plt" files.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/tecplot
-
-        Reads Common File Format data.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/cff
-
-        Reads Cobalt grid and picture/restart file data.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/cobalt
- 
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-	routines are called, which is provided in this file, along with
- 	the example libraries, should make it possible for you to produce
-	code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-        This is a compiling and loading process which varies according to
-        the type of machine you are on.  Thus, a separate makefile is provided
-        for each machine type.  Operating system level differences could cause
-        you to have to modify these makefiles slightly, but the general
-        process is very straightforward.  Note that for the SGI environment you
-        must compile with the following flags to ensure compatability with
-        the EnSight server:  Irix_5.3     -mips1
-                             Irix_6.2     -mips2
-                             Irix_6.5_n32 -mips3
-                             Irix_6.5_n64 -mips4 -64
-
-       __________________________________________________________________
-      | MACHINE | MAKEFILE TO USE       |  SHARED LIBRARY NAME PRODUCED  |
-      |  TYPE   |--------------------------------------------------------|
-      |         |         LD COMMAND USED IN MAKEFILE                    |
-       ==================================================================
-       __________________________________________________________________
-      | sgi     | makefile.sgi          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -shared -all -o libuserd.so libuserd.o              |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | hp      | makefile.hp           |  libuserd.sl                   |
-      |         |--------------------------------------------------------|
-      |         | ld -b -o libuserd.sl libuserd.o                        |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | sun     | makefile.sun          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -G -o libuserd.so libuserd.o                        |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | dec     | makefile.dec          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -shared -all -o libuserd.so libuserd.o -lc          |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | ibm     | makefile.ibm          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -G -o libuserd.so libuserd.o -bnoentry -bexpall -lc |
-       ------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice under:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers
-
-   Thus, if you created a reader for "mydata", you should create the
-   following directory, and place your libuserd.so into it:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers/mydata
-
-
-3. Set up the ENSIGHT6_READER environment variable so EnSight will know
-   which reader directory to use at runtime.
-
-   Ensight will look for the library under:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers/$ENSIGHT6_READER
-
-   When EnSight was installed, you set this variable to "dummy", with:
-
-     setenv ENSIGHT6_READER dummy
-
-   You can use any of the other provided readers by changing this variable.
-   For example, to use the dytran reader:
-
-     setenv ENSIGHT6_READER dytran 
-
-   Thus, you can use your reader in the same way.  If you provided "mydata",
-   change ENSIGHT6_READER to:
- 
-     setenv ENSIGHT6_READER mydata
-
-
-   For your information, EnSight makes sure that the appropriate library
-   environment variable is set for your machine architecture. You do not
-   have to deal with this if you locate your library as outlined above.
-   The library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-IMPORTANT:  Unless the shared library is available in the
-            .../$ENSIGHT6_READER directory, EnSight will not run.
-
-As always, EnSight support is available if you need it.
-
-
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_number_of_global_nodes                number of global nodes
-USERD_get_global_coords                         global node coordinates
-USERD_get_global_node_ids                       global node ids
-USERD_get_element_connectivities_for_part       part's element connectivites
-USERD_get_element_ids_for_part                  part's element ids
-USERD_get_scalar_values                         global scalar variables
-USERD_get_vector_values                         global vector variables
-
-
-Generally Needed for BLOCK data
------------------------------------------
-USERD_get_block_coords_by_component             block coordinates
-USERD_get_block_iblanking                       block iblanking values
-USERD_get_block_scalar_values                   block scalar variables
-USERD_get_block_vector_values_by_component      block vector variables 
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_set_filenames                             filenames entered in GUI
-USERD_set_time_step                             current time step
-
-USERD_get_name_of_reader                        name of reader for GUI
-USERD_get_number_of_files_in_dataset            number of files in model
-USERD_get_dataset_query_file_info               info about each model file
-USERD_get_changing_geometry_status              changing geometry?
-USERD_get_node_label_status                     node labels?
-USERD_get_element_label_status                  element labels?
-USERD_get_number_of_time_steps                  number of time steps
-USERD_get_solution_times                        solution time values
-USERD_get_description_lines                     file associated descrip lines
-USERD_get_number_of_variables                   number of variables
-USERD_get_variable_info                         variable type/descrip etc.
-USERD_get_constant_value                        constant variable's value
-USERD_get_number_of_model_parts                 number of model parts
-USERD_get_part_build_info                       part type/descrip etc.
-USERD_get_variable_value_at_specific            node's or element's variable
-                                                   value over time
-
-USERD_stop_part_building                        cleanup routine
-USERD_bkup                                      archive routine
-
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-
-2. Setting filenames and getting time info
-        USERD_set_filenames
-        USERD_get_number_of_time_steps
-        USERD_get_solution_times
-        USERD_set_time_step
-
-3. Gathering info for part builder
-
-        USERD_set_time_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_description_lines             (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords                 (for model extents)
-        USERD_get_block_coords_by_component     (for model extents)
-
-4. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_variable_info
-              
-5. Part building (per part created)
-
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-6. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_step
-        USERD_get_constant_value
-          
-        scalars:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_scalar_values
-        USERD_get_block_scalar_values
-
-        vectors:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_vector_values
-        USERD_get_block_vector_values_by_component
-
-7. Changing geometry
-
-        changing coords only:
-        --------------------
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity:
-        ---------------------
-        USERD_set_time_step
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-  
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available      = 0;
-static int Num_unstructured_parts  = 0;
-static int Num_structured_blocks   = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_time_steps          = 1;
-static int Num_global_nodes        = 0;
-static int Num_variables           = 0;
-static int Num_dataset_files       = 0;
-static int Current_time_step       = 0;
-
-
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
-
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given scalar variable
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given scalar variable
-
-   Specification:
-   -------------
-   int USERD_get_block_scalar_values(int block_number,
-                                     int which_scalar,
-                                     float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (IN)  which_scalar            = The variable number
-   (OUT) scalar_array            = 1D array containing scalar values
-                                   for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some scalar type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_vector_values_by_component
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given vector
-     variable, one component at a time.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given vector
-     variable, one component at a time.
-
-
-   Specification:
-   -------------
-   int USERD_get_block_vector_values_by_component(int block_number,
-                                                  int which_vector,
-                                                  int which_component,
-                                                  float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) vector_array            = 1D array containing vector
-                                   component value for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.
-
-
-
---------------------------------------------------------------------
-USERD_get_constant_value
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_BUFLEN is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-
-
-
---------------------------------------------------------------------
-USERD_get_description_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_description_lines(int which_type,
-                                   int which_var,
-                                   char line1[Z_BUFL],
-                                   char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_connectivities_for_part
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of an unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_element_connectivities_for_part(int part_number,
-                                                 int **conn_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) conn_array              = 3D array containing connectivity
-                                   of each element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type by connectivity length
-                                   of each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25][3]
-                              conn_array[Z_QUA04][100][4]
-                              conn_array[Z_HEX08][30][8]
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array loaded in USERD_get_global_coords is zero-based,
-     but within EnSight it will become a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array in
-          USERD_get_global_coords as follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array here as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
-
-
---------------------------------------------------------------------
-USERD_get_element_ids_for_part
-
-   Description:
-   -----------
-   Gets the ids for the elements of an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_element_ids_for_part(int part_number,
-                                      int *elemid_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) elemid_array            = 2D array containing id of each
-                                   element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25]
-                              conn_array[Z_QUA04][100]
-                              conn_array[Z_HEX08][30]
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and element
-     label status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-         USERD_get_element_ids_for_part is used to obtain the ids,
-         on a part by part basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_global_coords
-
-   Description:
-   -----------
-   Gets the coordinates for the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_coords(CRD *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) coord_array             = 1D array of CRD structures,
-                                   which contains x,y,z coordinates
-                                   of each node.
-
-                                  (Array will have been allocated
-                                   Num_global_nodes long)
-
-    For reference, CRD structure (which is in global_extern) is:
-
-         typedef struct {
-            float xyz[3];
-         }CRD;
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array is zero-based, but within EnSight it will become
-     a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array as
-          follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array in USERD_get_element_connectivities_for_part
-        as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
---------------------------------------------------------------------
-USERD_get_global_node_ids
-
-   Description:
-   -----------
-   Gets the node ids assigned to each of the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_node_ids(int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node. The ids must be > 0
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and node label
-     status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Provide a name for your custom reader format.
-
-   * If you don't want a custom reader to show up in the data dialog
-     choices, return a name of "No_Custom"
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  The must also be
-       positive numbers greater than zero.
-
-         USERD_get_global_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         Also be aware that if you say node labels are available,
-         the connectivity of elements must be according to these
-         node ids.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_global_nodes
-
-   Description:
-   -----------
-   Gets the number of global nodes, used for unstructured parts.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_global_nodes()
-
-   Returns:
-   -------
-   Number of global nodes (>=0 if okay, <0 if problems)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * For unstructured data:
-           EnSight wants  1. A global array of nodes
-                          2. Element connectivities by part, which
-                             reference the node numbers of the global
-                             node array.
-                IMPORTANT:
-                ---------
-                If you provide node ids, then element connectivities
-                must be in terms of the node ids.  If you do not
-                provide node ids, then element connectivities must be
-                in terms of the index into the node array, but shifted
-                to start at 1
-
-   * Num_global_nodes would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if probs).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_time_steps( void )
-
-   Returns:
-   -------
-   Number of time steps  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, and vector types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_part_build_info(int *part_numbers,
-                                 int *part_types,
-                                 char *part_description[Z_BUFL],
-                                 int *number_of_elements[Z_MAXTYPE],
-                                 int *ijk_dimensions[3],
-                                 int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) part_numbers           = Array containing part numbers for
-                                  each of the model parts.
-
-                                  IMPORTANT:
-                                   Parts numbers must be >= 1
-
-            ********************************************
-             The numbers provided here are the ones by
-             which the parts will be referred to in any
-             of the other routines which receive a part
-             number or block number as an argument!! 
-            ********************************************
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimensions
-                                  for each structured model part.
-                                           ----------
-                                  (Ignored if Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 3 long)
-
-                             ijk_dimensions[][0] = I dimension
-                             ijk_dimensions[][1] = J dimension
-                             ijk_dimensions[][2] = K dimension
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given scalar variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given scalar variable.
-
-   Specification:
-   -------------
-   int USERD_get_scalar_values(int which_scalar,
-                               int which_part,
-                               int which_type,
-                               float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_scalar            = The variable number (of scalar type)
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) scalar_array 
-
-            if Z_PER_NODE:       = 1D array containing scalar values
-                                    for each node.
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-
-            if Z_PER_ELEM:       = 1d array containing scalar values for
-                                   each element of a particular part and type.
-                                    
-                                   (Array will have been allocated
-                                    number_of_elements[which_part][which_type]
-                                    long.  See USERD_get_part_build_info)
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0, and you have some scalar type variables.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_solution_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step.
-
-   Specification:
-   -------------
-   int USERD_get_solution_times(float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) solution_times       = 1D array of solution times/time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_variable_info(char **var_description,
-                               char **var_filename,
-                               int *var_type,
-                               int *var_classify)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_filename         = Variable filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-              etc.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_variable_value_at_specific(int which_var,
-                                            int which_node_or_elem,
-                                            int which_part,
-                                            int which_elem_type,
-                                            int time_step,
-                                            float values[3])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-                        If Z_PER_NODE:
-                          = The node number.  This is not the id, but is
-                                              the index of the global node 
-                                              list (1 based), or the block's
-                                              node list (1 based).
-
-                            Thus,  coord_array[1]
-                                   coord_array[2]
-                                   coord_array[3]
-                                        .      |
-                                        .      |which_node_or_elem index
-                                        .             ----
-
-
-                        If Z_PER_ELEM:
-                          = The element number.  This is not the id, but is
-                                                 the element number index
-                                                 of the number_of_element array
-                                                 (see USERD_get_part_build_info),
-                                                 or the block's element list
-  zzzzz                                          (1 based).
-
-                            Thus,  for which_part:
-                                   conn_array[which_elem_type][0]
-                                   conn_array[which_elem_type][1]
-                                   conn_array[which_elem_type][2]
-                                        .                      |
-                                        .          which_node_or_elem index
-                                        .                        ----
-
-
-   (IN)  which_part
-
-                        If Z_PER_NODE, or block part:
-                          = Not used
-
-                        If Z_PER_ELEM:
-                          = The part number
-
-   (IN)  which_elem_type
-
-                        If Z_PER_NODE, or block part:
-                          = Not used
-
-                        If Z_PER_ELEM:
-                          = The element type.    This is the element type index
-                                                 of the number_of_element array
-                                                 (see USERD_get_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-
---------------------------------------------------------------------
-USERD_get_vector_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given vector variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given vector variable.
-
-   Specification:
-   -------------
-   int USERD_get_vector_values(int which_vector,
-                               int which_part,
-                               int which_type,
-                               float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) vector_array 
-
-            if Z_PER_NODE:       = 1D array containing vector values
-                                    for each node.
-
-                                   (Array will have been allocated
-                                    3 by Num_global_nodes long)
-
-                      Info stored in this fashion:
-                            vector_array[0] = xcomp of node 1
-                            vector_array[1] = ycomp of node 1
-                            vector_array[2] = zcomp of node 1
-
-                            vector_array[3] = xcomp of node 2
-                            vector_array[4] = ycomp of node 2
-                            vector_array[5] = zcomp of node 2
-
-                            vector_array[6] = xcomp of node 3
-                            vector_array[7] = ycomp of node 3
-                            vector_array[8] = zcomp of node 3
-                                    etc.
-
-            if Z_PER_ELEM:       = 1d array containing vector values for
-                                   each element of a particular part and type.
-                                    
-                                 (Array will have been allocated
-                                  3 by number_of_elements[which_part][which_type]
-                                  long.  See USERD_get_part_build_info)
-
-                      Info stored in this fashion:
-                            vector_array[0] = xcomp of elem 1 (of part and type)
-                            vector_array[1] = ycomp of elem 1         "
-                            vector_array[2] = zcomp of elem 1         "
-
-                            vector_array[3] = xcomp of elem 2         "
-                            vector_array[4] = ycomp of elem 2         "
-                            vector_array[5] = zcomp of elem 2         "
-
-                            vector_array[6] = xcomp of elem 3         "
-                            vector_array[7] = ycomp of elem 3         "
-                            vector_array[8] = zcomp of elem 3         "
-                                    etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0,  and you have some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed.
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
-
---------------------------------------------------------------------
-USERD_set_time_step
-
-   Description:
-   -----------
-   Set the current time step.  All functions that need time, and
-   that do not explicitly pass it in, will use the time step set by
-   this routine.
-
-   Specification:
-   -------------
-   void USERD_set_time_step(int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) time_step - The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step would be set here
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README7
+++ /dev/null
@@ -1,1847 +0,0 @@
---------------------------------------
-EnSight User Defined Reader Capability
---------------------------------------
-
-A user defined reader capability is included in EnSight which allows otherwise
-unsupported structured or unstructured data to be read.  The user defined
-reader utilizes a dynamic shared library composed of routines defined in this
-document, but produced by the user (or some third party). This capability is
-currently available for dec, ibm, hp, sgi, and sun servers.
-
-****************************************************************************
-Note: Several user defined readers have been included with your EnSight
-      release and can be accessed by changing the ENSIGHT6_READER
-      environment variable as outlined in step 3. below.   Please be aware
-      that these are "unsupported" readers, but many of them are being used
-      successfully.
-****************************************************************************
-
-
-The process for producing a user defined reader is:
---------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy library and for various other working or
-        sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $ENSIGHT6_HOME/ensight62/user_defined_src/readers
-
-        examples:
-        --------
-        The default library. Basic dummy routines.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/dummy
-
-        Sample library which reads unstructured binary EnSight6 data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/ensight6
-
-        Sample library which reads binary static plot3d data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/plot3d
-
-        Reads binary LS-DYNA3D state database.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/ls-dyna3d
-
-        Reads FORTRAN binary Unstrutured dytran data base.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/dytran
-
-        Reads FlowScience "flsgrf" flow3d data.
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/flow3d
-
-        Reads Tecplot "plt" files.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/tecplot
-
-        Reads Common File Format data.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/cff
-
-        Reads Cobalt grid and picture/restart file data.        
-          $ENSIGHT6_HOME/ensight62/user_defined_src/readers/cobalt
- 
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-	routines are called, which is provided in this file, along with
- 	the example libraries, should make it possible for you to produce
-	code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-        This is a compiling and loading process which varies according to
-        the type of machine you are on.  Thus, a separate makefile is provided
-        for each machine type.  Operating system level differences could cause
-        you to have to modify these makefiles slightly, but the general
-        process is very straightforward.  Note that for the SGI environment you
-        must compile with the following flags to ensure compatability with
-        the EnSight server:  Irix_5.3     -mips1
-                             Irix_6.2     -mips2
-                             Irix_6.5_n32 -mips3
-                             Irix_6.5_n64 -mips4 -64
-
-       __________________________________________________________________
-      | MACHINE | MAKEFILE TO USE       |  SHARED LIBRARY NAME PRODUCED  |
-      |  TYPE   |--------------------------------------------------------|
-      |         |         LD COMMAND USED IN MAKEFILE                    |
-       ==================================================================
-       __________________________________________________________________
-      | sgi     | makefile.sgi          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -shared -all -o libuserd.so libuserd.o              |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | hp      | makefile.hp           |  libuserd.sl                   |
-      |         |--------------------------------------------------------|
-      |         | ld -b -o libuserd.sl libuserd.o                        |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | sun     | makefile.sun          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -G -o libuserd.so libuserd.o                        |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | dec     | makefile.dec          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -shared -all -o libuserd.so libuserd.o -lc          |
-       ------------------------------------------------------------------
-       __________________________________________________________________
-      | ibm     | makefile.ibm          |  libuserd.so                   |
-      |         |--------------------------------------------------------|
-      |         | ld -G -o libuserd.so libuserd.o -bnoentry -bexpall -lc |
-       ------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice under:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers
-
-   Thus, if you created a reader for "mydata", you should create the
-   following directory, and place your libuserd.so into it:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers/mydata
-
-
-3. Set up the ENSIGHT6_READER environment variable so EnSight will know
-   which reader directory to use at runtime.
-
-   Ensight will look for the library under:
-
-     $ENSIGHT6_HOME/machines/$ENSIGHT6_ARCH/lib_readers/$ENSIGHT6_READER
-
-   When EnSight was installed, you set this variable to "dummy", with:
-
-     setenv ENSIGHT6_READER dummy
-
-   You can use any of the other provided readers by changing this variable.
-   For example, to use the dytran reader:
-
-     setenv ENSIGHT6_READER dytran 
-
-   Thus, you can use your reader in the same way.  If you provided "mydata",
-   change ENSIGHT6_READER to:
- 
-     setenv ENSIGHT6_READER mydata
-
-
-   For your information, EnSight makes sure that the appropriate library
-   environment variable is set for your machine architecture. You do not
-   have to deal with this if you locate your library as outlined above.
-   The library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-IMPORTANT:  Unless the shared library is available in the
-            .../$ENSIGHT6_READER directory, EnSight will not run.
-
-As always, EnSight support is available if you need it.
-
-
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_number_of_global_nodes                number of global nodes
-USERD_get_global_coords                         global node coordinates
-USERD_get_global_node_ids                       global node ids
-USERD_get_element_connectivities_for_part       part's element connectivites
-USERD_get_element_ids_for_part                  part's element ids
-USERD_get_scalar_values                         global scalar variables
-USERD_get_vector_values                         global vector variables
-
-
-Generally Needed for BLOCK data
------------------------------------------
-USERD_get_block_coords_by_component             block coordinates
-USERD_get_block_iblanking                       block iblanking values
-USERD_get_block_scalar_values                   block scalar variables
-USERD_get_block_vector_values_by_component      block vector variables 
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_set_filenames                             filenames entered in GUI
-USERD_set_time_step                             current time step
-
-USERD_get_name_of_reader                        name of reader for GUI
-USERD_get_number_of_files_in_dataset            number of files in model
-USERD_get_dataset_query_file_info               info about each model file
-USERD_get_changing_geometry_status              changing geometry?
-USERD_get_node_label_status                     node labels?
-USERD_get_element_label_status                  element labels?
-USERD_get_number_of_time_steps                  number of time steps
-USERD_get_solution_times                        solution time values
-USERD_get_description_lines                     file associated descrip lines
-USERD_get_number_of_variables                   number of variables
-USERD_get_variable_info                         variable type/descrip etc.
-USERD_get_constant_value                        constant variable's value
-USERD_get_number_of_model_parts                 number of model parts
-USERD_get_part_build_info                       part type/descrip etc.
-USERD_get_variable_value_at_specific            node's or element's variable
-                                                   value over time
-
-USERD_stop_part_building                        cleanup routine
-USERD_bkup                                      archive routine
-
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-
-2. Setting filenames and getting time info
-        USERD_set_filenames
-        USERD_get_number_of_time_steps
-        USERD_get_solution_times
-        USERD_set_time_step
-
-3. Gathering info for part builder
-
-        USERD_set_time_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_description_lines             (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords                 (for model extents)
-        USERD_get_block_coords_by_component     (for model extents)
-
-4. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_variable_info
-              
-5. Part building (per part created)
-
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-6. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_step
-        USERD_get_constant_value
-          
-        scalars:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_scalar_values
-        USERD_get_block_scalar_values
-
-        vectors:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_vector_values
-        USERD_get_block_vector_values_by_component
-
-7. Changing geometry
-
-        changing coords only:
-        --------------------
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity:
-        ---------------------
-        USERD_set_time_step
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-  
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available      = 0;
-static int Num_unstructured_parts  = 0;
-static int Num_structured_blocks   = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_time_steps          = 1;
-static int Num_global_nodes        = 0;
-static int Num_variables           = 0;
-static int Num_dataset_files       = 0;
-static int Current_time_step       = 0;
-
-
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
-
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given scalar variable
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given scalar variable
-
-   Specification:
-   -------------
-   int USERD_get_block_scalar_values(int block_number,
-                                     int which_scalar,
-                                     float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (IN)  which_scalar            = The variable number
-   (OUT) scalar_array            = 1D array containing scalar values
-                                   for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some scalar type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_vector_values_by_component
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given vector
-     variable, one component at a time.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given vector
-     variable, one component at a time.
-
-
-   Specification:
-   -------------
-   int USERD_get_block_vector_values_by_component(int block_number,
-                                                  int which_vector,
-                                                  int which_component,
-                                                  float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) vector_array            = 1D array containing vector
-                                   component value for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.
-
-
-
---------------------------------------------------------------------
-USERD_get_constant_value
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine) (Is a long)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_MAXFILENP is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-
-
-
---------------------------------------------------------------------
-USERD_get_description_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_description_lines(int which_type,
-                                   int which_var,
-                                   char line1[Z_BUFL],
-                                   char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_connectivities_for_part
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of an unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_element_connectivities_for_part(int part_number,
-                                                 int **conn_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) conn_array              = 3D array containing connectivity
-                                   of each element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type by connectivity length
-                                   of each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25][3]
-                              conn_array[Z_QUA04][100][4]
-                              conn_array[Z_HEX08][30][8]
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array loaded in USERD_get_global_coords is zero-based,
-     but within EnSight it will become a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array in
-          USERD_get_global_coords as follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array here as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
-
-
---------------------------------------------------------------------
-USERD_get_element_ids_for_part
-
-   Description:
-   -----------
-   Gets the ids for the elements of an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_element_ids_for_part(int part_number,
-                                      int *elemid_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) elemid_array            = 2D array containing id of each
-                                   element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25]
-                              conn_array[Z_QUA04][100]
-                              conn_array[Z_HEX08][30]
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and element
-     label status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-         USERD_get_element_ids_for_part is used to obtain the ids,
-         on a part by part basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_global_coords
-
-   Description:
-   -----------
-   Gets the coordinates for the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_coords(CRD *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) coord_array             = 1D array of CRD structures,
-                                   which contains x,y,z coordinates
-                                   of each node.
-
-                                  (Array will have been allocated
-                                   Num_global_nodes long)
-
-    For reference, CRD structure (which is in global_extern) is:
-
-         typedef struct {
-            float xyz[3];
-         }CRD;
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array is zero-based, but within EnSight it will become
-     a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array as
-          follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array in USERD_get_element_connectivities_for_part
-        as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
---------------------------------------------------------------------
-USERD_get_global_node_ids
-
-   Description:
-   -----------
-   Gets the node ids assigned to each of the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_node_ids(int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node. The ids must be > 0
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and node label
-     status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Provide a name for your custom reader format.
-
-   * If you don't want a custom reader to show up in the data dialog
-     choices, return a name of "No_Custom"
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  The must also be
-       positive numbers greater than zero.
-
-         USERD_get_global_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         Also be aware that if you say node labels are available,
-         the connectivity of elements must be according to these
-         node ids.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_global_nodes
-
-   Description:
-   -----------
-   Gets the number of global nodes, used for unstructured parts.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_global_nodes()
-
-   Returns:
-   -------
-   Number of global nodes (>=0 if okay, <0 if problems)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * For unstructured data:
-           EnSight wants  1. A global array of nodes
-                          2. Element connectivities by part, which
-                             reference the node numbers of the global
-                             node array.
-                IMPORTANT:
-                ---------
-                If you provide node ids, then element connectivities
-                must be in terms of the node ids.  If you do not
-                provide node ids, then element connectivities must be
-                in terms of the index into the node array, but shifted
-                to start at 1
-
-   * Num_global_nodes would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if probs).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_time_steps( void )
-
-   Returns:
-   -------
-   Number of time steps  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, and vector types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_part_build_info(int *part_numbers,
-                                 int *part_types,
-                                 char *part_description[Z_BUFL],
-                                 int *number_of_elements[Z_MAXTYPE],
-                                 int *ijk_dimensions[3],
-                                 int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) part_numbers           = Array containing part numbers for
-                                  each of the model parts.
-
-                                  IMPORTANT:
-                                   Parts numbers must be >= 1
-
-            ********************************************
-             The numbers provided here are the ones by
-             which the parts will be referred to in any
-             of the other routines which receive a part
-             number or block number as an argument!! 
-            ********************************************
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimensions
-                                  for each structured model part.
-                                           ----------
-                                  (Ignored if Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 3 long)
-
-                             ijk_dimensions[][0] = I dimension
-                             ijk_dimensions[][1] = J dimension
-                             ijk_dimensions[][2] = K dimension
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given scalar variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given scalar variable.
-
-   Specification:
-   -------------
-   int USERD_get_scalar_values(int which_scalar,
-                               int which_part,
-                               int which_type,
-                               float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_scalar            = The variable number (of scalar type)
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) scalar_array 
-
-            if Z_PER_NODE:       = 1D array containing scalar values
-                                    for each node.
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-
-            if Z_PER_ELEM:       = 1d array containing scalar values for
-                                   each element of a particular part and type.
-                                    
-                                   (Array will have been allocated
-                                    number_of_elements[which_part][which_type]
-                                    long.  See USERD_get_part_build_info)
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0, and you have some scalar type variables.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_solution_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step.
-
-   Specification:
-   -------------
-   int USERD_get_solution_times(float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) solution_times       = 1D array of solution times/time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_variable_info(char **var_description,
-                               char **var_filename,
-                               int *var_type,
-                               int *var_classify)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_filename         = Variable filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-              etc.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_variable_value_at_specific(int which_var,
-                                            int which_node_or_elem,
-                                            int which_part,
-                                            int which_elem_type,
-                                            int time_step,
-                                            float values[3])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-                        If Z_PER_NODE:
-                          = The node number.  This is not the id, but is
-                                              the index of the global node 
-                                              list (1 based), or the block's
-                                              node list (1 based).
-
-                            Thus,  coord_array[1]
-                                   coord_array[2]
-                                   coord_array[3]
-                                        .      |
-                                        .      |which_node_or_elem index
-                                        .             ----
-
-
-                        If Z_PER_ELEM:
-                          = The element number.  This is not the id, but is
-                                                 the element number index
-                                                 of the number_of_element array
-                                                 (see USERD_get_part_build_info),
-                                                 or the block's element list
-  zzzzz                                          (1 based).
-
-                            Thus,  for which_part:
-                                   conn_array[which_elem_type][0]
-                                   conn_array[which_elem_type][1]
-                                   conn_array[which_elem_type][2]
-                                        .                      |
-                                        .          which_node_or_elem index
-                                        .                        ----
-
-
-   (IN)  which_part
-
-                        If Z_PER_NODE, or block part:
-                          = Not used
-
-                        If Z_PER_ELEM:
-                          = The part number
-
-   (IN)  which_elem_type
-
-                        If Z_PER_NODE, or block part:
-                          = Not used
-
-                        If Z_PER_ELEM:
-                          = The element type.    This is the element type index
-                                                 of the number_of_element array
-                                                 (see USERD_get_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-
---------------------------------------------------------------------
-USERD_get_vector_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given vector variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given vector variable.
-
-   Specification:
-   -------------
-   int USERD_get_vector_values(int which_vector,
-                               int which_part,
-                               int which_type,
-                               float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) vector_array 
-
-            if Z_PER_NODE:       = 1D array containing vector values
-                                    for each node.
-
-                                   (Array will have been allocated
-                                    3 by Num_global_nodes long)
-
-                      Info stored in this fashion:
-                            vector_array[0] = xcomp of node 1
-                            vector_array[1] = ycomp of node 1
-                            vector_array[2] = zcomp of node 1
-
-                            vector_array[3] = xcomp of node 2
-                            vector_array[4] = ycomp of node 2
-                            vector_array[5] = zcomp of node 2
-
-                            vector_array[6] = xcomp of node 3
-                            vector_array[7] = ycomp of node 3
-                            vector_array[8] = zcomp of node 3
-                                    etc.
-
-            if Z_PER_ELEM:       = 1d array containing vector values for
-                                   each element of a particular part and type.
-                                    
-                                 (Array will have been allocated
-                                  3 by number_of_elements[which_part][which_type]
-                                  long.  See USERD_get_part_build_info)
-
-                      Info stored in this fashion:
-                            vector_array[0] = xcomp of elem 1 (of part and type)
-                            vector_array[1] = ycomp of elem 1         "
-                            vector_array[2] = zcomp of elem 1         "
-
-                            vector_array[3] = xcomp of elem 2         "
-                            vector_array[4] = ycomp of elem 2         "
-                            vector_array[5] = zcomp of elem 2         "
-
-                            vector_array[6] = xcomp of elem 3         "
-                            vector_array[7] = ycomp of elem 3         "
-                            vector_array[8] = zcomp of elem 3         "
-                                    etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0,  and you have some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed.
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
-
---------------------------------------------------------------------
-USERD_set_time_step
-
-   Description:
-   -----------
-   Set the current time step.  All functions that need time, and
-   that do not explicitly pass it in, will use the time step set by
-   this routine.
-
-   Specification:
-   -------------
-   void USERD_set_time_step(int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) time_step - The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step would be set here
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_1.0_to_2.0
+++ /dev/null
@@ -1,361 +0,0 @@
-README_1.0_to_2.0
-=================
-This document exists to help those who already have a working user defined
-reader (using the 1.0 API) to change it into the 2.0 API format - if desired.
-
-Note that you do not have to update your (1.0 API) user defined reader if it
-is already working fine for you.
-
-You should consider it if:
-  - efficieny gains are needed or
-  - you need access to complex variables or
-  - you need access to tensor variables or
-  - you need multiple timeset capability or
-  - you want to provide your own "border" elements (as opposed to EnSight's
-                                                    computation of them)
-
-As an indication of the differences that might be realized in efficency,
-consider the following comparison on an unstructured model consisting of:
-
-1,639,058 nodes
-7,079,211 elements      240530 tria3
-                          3984 quad4
-                       5927663 tetra4
-                           653 pyramid5
-                        906381 penta6
-
-12 parts
-
-The same model was represented in EnSight6 and EnSight Gold format.
-
-
-                    EnSight6 format into:           EnSight Gold format into:
-            ------------------------------------    -------------------------
-            EnSight7.1  |Ensight7.2  |Ensight 7.1  |EnSight7.2  |Ensight7.2
-            internal    |internal    |userd reader |internal    |userd reader
-            reader      |reader      |(API 1.0)    |reader      |(API 2.0)
-                        |            |             |            |
-            Time | Mem  |Time | Mem  |Time | Mem   |Time | Mem  |Time | Mem
-            (sec)| (Mb) |(sec)| (Mb) |(sec)| (Mb)  |(sec)| (Mb) |(sec)| (Mb)
-            ----------- |----------- |-----------  |----------- |-----------
-@ part       4.3   27.6 | 3.5   28.4 | 4.0   27.6  | 3.3    8.8 | 3.3    8.9
-loader                  |            |             |            |
-                        |            |             |            |
-after       14.0  243.4 |12.8  244.3 |49.8  475.8  | 6.0  211.5 | 6.2  211.6
-loading all             |            |             |            |
-12 parts                |            |             |            |
-(non-visual)            |            |             |            |
-                        |            |             |            |
-after       16.8  263.2 |16.0  264.2 |52.8  490.7  | 9.1  236.2 | 9.5  236.2
-activate of             |            |             |            |
-a vector.               |            |             |            |
-                                           ^                          ^
-                                          /|\                        /|\
-                                           |                          |
-                                           |                          |
-                                           |                          |
-                                                Compare these two!
-
-
-Significant is the inefficiency of the 1.0 API, and the fact that the
-2.0 API has the same improved efficiency (both in speed and memory) as
-the gold internal reader!
-
-Note: Structured data will not show much difference between the two API's,
-but it was more efficient initially.
-
-
-=========================================================
-A note on philosophical differences between the two API's:
-=========================================================
-
-API 1.0 deals with:
--------------------
- -> global coordinate array  & corresponding
-    -> global node id array
-    -> global nodal variables
-
- -> for each part:
-    -> local element connectivities (grouped by type) & corresponding
-       -> local element ids
-       -> local elemental variables
-
-
-The element connectivities, within parts, reference the global coordinate
-array. If node ids are provided, the element connectivities have to be in
-terms of the node ids. If node ids are not provided, the connectivities are in
-terms of the (one-based) index number of each node in the global coordinate
-array. Thus, node ids are more than labels - they are a part of the
-connectivity referencing scheme. Element ids are purely labels.
-
-This API was originally setup to try to make the interface to other codes as
-straightforward as possible.  Efficiency was not the major consideration.
-
-EnSight must do a fair amount of work to get data provided in the manner
-described above into the form that it uses internally. There is mapping that
-has to be setup and maintained between the global arrays and the local part
-arrays so that updating over time can be accomplished efficiently. There is
-hashing that is required in order to deal efficently with node ids.
-
-All of this leads to a considerable amount of temporary memory and processing,
-in order to get a model read into EnSight.
-
-
-API 2.0 deals with:
--------------------
- -> for each part:
-    -> part coordinates  & corresponding
-    -> part node ids
-    -> part nodal variables
-
-    -> part element connectivities (grouped by type) & corresponding
-       -> part element ids
-       -> part elemental variables
-
-API 2.0 requires that the coordinates and corresponding nodal variables be
-provided per part. This eliminates the global to local mapping with all its
-associated temporary memory and processing time. The connectivity of the
-elements in each part reference the node indicies of its own (one-based) part
-coordinate array.  The connectivity of the elements do not reference the nodes
-according to node ids.  Node ids (and element ids for that matter) are purely
-labels for screen display and for query operations within EnSight. This
-eliminates the need for node id hashing as a model is read.
- 
-The 2.0 API has been created for those needing more efficiency - both in terms
-of memory use and speed. The increased efficiency is possible because data is
-requested in a manner which more closely represents the way that EnSight
-stores and manipulates information internally. The new API requests size
-information and allocates the actual internal structures and arrays
-accordingly.  Pointers to these arrays are passed directly to you in the
-routines which gather data, thus eliminating a considerable amount of
-temporary memory (and allocation time) that is needed in the old
-API. Depending on what you must do to get your data into the form required,
-the memory savings and the speed improvement when loading models can be quite
-significant!!
- 
-Additionally, the ability to handle tensor and complex variables has been
-added to the new API, and support for multiple timesets is provided.
-------------------------------------------------
-
-
-So, with that said, if you determine that you want to convert your existing
-reader to the new API format, The following may be helpful.
-
-====================
-First the Good News!  The following routines are identical in both API's!!
-====================  ----------------------------------------------------
-USERD_bkup
-USERD_get_block_coords_by_component
-USERD_get_block_iblanking
-USERD_get_changing_geometry_status
-USERD_get_dataset_query_file_info
-USERD_get_element_label_status
-USERD_get_name_of_reader
-USERD_get_node_label_status
-USERD_get_number_of_files_in_dataset
-USERD_get_number_of_model_parts
-USERD_get_number_of_variables
-USERD_set_filenames
-USERD_stop_part_building
-
-
-
-========================
-Second, pretty Good News!    The following routines have minor changes,
-========================     namely a slight name change and the addition
-                             of arguments related to complex data, constant
-(Note, the name changes      type, or self contained parts vs global coords.
- are needed so both
- API's can exist together)   The arguments must be added, but depending on
-                             your situation, many might simply be place
-                             holders.
--------------------------------------------------------------------------------
-
-   -----------------------------------------------------
-A) Changes related to imaginary flag for complex data
-   =====================================================
-   If you don't deal with complex variables, simply add
-   this flag to your argument list and ignore its value.
-   ----------------------------------------------------- 
-
-API 1.0                                 API 2.0
--------                                 -------
-USERD_get_constant_value                USERD_get_constant_val
-(                                       (
- int which var                           int which_var,
-                                         int imag_data
-)                                       )
-
-USERD_get_description_lines             USERD_get_descrip_lines
-(                                       (
- int which_type,                         int which_type,
- int which_var,                          int which_var,
-                                         int imag_data,
- char line1[Z_BUFL],                     char line1[Z_BUFL],
- char line2[Z_BUFL]                      char line2[Z_BUFL]
-)                                       )
-
-USERD_get_variable_value_at_specific    USERD_get_var_value_at_specific
-(                                       (
- int which_var,                          int which_var,
- int which_node_or_elem,                 int which_node_or_elem,
- int which_part,                         int which_part,
- int which_elem_type,                    int which_elem_type,
- int time_step,                          int time_step,
- float values[3]                         float values[3],
-                                         int imag_data
-)                                       )
-
-
-   ---------------------------------------------------------
-B) Changes related to complex data info, and constant type
-   (and some of the multiple timeset support)
-   =========================================================
-   If you don't deal with complex variables, simply add the
-   arguments for var_complex, var_ifilename, and var_freq
-   and assign var_complex to be FALSE.
-
-   The argument var_contran needs to be added, and set
-   appropriately if you have constant variables, to indicate
-   if the constant variable is fixed for all time or varies
-   over time.
-
-   The argument var_timeset needs to be added, and set
-   appropriately.
-   --------------------------------------------------------- 
-
-API 1.0                                 API 2.0
--------                                 -------
-USERD_get_variable_info                 USERD_get_gold_variable_info
-(                                       (
- char **var_description,                 char **var_description,
- char **var_filename,                    char **var_filename,
- int *var_type,                          int *var_type,
- int *var_classify                       int *var_classify,
-                                         int *var_complex,
-                                         char **var_ifilename,
-                                         float *var_freq,
-                                         int *var_contran,
-                                         int *var_timeset
-)                                       )
-
-
-   ------------------------------------------------------
-C) Changes related to self contained part coordinates
-   ======================================================
-   The number_of_nodes argument needs to be added and
-   set for each part. This one is critical for you to do.
-   ------------------------------------------------------
-
-API 1.0                                 API 2.0
--------                                 -------
-USERD_get_part_build_info               USERD_get_gold_part_build_info
-(                                       (
- int *part_numbers,                      int *part_types,
- int *part_types,                        int *part_types,
- char *part_description[Z_BUFL],         char *part_description[Z_BUFL],
-                                         int *number_of_nodes,
- int *number_of_elements[Z_MAXTYPE],     int *number_of_elements[Z_MAXTYPE],
- int *ijk_dimensions[3],                 int *ijk_dimensions[3],
- int *iblanking_options[6]               int *iblanking_options[6]
-)                                       )
-
-
-   ------------------------------------------------------
-D) Changes related to multiple timeset support
-   ======================================================
-   The timeset_number argument needs to be added for the
-   following three routines.
-
-   The multiple timeset support also includes the change
-   in B) above for USERD_get_gold_variable_info and the
-   last three new routines in the third section of this
-   readme file.
-   ------------------------------------------------------
-
-API 1.0                                 API 2.0
--------                                 -------
-USERD_get_number_of_time_steps          USERD_get_num_of_time_steps
-(                                       (
- void                                    int timeset_number
-)                                       )
-
-USERD_get_solution_times                USERD_get_sol_times
-(                                       (
-                                         int timeset_number,
- float *solution_times                   float *solution_times
-)                                       )
-
-USERD_set_time_step                     USERD_set_time_set_and_step
-(                                       (
-                                         int timeset_number,
- int time_step                           int time_step
-)                                       )
-
-
-   ------------------------------------------------------
-E) Changes related to global_extern.h
-   ======================================================
-
-   Be sure to include the updated global_extern.h file that comes 
-   with the EnSight 7.2 release (not the one from previous releases).
-
-
-
-
-=================================================================
-Third, deleted and new routines.  (Here is where the work lies)
-
-  Several old routines are gone. You will have to create the new
-  routines that replace them. I think you will find in most cases
-  that your old routines will form the basis of the new routines,
-  and that it isn't too difficult to provide the information in
-  the new way.
-
-  The detailed specifications for these new routines can be found
-  in README_USERD_2.0 (or the headers in libuserd.c of the
-  dummy_gold or ensight_gold readers).
-=================================================================
-
-API 1.0                                     API 2.0
--------                                     -------
-
-These routines:                             replaced by the single routine:
----------------------------                 -------------------------------
-USERD_get_block_scalar_values               USERD_get_var_by_component
-USERD_get_block_vector_values_by_component    
-USERD_get_scalar_values                       
-USERD_get_vector_values                       
-
-These global coordinate routines:           replaced by part coord routines:
----------------------------------           --------------------------------
-USERD_get_global_coords                     USERD_get_part_coords
-USERD_get_global_node_ids                   USERD_get_part_node_ids
-USERD_get_number_of_global_nodes
-
-These part connectivity routines:           replaced by part by type routines:
----------------------------------           ----------------------------------
-USERD_get_element_connectivities_for_part   USERD_get_part_elements_by_type
-USERD_get_element_ids_for_part              USERD_get_part_element_ids_by_type
-
-
-                                            These are New Routines
-                                            ----------------------
-                      (Can be a dummy) ->   USERD_exit_routine
-                      (Can be a dummy) ->   USERD_get_model_extents
-                            (Required) ->   USERD_get_reader_version
-
-     multiple timeset releated:
-                            (Required) ->   USERD_get_number_timesets
-                            (Required) ->   USERD_get_timeset_description
-                            (Required) ->   USERD_get_geom_timeset_number
-
-     border provided by the reader option:
-                            (Required) ->   USERD_get_border_availability
-                      (Can be a dummy) ->   USERD_get_border_elements_by_type
-
-     transient model allocation efficency:
-                      (Can be a dummy) ->   USERD_get_maxsize_info
-
-     Possible use with Server-of-Servers:
-                      (Can be a dummy) ->   USERD_set_server_number
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_2.01_to_2.03
+++ /dev/null
@@ -1,1374 +0,0 @@
-README_USERD_2.03
-=================
-
-At this API revision level:
-
-1. Routines to handle materials have been added.
-2. Routines to handle nsided and nfaced elements have been added
-3. A routine has modified so structured ranges can be specified
-
-****************************************************************************
-Note: The dummy_gold reader, the Ensight Gold example reader, and the
-      SILO reader have been moved to this 2.03 API level.
-****************************************************************************
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-The new new routines are:
--------------------------
-USERD_get_number_of_material_sets    Gets the number of material sets
-USERD_get_matf_set_info              Gets the material set indices and names
-USERD_get_number_of_materials        Gets the number of materials
-USERD_get_matf_var_info              Gets the material indices and descriptions
-USERD_size_matf_data                 Gets the length of either the
-                                        material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-USERD_load_matf_data                 Gets the material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-
-USERD_get_nsided_conn                Gets the element connectivities for nsided
-                                        elements. (utilizes the number of nodes
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_nodes_per_face      Gets the number of nodes per face for nfaced
-                                        elements (utilizes the number of faces
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_conn                Gets the element connectivities for nfaced
-                                        elements (utilizes the number of nodes
-                                        per face obtained in
-                                        USERD_get_nfaced_nodes_per_face)
-The modified routine is:
-------------------------
-USERD_get_gold_part_build_info       Gets the info needed for part building
-                                        process
-
---------------------
-Header files changes
---------------------
-global_extern.h         has appropriate changes, must use it
-global_extern_proto.h   new file, access from global_extern.h
-
-Basically the the old global_extern.h file has been split into two files now.
-
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-10. To see if materials in the model
-
-        USERD_get_number_of_material_sets
-
-      If any material sets in the model (calls these once per material set):
-        USERD_get_matf_set_info
-        USERD_get_number_of_materials
-        USERD_get_matf_var_info
-
-      For each elment type of each part containing material ids, calls:
-        USERD_size_matf_data
-        USERD_load_matf_data
-
-      If there are any elements with mixed materials, when a domain or
-      interface is created, calls these again per part:
-
-        USERD_size_matf_data
-        USERD_load_matf_data
-
-6. Part building (per part created)
-
-        both unstructured and structured:
-        --------------------------------
-        USERD_set_time_set_and_step
-
-        if unstructured part:
-        --------------------
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-
-          If any nsided elements:
-  
-            USERD_get_nsided_conn
-
-          If any nfaced elements:
-
-            USERD_get_nfaced_nodes_per_face
-            USERD_get_nfaced_conn
-
-        USERD_get_part_coords
-        USERD_get_part_node_ids
- 
-         .
-         .
-         .
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-
-*******************************************************************************
-****************************** Special Note ***********************************
-*******************************************************************************
-
-Make sure you use the proper define in the global_extern.h header file, namely:
-#define USERD_API_203
-
-Also, Make sure the api version in the USERD_get_reader_version routine is set
-to "2.03" or larger.
-
-Make sure your reader has access to the global_extern_proto.h   This is a new
-file which is access from the new global_extern.h    
-
-*******************************************************************************
-*******************************************************************************
-
-____________________
---------------------
-New Library Routines
-____________________
---------------------
-
---------------------------------------------------------------------
-USERD_get_number_of_material_sets -
-
-   Description:
-   -----------
-   Get the number of material sets in the model
-
-   Specification:
-   -------------
-   int USERD_get_number_of_material_sets( void )
-
-
-   Returns:
-   -------
-   Num_material_sets = number of material sets
-                       (Zero would indicate that you have no materials
-                        to deal with in the model)
-
-                       or
-
-                       -1 if an error condition
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-  * You may want to keep this as a global for use in other routines.
-
-   ###############################################################
-   NOTE:  For EnSight 7.6, only one material set is supported
-          within EnSight.
-          Thus the only valid returns here are:
-               0 (no materials)
-               1 (for the one material set allowed)
-          or  -1 (if an error)
-
-          If the casefile has more than this, this reader will
-          read them, but EnSight will issue an error message and
-          choke on them!
-   ###############################################################
-
-  ================================================================
-  A very simple explanatory example, to use as a reference for the
-  materials routines:
-
-  Given a 2D mesh composed of 9 quad (Z_QUA04) elements, with two materials.
-  Most of the model is material 1, but the top left corner is material 9 -
-  basically as shown:
-
-
-        *--------*--------*--------*
-        |        |   /    |        |
-        |     Mat 9 /     |        |
-        |        | /      |        |
-        |        |/       |        |
-        |  e7    /   e8   |   e9   |
-        |       /|        |        |
-        |      / |        |        |
-        |     /  |        |        |
-        *----/---*--------*--------*
-        |   /    |        |        |
-        |  /     |        |        |
-        | /      |      Mat 1      |
-        |/       |        |        |
-        |   e4   |   e5   |   e6   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |   e1   |   e2   |   e3   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-
-
-  Thus, in this routine, set:
-    Num_material_sets = 1
-
-  In USERD_get_matf_set_info, set:
-    mat_set_ids[0]    = 1
-    mat_set_name[0]   = "Material Set 1"  (or whatever name desired)
-
-  In USERD_get_number_of_materials, input would be set_index = 0, and
-  would need to set:
-    Num_materials[0] = 2
-
-  For simplicity, the ids and descriptions that would be returned in
-  USERD_get_matf_var_info could be:
-    mat_ids[0] = 1
-    mat_ids[1] = 9
-    mat_desc[0] = "mat 1"   (or whatever desired)
-    mat_desc[2] = "mat 9"
-
-  The per element material ids list would need to be:
-
-     material ids:
-     -------------
-     ids_list[0] = 1  (material id 1, for elem e1)
-     ids_list[1] = 1  (     "                  e2)
-     ids_list[2] = 1  (     "                  e3)
-     ids_list[3] = -1 (negative of index into mixed-material id list, for elem e4)
-     ids_list[5] = 1  (material id 1, for elem e5)
-     ids_list[5] = 1  (     "                  e6)
-     ids_list[5] = -5 (negative of index into mixed-material id list, for elem e7)
-     ids_list[5] = -9 (     "                                                  e8)
-     ids_list[5] = 1  (material id 1, for elem e9)
-
-  Finally we need the mixed material ids list and the mixed materials values list,
-  which would need to be:
-
-       mixed-material ids:
-       -------------------
-   ==> 1  ids_list[0]  =  2  (the -1 in the material variable points here,
-                                      2 indicates that two materials are present)
-       2  ids_list[1]  =  1  (1st material is 1)
-       3  ids_list[2]  =  9  (2nd material is 9)
-       4  ids_list[3]  = -1  (negative of index into mixed-material val_list)
-   ==> 5  ids_list[4]  =  2  (the -5 in the material variable points here,
-                                      2 indicates that two materials are present)
-       6  ids_list[5]  =  1  (1st material is 1)
-       7  ids_list[6]  =  9  (2nd material is 9)
-       8  ids_list[7]  = -3  (negative of index into mixed-material val_list)
-   ==> 9  ids_list[8]  =  2     etc.
-       10 ids_list[9]  =  1
-       11 ids_list[10] =  9
-       12 ids_list[11] = -5
-
-       mixed-material values:
-       ----------------------
-   ==> 1 val_list[0] = 0.875 (the -1 in the  mixed-material ids_list points here,
-                                       and this is the value for material 1)
-       2 val_list[1] = 0.125 (the value for material 9)
-   ==> 3 val_list[2] = 0.125 (the -3 in the mixed-materials ids_list points here)
-       4 val_list[3] = 0.875
-   ==> 5 val_list[4] = 0.875 (the -5 in the mixed-materials ids_list points here)
-       6 val_list[5] = 0.125
-
-  So, USERD_size_matf_data would need to return
-       matf_size = 8, when called with set_id    = 1
-                                       part_id   = 1
-                                       wtyp      = Z_QUA04
-                                       mat_type  = Z_MAT_INDEX
-
-       matf_size = 12, when called with set_id   = 1
-                                        part_id  = 1
-                                        mat_type = Z_MIX_INDEX
-
-                 = 6, when called with set_id   = 1
-                                       part_id  = 1
-                                       mat_type = Z_MIX_VALUE
-
-  And, USERD_load_matf_data would need to return:
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       wtyp     = Z_QUA04
-       mat_type = Z_MAT_INDEX (indicating id list).
-
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_INDEX (indicating id list).
-
-    the float array val_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_VALUE (indicating val list).
-
-
-
--------------------------------------------------------------------------
-USERD_get_matf_set_info
-
-   Description:
-   -----------
-   Get the material set ids and names
-
-   Specification:
-   -------------
-   int USERD_get_matf_set_info(int *mat_set_ids,
-                               char **mat_set_name)
-
-   Returns: 
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) mat_set_ids  = 1D material set ids array
-
-                               (Array will have been allocated
-                                Num_material_sets long)
-
-   (OUT) mat_set_name = 2D material set name array
-
-                               (Array will have been allocated
-                                Num_material_sets by Z_BUFL long)
-
-   Notes:
-   -----
-   * Will not be called if Num_material_sets is zero
-   * See USERD_get_number_of_material_sets header for explanatory example
-
-
--------------------------------------------------------------------------
-USERD_get_number_of_materials
-
-   Description:
-   -----------
-   Gets the number of materials in the material set
-
-   Specification:
-   -------------
-   int USERD_get_number_of_materials( int set_index )
-
-   Returns:
-   -------
-   Num_materials[set_index]   = Number of materials in the set
-                                 0 indicates no materials information present
-                                -1 indicates an error
-   Arguments:
-   ---------
-   (IN) set_index             = the material set index (zero based)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero
-  * You may want to keep this as a global for use in other routines.
-
-
---------------------------------------------------------------------
-USERD_get_matf_var_info
-
-   Description:
-   -----------
-   Gets the material ids and descriptions for the material set
-
-   Specification:
-   -------------
-   int USERD_get_matf_var_info(int set_index,
-                               int *mat_ids,
-                               char **mat_desc)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  set_index               = the material set index (zero based)
-
-   (OUT) mat_ids[set_index]      = 1D integer array containing the material
-                                   ids to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] long)
-
-   (OUT) mat_desc[set_index]     = 2D char array containing the material
-                                   descriptions to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] by Z_BUFL long)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
---------------------------------------------------------------------
-USERD_size_matf_data
-
-   Description:
-   -----------
-   Get the length of the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_size_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *matf_size)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) matf_size         = the length of the material id list, or
-                            mixed-material id list, or
-                            mixed-material values list
-                            for the given material set and part number
-                            (and element type if Z_MAT_INDEX)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
-----------------------------------------------------------------------
-USERD_load_matf_data
-
-   Description:
-   -----------
-   Get the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_load_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *ids_list,
-                             float *val_list)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) ids_list          = If mat_type is Z_MAT_INDEX:
-                            ---------------------------
-                             1D material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MAT_INDEX)
-
-                            If mat_type is Z_MIX_INDEX:
-                            ---------------------------
-                             1D mixed-material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MIX_INDEX)
-
-  (OUT) val_list          = 1D mixed-materials values list
-                            (only used if mat_type is Z_MIX_VALUE)
-
-                               (Float array will have been allocated
-                                the appropriate size, as returned in
-                                USERD_size_matf_data for mat_type Z_MIX_VALUE)
-  
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero,
-     or Num_materials[set_index] is zero,
-     or the appropriate size from USERD_size_matf_data is zero
-
-
-
---------------------------------------------------------------------
-USERD_get_nsided_conn -
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided elements
-
-   Specification:
-   -------------
-   int USERD_get_nsided_conn(int part_number,
-                             int *nsided_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number         = the part number
-
-   (OUT) nsided_conn_array   = 1D array of nsided connectivies
-  
-                               (int array will have been allocated long enough
-                                to hold all the nsided connectivities. Which is
-                                the sum of all the nodes_per_element values in
-                                the conn_array of USERD_get_part_elements_by_type)
-  
-
-   Notes:
-   -----
-   * Will not be called unless there are some nsided elements in the the part.
-
-   * Providing nsided information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nsided
-        elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of nodes per nsided element. (as if connectivity
-        length of an nsided element is one)
-  
-     3. In this routine, provide the streamed connectivities for each of the
-        nsided elements.
-  
-  
-     Simple example:         5        6
-                            +--------+
-     3 nsided elements:    /|         \
-     (1 4-sided           / |          \
-      1 3-sided          /  |           \
-      1 7-sided)        /   |            \ 7
-                       /3   |4            +
-                      +-----+             |
-                      |     |             |
-                      |     |             |8
-                      |     |             +
-                      |     |            /
-                      |     |           /
-                      |     |          /
-                      |1    |2        /9
-                      +-----+--------+
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NSIDED] = 3
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      3 x 1
-  
-          for element_type of Z_NSIDED:
-              conn_array[0][0] = 4           (for the 4-sided element)
-              conn_array[1][0] = 3           (for the 3-sided element)
-              conn_array[2][0] = 7           (for the 7-sided element)
-  
-                           Sum  ===
-                                 14    <---------+
-                                                 |
-      3. In this routine:                        |
-           length of nsided_conn_array will be:  14
-  
-              nsided_conn_array[0]  = 1      (connectivity of 4-sided element)
-              nsided_conn_array[1]  = 2
-              nsided_conn_array[2]  = 4
-              nsided_conn_array[3]  = 3
-  
-              nsided_conn_array[4]  = 3      (connectivity of 3-sided element)
-              nsided_conn_array[5]  = 4
-              nsided_conn_array[6]  = 5
-  
-              nsided_conn_array[7]  = 2      (connectivity of 7-sided element)
-              nsided_conn_array[8]  = 9
-              nsided_conn_array[9]  = 8
-              nsided_conn_array[10] = 7
-              nsided_conn_array[11] = 6
-              nsided_conn_array[12] = 5
-              nsided_conn_array[13] = 4
-
-
-
---------------------------------------------------------------------
-USERD_get_nfaced_nodes_per_face -
-
-   Description:
-   -----------
-   Gets the array containing the number of nodes per face for each face
-   of the nfaced elements.
-
-   Specification:
-   -------------
-   int USERD_get_nfaced_nodes_per_face(int part_number,
-                                       int *nfaced_npf_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number       = the part number
-
-   (OUT) nfaced_npf_array  = 1D array of nodes per face for all faces of
-                             nfaced elements
- 
-                             (int array will have been allocated long enough
-                              to hold all the nodes_per_face values. Which is
-                              the sum of all the number of faces per element
-                              values in the conn_array of
-                              USERD_get_part_elements_by_type)
-
-   Notes:
-   -----
-   * Will not be called unless there are some nfaced elements in the
-     the part
-
-   * Providing nfaced information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-  
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-  
-  
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-  
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In this routine:                       |
-           length of nfaced_npf_array will be:  12
-  
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-  
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-  
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In USERD_get_nfaced_conn:                    |
-            length of the nfaced_conn_array will be:  48
-  
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-  
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-  
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-  
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-  
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-  
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-  
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-  
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-  
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-  
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-  
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-  
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-
---------------------------------------------------------------------
-USERD_get_nfaced_conn
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided faces of nfaced elements
-
-   Specification:
-   -------------int
-   int USERD_get_nfaced_conn(int part_number,
-                             int *nfaced_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number        = the part number
-
-   (OUT) nfaced_conn_array  = 1D array of nsided face connectivies of nfaced
-                              elements
-
-                              (int array will have been allocated long enough to
-                               hold all the nsided face connectivities. Which is
-                               the sum of all the nodes per face values in the
-                               nfaced_npf_array of USERD_get_nfaced_nodes_per_face)
-
-   Notes:
-   -----
- * Will not be called unless there are some nfaced elements in the part
-
- * Providing nfaced information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-  
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-  
-  
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-  
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In USERD_get_faced_nodes_per_face:     |
-           length of nfaced_npf_array will be:  12
-  
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-  
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-  
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In this function:                            |
-            length of the nfaced_conn_array will be:  48
-  
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-  
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-  
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-  
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-  
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-  
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-  
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-  
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-  
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-  
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-  
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-  
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-________________________
-------------------------
-Modified Library Routine
-________________________
-------------------------
-
---------------------------------------------------------------------
-USERD_get_gold_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for part building process
-
-   Specification:
-   -------------
-   int
-   USERD_get_gold_part_build_info(int *part_id,
-                                  int *part_types,
-                                  char *part_description[Z_BUFL],
-                                  int *number_of_nodes,
-                                  int *number_of_elements[Z_MAXTYPE],
-                                  int *ijk_dimensions[9],
-                                  int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) part_id                = Array containing the external part
-                                  ids for each of the model parts.
- 
-                                  IMPORTANT:
-                                   Parts numbers must be >= 1, because
-                                   of the way they are used in the GUI
- 
-              *******************************************
-               The ids provided here are the numbers by
-               which the parts will be referred to in the
-               GUI (if possible). They are basically
-               labels as far as you are concerned.
- 
-               Note: The part numbers you pass to routines
-               which receive a part_number or block_number
-               or which_part as an argument are the 1-based
-               table index of the parts!
- 
-               example:  If Numparts_available = 3
- 
-                         Table index        part_id
-                         -----------        -------
-                          1                  13
-                          2                  57
-                          3                  125
- 
-                          ^                   ^
-                          |                   |
-                          |                    These are placed in:
-                          |                      part_id[0] = 13
-                          |                      part_id[1] = 57
-                          |                      part_id[2] = 125
-                          |                    for GUI labeling purposes.
-                          |
-                           These implied table indices are the part_number,
-                           block_number, or which_part numbers that you would
-                           pass to routines like:
- 
-                          USERD_get_part_coords(int part_number,...
-                          USERD_get_part_node_ids(int part_number,...
-                          USERD_get_part_elements_by_type(int part_number,...
-                          USERD_get_part_element_ids_by_type(int part_number,...
-                          USERD_get_block_coords_by_component(int block_number,...
-                          USERD_get_block_iblanking(int block_number,...
-                          USERD_get_block_ghost_flags(int block_number,...
-                          USERD_get_ghosts_in_block_flag(int block_number)
-                          USERD_get_border_availability( int part_number,...
-                          USERD_get_border_elements_by_type( int part_number,...
-                          USERD_get_var_by_component(int which_variable,
-                                                     int which_part,...
-                          USERD_get_var_value_at_specific(int which_var,
-                                                          int which_node_or_elem,
-                                                          int which_part,...
-              ********************************************
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
- 
-                                        Z_UNSTRUCTURED or
-                                        Z_STRUCTURED  or
-                                        Z_IBLANKED
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
- 
-                                   (Array will have been allocated
-                                    Numparts_available by Z_BUFL
-                                    long)
- 
-   (OUT) number_of_nodes        = Number of unstructured nodes in the part
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
- 
-                                 Z_POINT   =  point
-                                 Z_BAR02   =  2-noded bar
-                                 Z_BAR03   =  3-noded bar
-                                 Z_TRI03   =  3-noded triangle
-                                 Z_TRI06   =  6-noded triangle
-                                 Z_QUA04   =  4-noded quadrilateral
-                                 Z_QUA08   =  8-noded quadrilateral
-                                 Z_TET04   =  4-noded tetrahedron
-                                 Z_TET10   = 10-noded tetrahedron
-                                 Z_PYR05   =  5-noded pyramid
-                                 Z_PYR13   = 13-noded pyramid
-                                 Z_PEN06   =  6-noded pentahedron
-                                 Z_PEN15   = 15-noded pentahedron
-                                 Z_HEX08   =  8-noded hexahedron
-                                 Z_HEX20   = 20-noded hexahedron
- 
-    Starting at API 2.01:
-    ====================
-                                 Z_G_POINT    ghost node point element
-                                 Z_G_BAR02    2 node ghost bar
-                                 Z_G_BAR03    3 node ghost bar
-                                 Z_G_TRI03    3 node ghost triangle
-                                 Z_G_TRI06    6 node ghost triangle
-                                 Z_G_QUA04    4 node ghost quad
-                                 Z_G_QUA08    8 node ghost quad
-                                 Z_G_TET04    4 node ghost tetrahedron
-                                 Z_G_TET10   10 node ghost tetrahedron
-                                 Z_G_PYR05    5 node ghost pyramid
-                                 Z_G_PYR13   13 node ghost pyramid
-                                 Z_G_PEN06    6 node ghost pentahedron
-                                 Z_G_PEN15   15 node ghost pentahedron
-                                 Z_G_HEX08    8 node ghost hexahedron
-                                 Z_G_HEX20   20 node ghost hexahedron
- 
-    Starting at API 2.02:
-    ====================
-                                 Z_NSIDED     n node nsided polygon
-                                 Z_NFACED     n face nfaced polyhedron
-                                 Z_G_NSIDED   n node ghost nsided polygon
-                                 Z_G_NFACED   n face ghost nfaced polyhedron
- 
-                                (Ignored unless Z_UNSTRUCTURED type)
- 
-                                   (Array will have been allocated
-                                    Numparts_available by
-                                    Z_MAXTYPE long)
- 
-   (OUT) ijk_dimensions         = 2D array containing ijk dimension info
-                                  for structured blocks
- 
-                                  For Z_UNSTRUCTURED - is ignored
- 
-                                  For Z_STRUCTURED or Z_IBLANKED
- 
-        Prior to version 2.03:
-        ----------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 3 long)
- 
-                              ijk_dimensions[][0] = I dimension
-                              ijk_dimensions[][1] = J dimension
-                              ijk_dimensions[][2] = K dimension
- 
- 
-        Starting at version 2.03:
-        ------------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 9 long)
- 
-                              There are two ways to do this:
-                              ------------------------------
-                              1. The simple one, without ranges.
- 
-                                   This is good for all structured models
-                                   that will NOT be used in EnSight's
-                                   Server of Servers
- 
-                                   Simply provide the ijk dimensions in the
-                                   first three slots and place a -1 in
-                                   the 4th slot.  (The remaining slots will
-                                   be ignored).
- 
-                              Thus,
-                              ijk_dimensions[][0] = I dimension of block
-                              ijk_dimensions[][1] = J dimension of block
-                              ijk_dimensions[][2] = K dimension of block
-                              ijk_dimensions[][3] = -1
- 
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][4] = -1
-                              |       |       |
-                              |       |       |
-                            2 *-------*-------*
-                              |       |       |
-                              |       |       |
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
- 
-                              2. Using ranges.
- 
-                                  This one can be used anytime, but MUST
-                                  be used if EnSight's Server of Servers
-                                  is to be used!
- 
-                                  The first 3 slots contain the ijk dimension
-                                  of the complete block (of which this may be
-                                  a portion).  The last 6 slots contain the
-                                  ijk min and max ranges within the complete.
- 
-                              Thus,
-                              ijk_dimensions[][0] = I dim of complete block
-                              ijk_dimensions[][1] = J dim of complete block
-                              ijk_dimensions[][2] = K dim of complete block
- 
-                              ijk_dimensions[][3] = Imin of portion (1-based)
-                              ijk_dimensions[][4] = Imax of portion (1-based)
-                              ijk_dimensions[][5] = Jmin of portion (1-based)
-                              ijk_dimensions[][6] = Jmax of portion (1-based)
-                              ijk_dimensions[][7] = Kmin of portion (1-based)
-                              ijk_dimensions[][8] = Kmax of portion (1-based)
- 
- 
-                              example1: (Model has one part, a simple 2D block,
-                                         and want whole thing)
- 
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][3] = 1
-                              |       |       |    ijk_dimension[0][4] = 3
-                              |       |       |    ijk_dimension[0][5] = 1
-                            2 *-------*-------*    ijk_dimension[0][6] = 4
-                              |       |       |    ijk_dimension[0][7] = 1
-                              |       |       |    ijk_dimension[0][8] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
-                              example2: (Want to have the block represented
-                                         in two portions - 2 parts)
- 
-                        (J planes)                 top portion
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              .       .       .    ijk_dimension[0][3] = 1
-                              .       .       .    ijk_dimension[0][4] = 3
-                              .       .       .    ijk_dimension[0][5] = 3
-                            2 .................    ijk_dimension[0][6] = 4
-                              .       .       .    ijk_dimension[0][7] = 1
-                              .       .       .    ijk_dimension[0][8] = 1
-                              .       .       .
-                            1 .................
-                              1       2       3  (I planes)
- 
- 
-                        (J planes)                 bottom portion
-                            4 .................
-                              .       .       .    ijk_dimension[1][0] = 3
-                              .       .       .    ijk_dimension[2][1] = 4
-                              .       .       .    ijk_dimension[3][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[1][3] = 1
-                              |       |       |    ijk_dimension[1][4] = 3
-                              |       |       |    ijk_dimension[1][5] = 1
-                            2 *-------*-------*    ijk_dimension[1][6] = 3
-                              |       |       |    ijk_dimension[1][7] = 1
-                              |       |       |    ijk_dimension[1][8] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
-        And note that if you were partioning this block for
-        EnSight's Server of Servers, you would only have one part,
-        instead of two.  Each SOS server would return its appropriate
-        ranges in the last 6 slots. The first 3 slots would remain constant.
- 
- 
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
- 
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
- 
-       iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                        [][Z_INT]     = TRUE if internal (inside)
-                        [][Z_BND]     = TRUE if boundary
-                        [][Z_INTBND]  = TRUE if internal boundary
-                        [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   If you haven't built a table of pointers to the different parts,
-   you might want to do so here as you gather the needed info.
- 
-   This will be based on Current_time_step
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_USERD_1.0
+++ /dev/null
@@ -1,2013 +0,0 @@
-README_USERD_1.0
-================
---------------------------------------
-EnSight User Defined Reader Capability   ===> (API 1.0)
---------------------------------------
-A user defined reader capability is included in EnSight which can allow
-otherwise unsupported structured or unstructured data to be read.  The user
-defined reader capability utilizes dynamic shared libraries composed of
-routines defined in this document but produced by you, the user, (or some
-third party). This capability is currently available for dec, ibm, hp, sgi,
-sun, linux, alpha linux, and NT servers.
-
-Two versions of this API are available starting with EnSight Version 7.2. The
-1.0 API (which was designed to be friendly to those producing it, but requires
-more manipulation internally by EnSight) may be a little easier to
-produce, but requires more memory and processing time.  The 2.0 API is
-considerably more efficient, and was designed more with that in mind. It
-requires that all data be provided on a part basis.
-
-If you already have a working 1.0 API reader and are happy with it - there is
-probably no reason to modify it to the 2.0 API unless:
- - you deal with large models and the memory use and load times are a
-   problem or
- - you need tensor variable support or
- - you need complex variable support or
- - you need multiple timeset capability or
- _ you want to provide your own "border" elements (as opposed to EnSight's
-                                                    computation of them).
-
-If you are producing a new reader, you should consider which will work best
-for your needs.
-
-
-API 1.0 (defined in this README_USERD_1.0 document)
-=======
-The original user defined reader API (used with EnSight Versions 6 through
-7.1) will continue to be supported. (Note that there was a change in the way
-that the libraries were made at version 7.1 of EnSight, but underlying code
-was kept the same.) Thus, any readers that work with EnSight 7.1, should still
-function with EnSight 7.2.
-
-
-API 2.0  (defined in README_USERD_2.0 document)
-=======
-This new API has been defined to be more efficient and includes access to new
-capabilities of EnSight 7.2.  It lends itself closely to the EnSight "gold"
-type format.
-
-Some of its advantages are::
-
- * Most intermediate temporary arrays have been eliminated, such that the user
-   defined routines write directly into internal part structures. This is a 
-   considerable improvement in memory use, and improves speed as well since
-   far less memory need be allocated, initialized, etc.
-
- * Parts are self contained. Coordinates, connectivity and all variables are
-   provided on a part basis. This eliminates the need for several global to
-   local coordinate mapping operations and the need for node id connectivity
-   hashing.  This can greatly improve the speed at which models are loaded.
-
- * Model extents can be provided directly, such that EnSight need not read
-   all the coordinate data at load time.
-
- * Tensor variables are supported
-
- * Complex variables are supported
-
- * A routine is provided as EnSight exits, so cleanup operations such as
-   removing temporary files can be easily accomplished.
-
- * Geometry and variables can be provided on different time lines.
-
- * If your data format already provides boundary shell information, you can
-   use it instead of the "border" representation that EnSight would compute.
-
-Further discussion on the philosophical differences between the two API's and
-an efficiency comparison example can be found in the README_1.0_to_2.0 file.
-This file also contains guidance on necessary changes to modify an existing
-1.0 API to the new 2.0 API.
-
-
-****************************************************************************
-Note: Several (1.0 API) user defined readers have been included with your
-      EnSight release and are configured by default.  There are site- and
-      user-configurable options outlined in step 3 below.  Please be aware
-      that these are "unsupported" readers, but many of them are being used
-      successfully.
-****************************************************************************
-
-
-The process for producing a user defined reader is:
----------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy library and for various other working or
-        sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $ENSIGHT7_HOME/user_defined_src/readers
-
-        examples of API 1.0:
-        -------------------
-        Basic dummy routines provide skeleton for a new reader
-          $ENSIGHT7_HOME/user_defined_src/readers/dummy
-
-        Sample library which reads unstructured binary EnSight6 data
-          $ENSIGHT7_HOME/user_defined_src/readers/ensight6
-
-        Sample library which reads binary static plot3d data
-          $ENSIGHT7_HOME/user_defined_src/readers/plot3d
-
-        Reads binary LS-DYNA3D state database
-          $ENSIGHT7_HOME/user_defined_src/readers/ls-dyna3d
-
-        Reads FORTRAN binary Unstructured dytran data base
-          $ENSIGHT7_HOME/user_defined_src/readers/dytran
-
-        Reads FlowScience "flsgrf" flow3d data
-          $ENSIGHT7_HOME/user_defined_src/readers/flow3d
-
-        Reads Tecplot "plt" files
-          $ENSIGHT7_HOME/user_defined_src/readers/tecplot
-
-        Reads Common File Format data
-          $ENSIGHT7_HOME/user_defined_src/readers/cff
-
-        Reads Cobalt grid and picture/restart file data
-          $ENSIGHT7_HOME/user_defined_src/readers/cobalt
- 
-        Reads binary Nastran OP2 data base
-          $ENSIGHT7_HOME/user_defined_src/readers/nastran
-
-        Reads binary and ascii cfx data
-          $ENSIGHT7_HOME/user_defined_src/readers/cfx4
-
-        Reads Exodus II data base
-          $ENSIGHT7_HOME/user_defined_src/readers/exodus
-
-        Reads Parallel Exodus data base
-          $ENSIGHT7_HOME/user_defined_src/readers/pxi
-
-        Reads FORTRAN binary SCRYU data
-          $ENSIGHT7_HOME/user_defined_src/readers/scryu
-
-        Reads binary and ascii STL data
-          $ENSIGHT7_HOME/user_defined_src/readers/stl
-
-        Reads Vectis data
-          $ENSIGHT7_HOME/user_defined_src/readers/vectis
-
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-        routines are called, which is provided in this file, along with
-        the example libraries, should make it possible for you to produce
-        code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-   This is a compiling and loading process which varies according to
-   the type of machine you are on.  In the user-defined-reader source
-   tree we have tried to isolate the machine dependent parts of the
-   build process using a set of files in the 'config' directory.  In this
-   directory there is a configuration file for each platform on which
-   EnSight is supported.  Before you can compile the installed readers
-   you should run the script called 'init' in the config directory.
-
-      i.e.  (for UNIX)
-            cd config
-            ./init sgi_6.5_n64
-            cd ..
-            make
-
-   If you are compiling for Windows NT, there are two options.  If you
-   have the Cygwin GNU utilities installed, you can use GNU make as for
-   Unix.  Otherwise, there is a script called makeall.cmd which will
-   build all of the readers using nmake.  The Makefiles in each reader
-   directory will work using either make or nmake.
-
-      i.e.  (WIN32 Cygwin)                 (using nmake)
-            cd config                      cd config
-            sh init win32                  cp win32 config
-            cd ..                          cd ..
-                                           mkdir lib
-            make                           makeall.cmd
-
-   If you have platform-specific portions of code in your reader, the
-   build system defines a set of flags which can be used within
-   #ifdef ... #endif regions in your source, as shown in the table
-   below.
-
-   Because the readers are now dynamically opened by EnSight, you may
-   have to include dependent libraries on your link-line to avoid having
-   unresolved symbols.  If you are having problems with a reader, start
-   ensight as "ensight7 -readerdbg" and you will get feedback on any
-   problems encountered in loading a reader.  If there are unresolved
-   symbols, you need to find the library which contains the missing
-   symbols and link it into your reader by adding it to the example
-   link commands below.
-
-   If you choose to use a different build environment for your reader,
-   you should take care to use compatible compilation flags to ensure
-   compatibilty with the EnSight executables, most notably on the SGI
-   and HP-UX 11.0 platforms, which should use the following flags:
-
-      sgi_6.2_o32: -mips2
-      sgi_6.2_n64: -mips4 -64
-      sgi_6.5_n32: -mips3
-      sgi_6.5_n64: -mips4 -64
-       hp_11.0_32: +DA2.0
-       hp_11.0_64: +DA2.0W
-
-    ______________________________________________________________________
-   | MACHINE | OS flag               |  SHARED LIBRARY NAME PRODUCED      |
-   |  TYPE   |------------------------------------------------------------|
-   |         |         LD COMMAND USED IN MAKEFILE                        |
-    ======================================================================
-    ______________________________________________________________________
-   | sgi     | -DSGI                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o              |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | hp      | -DHP                  |  libuserd-X.sl                     |
-   |         |------------------------------------------------------------|
-   |         | ld -b -o libuserd-X.sl libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | sun     | -DSUN                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | dec     | -DDEC                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o -lc          |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | linux   | -DLINUX               |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | alpha   | -DALINUX              |  libuserd-X.so                     |
-   | linux   |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | ibm     | -DIBM                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o -bnoentry -bexpall -lc |
-    ----------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice or in the standard reader location:
-
-      $ENSIGHT7_HOME/machines/$ENSIGHT7_ARCH/lib_readers
-
-   For example, if you created a reader for "mydata", you should create
-   the reader libuserd-mydata.so and place the file in your own reader
-   directory (see section 3 below) or in the standard location:
-
-      $ENSIGHT7_HOME/machines/$ENSIGHT7_ARCH/lib_readers/libuserd-mydata.so
-
-
-3. By default EnSight will load all readers found in the directory:
-
-      $ENSIGHT7_HOME/machines/$ENSIGHT7_ARCH/lib_readers
-
-   Files with names "libuserd-X.so" (where X is a name unique to the reader)
-   are assumed to be user-defined readers.
-
-   There are two methods which can be used to supplement the default
-   behavior.
-
-   (1) A feature which is useful for site-level or user-level configuration
-       is the optional environment variable $ENSIGHT7_READER.  This
-       variable directs EnSight to load all readers in the specified reader
-       directory (you should probably specify a full path) before loading
-       the built-in readers.  If the same reader exists in both directories
-       (as determined by the name returned by USERD_get_name_of_reader(),
-       NOT by the filename), the locally configured reader will take
-       precedence.
-
-   (2) A useful feature for end-users is the use of the libuserd-devel
-       reader.  EnSight will search for a reader named libuserd-devel.so
-       (.sl for HP or .dll for NT).  This reader can exist anywhere in the
-       library path (see below) of the user.  This is useful for an
-       individual actively developing a reader because the existence of a
-       libuserd-devel library will take precedence over any other library
-       which returns the same name from USERD_get_name_of_reader().
-
-   As an example, a site may install commonly used readers in a common
-   location, and users can set the ENSIGHT7_READER variable to access them:
-
-      setenv ENSIGHT7_READER /usr/local/lib/e7readers
-  
-   A user working on a new reader may compile the reader and place it in
-   a directory specified by the library path:
-
-      cp libuserd-myreader.so ~/lib/libuserd-devel.so
-      setenv <librarypath> ~/lib:$<librarypath>
-
-   The user is responsible for correctly configuring the library path
-   variable in order to make use of the libuserd-devel feature.  The
-   library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        linux           LD_LIBRARY_PATH
-        alpha linux     LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-As always, EnSight support is available if you need it.
-
-
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_number_of_global_nodes              number of global nodes
-USERD_get_global_coords                       global node coordinates
-USERD_get_global_node_ids                     global node ids
-USERD_get_element_connectivities_for_part     part's element connectivites
-USERD_get_element_ids_for_part                part's element ids
-USERD_get_scalar_values                       global scalar variables
-USERD_get_vector_values                       global vector variables
-
-
-Generally Needed for BLOCK data
------------------------------------------
-USERD_get_block_coords_by_component           block coordinates
-USERD_get_block_iblanking                     block iblanking values
-USERD_get_block_scalar_values                 block scalar variables
-USERD_get_block_vector_values_by_component    block vector variables 
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_set_filenames                           filenames entered in GUI
-USERD_set_time_step                           current time step
-
-USERD_get_name_of_reader                      name of reader for GUI
-USERD_get_number_of_files_in_dataset          number of files in model
-USERD_get_dataset_query_file_info             info about each model file
-USERD_get_changing_geometry_status            changing geometry?
-USERD_get_node_label_status                   node labels?
-USERD_get_element_label_status                element labels?
-USERD_get_number_of_time_steps                number of time steps
-USERD_get_solution_times                      solution time values
-USERD_get_description_lines                   file associated descrip lines
-USERD_get_number_of_variables                 number of variables
-USERD_get_variable_info                       variable type/descrip etc.
-USERD_get_constant_value                      constant variable's value
-USERD_get_number_of_model_parts               number of model parts
-USERD_get_part_build_info                     part type/descrip etc.
-USERD_get_variable_value_at_specific          node's or element's variable
-                                                 value over time
-
-USERD_stop_part_building                      cleanup routine
-USERD_bkup                                    archive routine
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-
-2. Setting filenames and getting time info
-        USERD_set_filenames
-        USERD_get_number_of_time_steps
-        USERD_get_solution_times
-        USERD_set_time_step
-
-3. Gathering info for part builder
-
-        USERD_set_time_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_description_lines             (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords                 (for model extents)
-        USERD_get_block_coords_by_component     (for model extents)
-
-4. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_variable_info
-              
-5. Part building (per part created)
-
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-6. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_step
-        USERD_get_constant_value
-          
-        scalars:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_scalar_values
-        USERD_get_block_scalar_values
-
-        vectors:
-        -------
-        USERD_get_description_lines
-        USERD_set_time_step
-        USERD_get_vector_values
-        USERD_get_block_vector_values_by_component
-
-7. Changing geometry
-
-        changing coords only:
-        --------------------
-        USERD_set_time_step
-        USERD_get_global_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity:
-        ---------------------
-        USERD_set_time_step
-        USERD_get_number_of_model_parts
-        USERD_get_part_build_info
-        USERD_get_number_global_nodes
-        USERD_get_global_coords
-        USERD_get_global_node_ids
-        USERD_get_element_connectivities_for_part
-        USERD_get_element_ids_for_part
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-  
-8. Node or Element queries over time
-
-        USERD_get_variable_value_at_specific
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines.
-
-       #include "global_extern.h"
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available      = 0;
-static int Num_unstructured_parts  = 0;
-static int Num_structured_blocks   = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_time_steps          = 1;
-static int Num_global_nodes        = 0;
-static int Num_variables           = 0;
-static int Num_dataset_files       = 0;
-static int Current_time_step       = 0;
-
-
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
-
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given scalar variable
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given scalar variable
-
-   Specification:
-   -------------
-   int USERD_get_block_scalar_values(int block_number,
-                                     int which_scalar,
-                                     float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-   (IN)  which_scalar            = The variable number
-   (OUT) scalar_array            = 1D array containing scalar values
-                                   for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some scalar type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_vector_values_by_component
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each node of a block, for a given vector
-     variable, one component at a time.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a block, for a given vector
-     variable, one component at a time.
-
-
-   Specification:
-   -------------
-   int USERD_get_block_vector_values_by_component(int block_number,
-                                                  int which_vector,
-                                                  int which_component,
-                                                  float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) vector_array            = 1D array containing vector
-                                   component value for each node or element.
-
-                                   Array will have been allocated:
-        
-                                   if Z_PER_NODE:
-                                      i*j*k for the block long
-
-                                   if Z_PER_ELEM:
-                                      (i-1)*(i-1)*(k-1) for the block long
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0,
-     Num_variables is > 0, and there are some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.
-
-
-
---------------------------------------------------------------------
-USERD_get_constant_value
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine) (Is a long)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_MAXFILENP is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-
-
-
---------------------------------------------------------------------
-USERD_get_description_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_description_lines(int which_type,
-                                   int which_var,
-                                   char line1[Z_BUFL],
-                                   char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_connectivities_for_part
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of an unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_element_connectivities_for_part(int part_number,
-                                                 int **conn_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) conn_array              = 3D array containing connectivity
-                                   of each element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type by connectivity length
-                                   of each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25][3]
-                              conn_array[Z_QUA04][100][4]
-                              conn_array[Z_HEX08][30][8]
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array loaded in USERD_get_global_coords is zero-based,
-     but within EnSight it will become a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array in
-          USERD_get_global_coords as follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array here as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
-
-
---------------------------------------------------------------------
-USERD_get_element_ids_for_part
-
-   Description:
-   -----------
-   Gets the ids for the elements of an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_element_ids_for_part(int part_number,
-                                      int *elemid_array[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-
-   (OUT) elemid_array            = 2D array containing id of each
-                                   element of each type.
-
-                                  (Array will have been allocated
-                                   Z_MAXTYPE by num_of_elements of
-                                   each type)
-
-                       ex) If num_of_elements[Z_TRI03] = 25
-                              num_of_elements[Z_QUA04] = 100
-                              num_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[Z_TRI03][25]
-                              conn_array[Z_QUA04][100]
-                              conn_array[Z_HEX08][30]
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and element
-     label status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-         USERD_get_element_ids_for_part is used to obtain the ids,
-         on a part by part basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_global_coords
-
-   Description:
-   -----------
-   Gets the coordinates for the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_coords(CRD *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) coord_array             = 1D array of CRD structures,
-                                   which contains x,y,z coordinates
-                                   of each node.
-
-                                  (Array will have been allocated
-                                   Num_global_nodes long)
-
-    For reference, CRD structure (which is in global_extern) is:
-
-         typedef struct {
-            float xyz[3];
-         }CRD;
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * The coord_array is zero-based, but within EnSight it will become
-     a one-based array.
-     Thus, coord_array[0] will be accessed by node 1 from the conn_array,
-           coord_array[1] will be accessed by node 2 from the conn_array, etc.
-
-      ex) Given a model of two triangles, you should load coord_array as
-          follows:
-
-                            node  coordinates
-                            ----  -----------
-          4 --------- 3      1    coord_array[0].xyz[0] = 0.0
-           |\        |            coord_array[0].xyz[1] = 0.0
-           | \  T2   |            coord_array[0].xyz[2] = 0.0
-           |  \      |
-           |   \     |       2    coord_array[1].xyz[0] = 1.0
-           |    \    |            coord_array[1].xyz[1] = 0.0
-           |     \   |            coord_array[1].xyz[2] = 0.0
-           |      \  |
-           |  T1   \ |       3    coord_array[2].xyz[0] = 1.0
-           |        \|            coord_array[2].xyz[1] = 1.6
-          1 --------- 2           coord_array[2].xyz[2] = 0.0
-
-                             4    coord_array[3].xyz[0] = 0.0
-                                  coord_array[3].xyz[1] = 1.6
-                                  coord_array[3].xyz[2] = 0.0
-
-
-        And conn_array in USERD_get_element_connectivities_for_part
-        as follows:
-                                               
-        Triangle  Connectivity
-        --------  ------------
-           T1     conn_array[Z_TRI03][0][0] = 1
-                  conn_array[Z_TRI03][0][1] = 2
-                  conn_array[Z_TRI03][0][2] = 4
-
-           T2     conn_array[Z_TRI03][1][0] = 2
-                  conn_array[Z_TRI03][1][1] = 3
-                  conn_array[Z_TRI03][1][2] = 4
-
---------------------------------------------------------------------
-USERD_get_global_node_ids
-
-   Description:
-   -----------
-   Gets the node ids assigned to each of the global nodes.
-
-   Specification:
-   -------------
-   int USERD_get_global_node_ids(int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node. The ids must be > 0
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and node label
-     status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Provide a name for your custom reader format.
-
-   * If you don't want a custom reader to show up in the data dialog
-     choices, return a name of "No_Custom"
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  The must also be
-       positive numbers greater than zero.
-
-         USERD_get_global_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         Also be aware that if you say node labels are available,
-         the connectivity of elements must be according to these
-         node ids.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_global_nodes
-
-   Description:
-   -----------
-   Gets the number of global nodes, used for unstructured parts.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_global_nodes()
-
-   Returns:
-   -------
-   Number of global nodes (>=0 if okay, <0 if problems)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-   * For unstructured data:
-           EnSight wants  1. A global array of nodes
-                          2. Element connectivities by part, which
-                             reference the node numbers of the global
-                             node array.
-                IMPORTANT:
-                ---------
-                If you provide node ids, then element connectivities
-                must be in terms of the node ids.  If you do not
-                provide node ids, then element connectivities must be
-                in terms of the index into the node array, but shifted
-                to start at 1
-
-   * Num_global_nodes would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if probs).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_time_steps( void )
-
-   Returns:
-   -------
-   Number of time steps  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, and vector types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_part_build_info(int *part_numbers,
-                                 int *part_types,
-                                 char *part_description[Z_BUFL],
-                                 int *number_of_elements[Z_MAXTYPE],
-                                 int *ijk_dimensions[3],
-                                 int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) part_numbers           = Array containing part numbers for
-                                  each of the model parts.
-
-                                  IMPORTANT:
-                                   Parts numbers must be >= 1
-
-            ********************************************
-             The numbers provided here are the ones by
-             which the parts will be referred to in any
-             of the other routines which receive a part
-             number or block number as an argument!! 
-            ********************************************
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimensions
-                                  for each structured model part.
-                                           ----------
-                                  (Ignored if Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 3 long)
-
-                             ijk_dimensions[][0] = I dimension
-                             ijk_dimensions[][1] = J dimension
-                             ijk_dimensions[][2] = K dimension
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_scalar_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given scalar variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given scalar variable.
-
-   Specification:
-   -------------
-   int USERD_get_scalar_values(int which_scalar,
-                               int which_part,
-                               int which_type,
-                               float *scalar_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_scalar            = The variable number (of scalar type)
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) scalar_array 
-
-            if Z_PER_NODE:       = 1D array containing scalar values
-                                    for each node.
-
-                                   (Array will have been allocated
-                                    Num_global_nodes long)
-
-            if Z_PER_ELEM:       = 1d array containing scalar values for
-                                   each element of a particular part and type.
-                                    
-                                   (Array will have been allocated
-                                    number_of_elements[which_part][which_type]
-                                    long.  See USERD_get_part_build_info)
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0, and you have some scalar type variables.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_solution_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step.
-
-   Specification:
-   -------------
-   int USERD_get_solution_times(float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) solution_times       = 1D array of solution times/time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_variable_info(char **var_description,
-                               char **var_filename,
-                               int *var_type,
-                               int *var_classify)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_filename         = Variable filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-              etc.
-
-
-
---------------------------------------------------------------------
-USERD_get_variable_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_variable_value_at_specific(int which_var,
-                                            int which_node_or_elem,
-                                            int which_part,
-                                            int which_elem_type,
-                                            int time_step,
-                                            float values[3])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-              If Z_PER_NODE:
-                = The node number.  This is not the id, but is
-                                    the index of the global node 
-                                    list (1 based), or the block's
-                                    node list (1 based).
-
-                  Thus,  coord_array[1]
-                         coord_array[2]
-                         coord_array[3]
-                              .      |
-                              .      |which_node_or_elem index
-                              .             ----
-
-
-              If Z_PER_ELEM:
-                = The element number.  This is not the id, but is
-                                       the element number index
-                                       of the number_of_element array
-                                       (see USERD_get_part_build_info),
-                                        or the block's element list (1 based).
-
-                            Thus,  for which_part:
-                                   conn_array[which_elem_type][0]
-                                   conn_array[which_elem_type][1]
-                                   conn_array[which_elem_type][2]
-                                        .                      |
-                                        .          which_node_or_elem index
-                                        .                        ----
-
-
-   (IN)  which_part
-
-                        If Z_PER_NODE, or block part:
-                          = Not used
-
-                        If Z_PER_ELEM:
-                          = The part number
-
-   (IN)  which_elem_type
-
-              If Z_PER_NODE, or block part:
-                = Not used
-
-              If Z_PER_ELEM:
-                = The element type.    This is the element type index
-                                       of the number_of_element array
-                                       (see USERD_get_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-
---------------------------------------------------------------------
-USERD_get_vector_values
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the values at each global node for a given vector variable.
-
-   or if Z_PER_ELEM:
-     Get the values at each element of a specific part and type for a
-     given vector variable.
-
-   Specification:
-   -------------
-   int USERD_get_vector_values(int which_vector,
-                               int which_part,
-                               int which_type,
-                               float *vector_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_vector            = The variable number
-
-   (IN)  which_part 
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The part number
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-
-   (OUT) vector_array 
-
-        if Z_PER_NODE:       = 1D array containing vector values
-                               for each node.
-
-                               (Array will have been allocated
-                                3 by Num_global_nodes long)
-
-                  Info stored in this fashion:
-                        vector_array[0] = xcomp of node 1
-                        vector_array[1] = ycomp of node 1
-                        vector_array[2] = zcomp of node 1
-
-                        vector_array[3] = xcomp of node 2
-                        vector_array[4] = ycomp of node 2
-                        vector_array[5] = zcomp of node 2
-
-                        vector_array[6] = xcomp of node 3
-                        vector_array[7] = ycomp of node 3
-                        vector_array[8] = zcomp of node 3
-                                etc.
-
-        if Z_PER_ELEM:       = 1D array containing vector values for
-                               each element of a particular part and type.
-                                    
-                             (Array will have been allocated
-                              3 by number_of_elements[which_part][which_type]
-                              long.  See USERD_get_part_build_info)
-
-                  Info stored in this fashion:
-                       vector_array[0] = xcomp of elem 1 (of part and type)
-                       vector_array[1] = ycomp of elem 1         "
-                       vector_array[2] = zcomp of elem 1         "
-
-                       vector_array[3] = xcomp of elem 2         "
-                       vector_array[4] = ycomp of elem 2         "
-                       vector_array[5] = zcomp of elem 2         "
-
-                       vector_array[6] = xcomp of elem 3         "
-                       vector_array[7] = ycomp of elem 3         "
-                       vector_array[8] = zcomp of elem 3         "
-                               etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0,
-     Num_variables is > 0,  and you have some vector type variables
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed.
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
-
---------------------------------------------------------------------
-USERD_set_time_step
-
-   Description:
-   -----------
-   Set the current time step.  All functions that need time, and
-   that do not explicitly pass it in, will use the time step set by
-   this routine.
-
-   Specification:
-   -------------
-   void USERD_set_time_step(int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) time_step - The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step would be set here
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-
-
-
----- end of doucment ----
-
-
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_USERD_2.0
+++ /dev/null
@@ -1,2537 +0,0 @@
-README_USERD_2.0
-================
---------------------------------------
-EnSight User Defined Reader Capability   ===> (API 2.0)
---------------------------------------
-A user defined reader capability is included in EnSight which can allow
-otherwise unsupported structured or unstructured data to be read.  The user
-defined reader capability utilizes dynamic shared libraries composed of
-routines defined in this document but produced by you, the user, (or some
-third party). This capability is currently available for dec, ibm, hp, sgi,
-sun, linux, alpha linux, and NT servers.
-
-Two versions of this API are available starting with EnSight Version 7.2. The
-1.0 API (which was designed to be friendly to those producing it, but requires
-more manipulation internally by EnSight) may be a little easier to
-produce, but requires more memory and processing time.  The 2.0 API is
-considerably more efficient, and was designed more with that in mind. It
-requires that all data be provided on a part basis.
-
-If you already have a working 1.0 API reader and are happy with it - there is
-probably no reason to modify it to the 2.0 API unless:
- - you deal with large models and the memory use and load times are a
-   problem or
- - you need tensor variable support or
- - you need complex variable support or
- - you need multiple timeset capability or
- _ you want to provide your own "border" elements (as opposed to EnSight's
-                                                    computation of them).
-
-If you are producing a new reader, you should consider which will work best
-for your needs.
-
-
-API 1.0  (defined in README_USERD_1.0 document)
-=======
-The original user defined reader API (used with EnSight Versions 6 through
-7.1) will continue to be supported. (Note that there was a change in the way
-that the libraries were made at version 7.1 of EnSight, but underlying code
-was kept the same.) Thus, any readers that work with EnSight 7.1, should still
-function with EnSight 7.2.
-
-
-API 2.0  (defined in this README_USERD_2.0 document)
-=======
-This new API has been defined to be more efficient and includes access to new
-capabilities of EnSight 7.2.  It lends itself closely to the EnSight "gold"
-type format.
-
-Some of its advantages are::
-
- * Most intermediate temporary arrays have been eliminated, such that the user
-   defined routines write directly into internal part structures. This is a
-   considerable improvement in memory use, and improves speed as well since
-   far less memory need be allocated, initialized, etc.
-
- * Parts are self contained. Coordinates, connectivity and all variables are
-   provided on a part basis. This eliminates the need for several global to
-   local coordinate mapping operations and the need for node id connectivity
-   hashing.  This can greatly improve the speed at which models are loaded.
-
- * Model extents can be provided directly, such that EnSight need not read
-   all the coordinate data at load time.
-
- * Tensor variables are supported
-
- * Complex variables are supported
-
- * A routine is provided as EnSight exits, so cleanup operations such as
-   removing temporary files can be easily accomplished.
-
- * Geometry and variables can be provided on different time lines (timesets).
-
- * If your data format already provides boundary shell information, you can
-   use it instead of the "border" representation that EnSight would compute.
-
-Further discussion on the philosophical differences between the two API's and
-an efficiency comparison example can be found in the README_1.0_to_2.0 file.
-This file also contains guidance on necessary changes to modify an existing
-1.0 API to the new 2.0 API.
-
-
-****************************************************************************
-Note: A default dummy_gold reader and an Ensight Gold example of this new 2.0
-      user defined reader API has been included with your EnSight release.
-      Also, the SILO reader included in the release utilizes the 2.0 API. 
-
-      And while not identical, the API 1.0 readers might be useful to
-      examine as examples.  Many of the routines are the same or similar.
-****************************************************************************
-
-
-The process for producing a user defined reader is:
----------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy_gold library and for various other
-        working or sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $CEI_HOME/ensight76/user_defined_src/readers
-
-        examples:
-        --------
-        Basic dummy_gold routines provide skeleton for a new reader
-          $CEI_HOME/ensight76/user_defined_src/readers/dummy_gold
-
-        Sample library which reads unstructured binary EnSight Gold data
-          $CEI_HOME/ensight76/user_defined_src/readers/ensight_gold
-
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-        routines are called, which is provided in this file, along with
-        the example libraries, should make it possible for you to produce
-        code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-   This is a compiling and loading process which varies according to
-   the type of machine you are on.  In the user-defined-reader source
-   tree we have tried to isolate the machine dependent parts of the
-   build process using a set of files in the 'config' directory.  In this
-   directory there is a configuration file for each platform on which
-   EnSight is supported.  Before you can compile the installed readers
-   you should run the script called 'init' in the config directory.
-
-      i.e.  (for UNIX)
-            cd config
-            ./init sgi_6.5_n64
-            cd ..
-            make
-
-   If you are compiling for Windows NT, there are two options.  If you
-   have the Cygwin GNU utilities installed, you can use GNU make as for
-   Unix.  Otherwise, there is a script called makeall.cmd which will
-   build all of the readers using nmake.  The Makefiles in each reader
-   directory will work using either make or nmake.
-
-      i.e.  (WIN32 Cygwin)                 (using nmake)
-            cd config                      cd config
-            sh init win32                  cp win32 config
-            cd ..                          cd ..
-                                           mkdir lib
-            make                           makeall.cmd
-
-   If you have platform-specific portions of code in your reader, the
-   build system defines a set of flags which can be used within
-   #ifdef ... #endif regions in your source, as shown in the table
-   below.
-
-   Because the readers are now dynamically opened by EnSight, you may
-   have to include dependent libraries on your link-line to avoid having
-   unresolved symbols.  If you are having problems with a reader, start
-   ensight as "ensight7 -readerdbg" and you will get feedback on any
-   problems encountered in loading a reader.  If there are unresolved
-   symbols, you need to find the library which contains the missing
-   symbols and link it into your reader by adding it to the example
-   link commands below.
-
-   If you choose to use a different build environment for your reader,
-   you should take care to use compatible compilation flags to ensure
-   compatibilty with the EnSight executables, most notably on the SGI
-   and HP-UX 11.0 platforms, which should use the following flags:
-
-      sgi_6.2_o32: -mips2
-      sgi_6.2_n64: -mips4 -64
-      sgi_6.5_n32: -mips3
-      sgi_6.5_n64: -mips4 -64
-       hp_11.0_32: +DA2.0
-       hp_11.0_64: +DA2.0W
-
-    ______________________________________________________________________
-   | MACHINE | OS flag               |  SHARED LIBRARY NAME PRODUCED      |
-   |  TYPE   |------------------------------------------------------------|
-   |         |         LD COMMAND USED IN MAKEFILE                        |
-    ======================================================================
-    ______________________________________________________________________
-   | sgi     | -DSGI                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o              |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | hp      | -DHP                  |  libuserd-X.sl                     |
-   |         |------------------------------------------------------------|
-   |         | ld -b -o libuserd-X.sl libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | sun     | -DSUN                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | dec     | -DDEC                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o -lc          |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | linux   | -DLINUX               |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | alpha   | -DALINUX              |  libuserd-X.so                     |
-   | linux   |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | ibm     | -DIBM                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o -bnoentry -bexpall -lc |
-    ----------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice or in the standard reader location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   For example, if you created a reader for "mydata", you should create
-   the reader libuserd-mydata.so and place the file in your own reader
-   directory (see section 3 below) or in the standard location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers/libuserd-mydata.so
-
-
-3. By default EnSight will load all readers found in the directory:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   Files with names "libuserd-X.so" (where X is a name unique to the reader)
-   are assumed to be user-defined readers.
-
-   There are two methods which can be used to supplement the default
-   behavior.
-
-   (1) A feature which is useful for site-level or user-level configuration
-       is the optional environment variable $ENSIGHT7_READER.  This
-       variable directs EnSight to load all readers in the specified reader
-       directory (you should probably specify a full path) before loading
-       the built-in readers.  If the same reader exists in both directories
-       (as determined by the name returned by USERD_get_name_of_reader(),
-       NOT by the filename), the locally configured reader will take
-       precedence.
-
-   (2) A useful feature for end-users is the use of the libuserd-devel
-       reader.  EnSight will search for a reader named libuserd-devel.so
-       (.sl for HP or .dll for NT).  This reader can exist anywhere in the
-       library path (see below) of the user.  This is useful for an
-       individual actively developing a reader because the existence of a
-       libuserd-devel library will take precedence over any other library
-       which returns the same name from USERD_get_name_of_reader().
-
-   As an example, a site may install commonly used readers in a common
-   location, and users can set the ENSIGHT7_READER variable to access them:
-
-      setenv ENSIGHT7_READER /usr/local/lib/e7readers
-  
-   A user working on a new reader may compile the reader and place it in
-   a directory specified by the library path:
-
-      cp libuserd-myreader.so ~/lib/libuserd-devel.so
-      setenv <librarypath> ~/lib:$<librarypath>
-
-   The user is responsible for correctly configuring the library path
-   variable in order to make use of the libuserd-devel feature.  The
-   library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        linux           LD_LIBRARY_PATH
-        alpha linux     LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-As always, EnSight support is available if you need it.
-
-
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_part_coords                         part's node coordinates
-USERD_get_part_node_ids                       part's node ids
-USERD_get_part_elements_by_type               part's element connectivites
-USERD_get_part_element_ids_by_type            part's element ids
-
-
-Generally Needed for BLOCK data
---------------------------------------
-USERD_get_block_coords_by_component           block coordinates
-USERD_get_block_iblanking                     block iblanking values
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_get_name_of_reader                      name of reader for GUI
-USERD_get_reader_version                      provide reader version number
-USERD_get_reader_descrip                      provide GUI more description(optional)
-
-USERD_set_filenames                           filenames entered in GUI
-USERD_set_server_number                       server which of how many
-
-USERD_get_number_of_timesets                  number of timesets
-USERD_get_timeset_description                 description of timeset
-USERD_get_geom_timeset_number                 timeset # to use for geom
-
-USERD_get_num_of_time_steps                   number of time steps
-USERD_get_sol_times                           solution time values
-USERD_set_time_set_and_step                   current timeset and time step
-
-
-USERD_get_changing_geometry_status            changing geometry?
-USERD_get_node_label_status                   node labels?
-USERD_get_element_label_status                element labels?
-USERD_get_model_extents                       provide model bounding extents
-USERD_get_number_of_files_in_dataset          number of files in model
-USERD_get_dataset_query_file_info             info about each model file
-USERD_get_descrip_lines                       file associated description lines
-USERD_get_number_of_model_parts               number of model parts
-USERD_get_part_build_info                     part/block type/descrip etc.
-USERD_get_maxsize_info                        part/block allocation maximums
-
-USERD_get_border_availability                 part border provided?
-USERD_get_border_elements_by_type             part border conn and parent info
-
-USERD_get_number_of_variables                 number of variables
-USERD_get_gold_variable_info                  variable type/descrip etc.
-USERD_get_var_by_component                    part or block variable values
-USERD_get_constant_val                        constant variable's value
-USERD_get_var_value_at_specific               node's or element's variable
-                                                 value over time
-USERD_stop_part_building                      cleanup after part build routine
-
-USERD_bkup                                    archive routine
-
-USERD_exit_routine                            cleanup upon exit routine
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-        USERD_get_reader_descrip    (optional)
-
-2. Getting the reader version (also distinguishes between API's)
-
-        USERD_get_reader_version
-
-3. Setting filenames and getting timeset and time info
-
-        USERD_set_server_number
-        USERD_set_filenames
-        USERD_get_number_of_timesets
-        USERD_get_geom_timeset_number
-
-        for each timeset:
-          USERD_get_timeset_description
-          USERD_get_num_of_time_steps
-          USERD_get_sol_times
-
-        USERD_set_time_set_and_step
-
-4. Gathering info for part builder
-
-        USERD_set_time_set_and_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_descrip_lines                 (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_maxsize_info
-        USERD_get_model_extents     OR          (for model extents)
-             USERD_get_part_coords  AND/OR
-             USERD_get_block_coords_by_component
-
-5. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_gold_variable_info
-              
-6. Part building (per part created)
-
-        USERD_set_time_set_and_step
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-7. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_set_and_step
-        USERD_get_constant_val
-          
-        scalars/vectors/tensors:
-        ------------------------
-        USERD_get_descrip_lines
-        USERD_set_time_set_and_step
-        USERD_get_var_by_component
-
-8. Changing geometry
-
-        changing coords only (per part):
-        --------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_part_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity (per part):
-        ---------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_model_extents   OR
-           USERD_get_part_coords  AND/OR
-           USERD_get_block_coords_by_component
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-  
-9. Node or Element queries over time
-
-        USERD_get_var_value_at_specific
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available         = 0;
-static int Num_unstructured_parts     = 0;
-static int Num_structured_blocks      = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_timesets               = 1;
-static int Current_timeset            = 1;
-static int Geom_timeset_number        = 1;
-
-static int Num_time_steps[Z_MAXSETS]  = 1;
-static int Current_time_step          = 0;
-static int Num_variables              = 0;
-static int Num_dataset_files          = 0;
-
-static int Server_Number              = 1;    Which server of
-static int Tot_Servers                = 1;    the total number of servers
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
---------------------------------------------------------------------
-USERD_exit_routine
-
-   Description:
-   -----------
-   This routine is called as EnSight is exiting. It can be used to clean
-   up anything needed - such as removing temporary files, etc. - or can simply
-   be a dummy.
-
-   Specification:
-   -------------
-   void USERD_exit_routine( void )
-
-   Arguments:
-   ---------
-   none
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_border_availability
-
-   Description:
-   -----------
-   Finds out if border elements are provided by the reader for the
-   desired part, or will need to be computed internally by EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_border_availability(int part_number,
-                                     int number_of_elements[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if border elements will be provided by the reader.
-          (number_of_elements array will be loaded and
-           USERD_get_border_elements_by_type will be called)
-
-   Z_ERR if border elements are not available - thus EnSight must compute.
-          (USERD_get_border_elements_by_type will not be called)
-
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of border element in
-                                  the part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-
-   Notes:
-   -----
-   * Only called if border representation is used.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_border_elements_by_type
-
-   Description:
-   -----------
-   Provides border element connectivity and parent information. 
-
-   Specification:
-   -------------
-   int USERD_get_border_elements_by_type(int part_number,
-                                         int element_type,
-                                         int **conn_array,
-                                         short *parent_element_type,
-                                         int *parent_element_num)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT    node point element
-                                 Z_BAR02    2 node bar
-                                 Z_BAR03    3 node bar
-                                 Z_TRI03    3 node triangle
-                                 Z_TRI06    6 node triangle
-                                 Z_QUA04    4 node quad
-                                 Z_QUA08    8 node quad
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each border element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_QUA08] = 30
-                           as obtained in:
-                            USERD_get_border_availability
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_QUA08
-
-   (OUT) parent_element_type   = 1D array containing element type of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   (OUT) parent_element_num   = 1D array containing element number of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   
-   Notes:
-   -----
-   * Not called unless USERD_get_border_availability returned Z_OK
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.  Note that
-     a part is allowed to be empty (number of nodes and elements equal
-     to zero).
-
-
---------------------------------------------------------------------
-USERD_get_constant_val
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var,
-                                  int imag_data)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   (IN)  imag_data            = TRUE if want imaginary data value.
-                                FALSE if want real data value.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine) (Is a long)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_MAXFILENP is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-     (See USERD_get_number_of_files_in_dataset)
-
-
---------------------------------------------------------------------
-USERD_get_descrip_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_descrip_lines(int which_type,
-                               int which_var,
-                               int imag_data,
-                               char line1[Z_BUFL],
-                               char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (IN)  imag_data            = TRUE if want imaginary data file.
-                                FALSE if want real data file.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-         USERD_get_part_element_ids_by_type is used to obtain the ids,
-         on a per part, per type basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-
---------------------------------------------------------------------
-USERD_get_geom_timeset_number -
-
-   Description:
-   -----------
-    Gets the timeset number to be used for geometry
-
-   Specification:
-   -------------
-   int USERD_get_geom_timeset_number( void )
-
-   Returns:
-   -------
-   Geom_timeset_number = The timeset number that will be used for geometry.   
-                         For example, if USERD_get_number_of timesets
-                         returns 2, the valid timeset numbers would be
-                         1 or 2.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   *  If your model is static, which you indicated by returning a zero
-      in USERD_get_number_of_timesets, you can return a zero here as well.
-
-
-
---------------------------------------------------------------------
-USERD_get_gold_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_gold_part_build_info(int *part_id,
-                                      int *part_types,
-                                      char *part_description[Z_BUFL],
-                                      int *number_of_nodes,
-                                      int *number_of_elements[Z_MAXTYPE],
-                                      int *ijk_dimensions[3],
-                                      int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-    (OUT) part_id                = Array containing the external part
-                                   ids for each of the model parts.
-  
-                                   IMPORTANT:
-                                    Parts numbers must be >= 1, because
-                                    of the way they are used in the GUI
-  
-               *******************************************
-                The ids provided here are the numbers by
-                which the parts will be referred to in the
-                GUI (if possible). They are basically
-                labels as far as you are concerned.
-  
-                Note: The part numbers you pass to routines
-                which receive a part_number or block_number
-                or which_part as an argument are the 1-based
-                table index of the parts!
-  
-                example:  If Numparts_available = 3
-  
-                          Table index        part_id
-                          -----------        -------
-                           1                  13
-                           2                  57
-                           3                  125
-  
-                           ^                   ^
-                           |                   |
-                           |                    These are placed in:
-                           |                      part_id[0] = 13
-                           |                      part_id[1] = 57
-                           |                      part_id[2] = 125
-                           |                    for GUI labeling purposes.
-                           |
-                            These implied table indices are the part_number,
-                            block_number, or which_part numbers that you would
-                            pass to routines like:
-  
-                           USERD_get_part_coords(int part_number,...
-                           USERD_get_part_node_ids(int part_number,...
-                           USERD_get_part_elements_by_type(int part_number,...
-                           USERD_get_part_element_ids_by_type(int part_number,...
-                           USERD_get_block_coords_by_component(int block_number,...
-                           USERD_get_block_iblanking(int block_number,...
-                           USERD_get_block_ghost_flags(int block_number,...
-                           USERD_get_ghosts_in_block_flag(int block_number)
-                           USERD_get_border_availability( int part_number,...
-                           USERD_get_border_elements_by_type( int part_number,...
-                           USERD_get_var_by_component(int which_variable,
-                                                      int which_part,...
-                           USERD_get_var_value_at_specific(int which_var,
-                                                           int which_node_or_elem,
-                                                           int which_part,...
-               ********************************************
-  
-                                    (Array will have been allocated
-                                     Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_nodes        = Number of unstructured nodes in the part
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimensions
-                                  for each structured model part.
-                                           ----------
-                                  (Ignored if Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 3 long)
-
-                             ijk_dimensions[][0] = I dimension
-                             ijk_dimensions[][1] = J dimension
-                             ijk_dimensions[][2] = K dimension
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_gold_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_gold_variable_info(char **var_description,
-                                    char **var_filename,
-                                    int *var_type,
-                                    int *var_classify,
-                                    int *var_complex,
-                                    char **var_ifilename,
-                                    float *var_freq,
-                                    int *var_contran,
-                                    int *var_timeset)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-           variable description restrictions:
-           ----------------------------------
-           1. Only first 19 characters used in EnSight.
-           2. Leading and trailing whitespace will be removed by EnSight.
-           3. Illegal characters will be replaced by underscores.
-           4. Thay may not start with a numeric digit.
-           4. No two variables may have the same description.
-
-
-   (OUT) var_filename         = Variable real filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-                                            Z_TENSOR
-                                            Z_TENSOR9
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   (OUT) var_complex          = TRUE if complex, FALSE otherwise
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_ifilename        = Variable imaginary filenames (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_freq             = complex frequency  (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_contran          = TRUE if constant changes per time step
-                                FALSE if constant truly same at all time steps
- 
-                                (Array will have been allocated
-                                 Num_variables long)
-
-   (OUT) var_timeset          = Timeset the variable will use (1 based).
-                                (For static models, set it to 1)
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                 For example:  If USERD_get_number_of_timesets
-                                               returns 2, the valid
-                                               timeset_number's would be 1 or 2
-
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-                                               var_complex[0]
-                                               var_ifilename[0]
-                                               var_freq[0]
-                                               var_contran[0]
-                                               var_timeset[0]
-
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-                                               var_complex[1]
-                                               var_ifilename[1]
-                                               var_freq[1]
-                                               var_contran[1]
-                                               var_timeset[1]
-              etc.
-
-
---------------------------------------------------------------------
-USERD_get_maxsize_info
-
-   Description:
-   -----------
-   Gets maximum part sizes for efficient memory allocation.
-
-   Transient models (especially those that increase in size) can cause
-   reallocations, at time step changes, to keep chewing up more and
-   more memory.   The way to avoid this is to know what the maximum
-   size of such memory will be, and allocate for this maximum initially.
-
-   Accordingly, if you choose to provide this information (it is optional),
-   EnSight will take advantage of it.
-
-
-   Specification:
-   -------------
-   int USERD_get_maxsize_info(int *max_number_of_nodes,
-                              int *max_number_of_elements[Z_MAXTYPE],
-                              int *max_ijk_dimensions[3])
-
-   Returns:
-   -------
-   Z_OK  if supplying maximum data
-   Z_ERR if not supplying maximum data, or some error occurred
-           while trying to obtain it.
-
-   Arguments:
-   ---------
-   (OUT) max_number_of_nodes    = Maximum number of unstructured nodes
-                                  in the part (over all time).
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) max_number_of_elements = 2D array containing maximum number of
-                                  each type of element for each
-                                  unstructured model part (over all time).
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) max_ijk_dimensions  = 2D array containing maximum ijk dimensions
-                               for each structured model part (over all time).
-                                           ----------
-                                (Ignored if Z_UNSTRUCTURED type)
-
-                                (Array will have been allocated
-                                 Numparts_available by 3 long)
-
-                             max_ijk_dimensions[][0] = maximum I dimension
-                             max_ijk_dimensions[][1] = maximum J dimension
-                             max_ijk_dimensions[][2] = maximum K dimension
-
-   Notes:
-   -----
-   * You need to have first called USERD_get_number_of_model_parts and
-     USERD_get_gold_part_build_info, so Numparts_available is known and
-     so EnSight will know what the type is (Z_UNSTRUCTURED, Z_STRUCTURED,
-     or Z_IBLANKED) of each part.
-
-   * This will NOT be based on Current_time_step - it is to be the maximum
-     values over all time!!
-
-   * This information is optional.  If you return Z_ERR, Ensight will still
-     process things fine, reallocating as needed, etc.  However, for
-     large transient models you will likely use considerably more memory
-     and take more processing time for the memory reallocations. So, if it
-     is possible to provide this information "up front", it is recommended
-     to do so.
-
-
-
-
---------------------------------------------------------------------
-USERD_get_model_extents
-
-   Description:
-   -----------
-   Gets the model bounding box extents.  If this routine supplys them
-   EnSight will not have to spend time doing so.  If this routine
-   returns Z_ERR, EnSight will have to take the time to touch all the
-   nodes and gather the extent info.
-
-   Specification:
-   -------------
-   int USERD_get_model_extents(float extents[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful  (whereupon EnSight will determine by reading
-                             all coords of all parts)
-
-   Arguments:
-   ---------
-   (OUT) extents[0]   = min x
-                [1]   = max x
-                [2]   = min y
-                [3]   = max y
-                [4]   = min z
-                [5]   = max z
-
-   Notes:
-   -----
-   * This will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Please be sure to provide a name for your custom
-     reader format.
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  They must also be
-       positive numbers greater than zero.
-
-         USERD_get_part_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         (Unlike API 1.0, where the connectivity of elements had to be
-          according to the node ids - API 2.0's element connectivities
-          are not affected either way by the status here.)
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-
-
---------------------------------------------------------------------
-USERD_get_num_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available for desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_num_of_time_steps( int timeset_number )
-
-   Returns:
-   -------
-   Number of time steps in timeset  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   (IN) timeset number = the timeset number
-
-                         For example: If USERD_get_number_of_timesets
-                                      returns 2, the valid
-                                      timeset_number's would be 1 and 2
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps[timeset_number] would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_timesets
-
-   Description:
-   -----------
-    Gets the number of timesets used in the model.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_timesets( void )
-
-   Returns:
-   -------
-   Number of timesets in the model
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Num_timesets would be set here
-
-   * If you have a static model, both geometry and variables, you should
-     return a value of zero.
- 
-   * If you have a transient model, then you should return one or more.
- 
-   For example:
- 
-      Geometry    Variables                                 No. of timesets
-      ---------   ------------------------------            ---------------
-      static      static                                      0
-      static      transient, all using same timeset           1
- 
-      transient   transient, all using same timeset as geom   1
- 
-      static      transient, using 3 different timesets       3
- 
-      transient   transient, using 3 different timesets and
-                             none of them the same as the
-                             geometry timeset                 4
-          etc.
- 
-   NOTE: ALL GEOMETRY MUST USE THE SAME TIMESET!!! You will have to provide
-                                                   the timeset number to use
-                                                   for geometry in:
-                                               USERD_get_geom_timeset_number
- 
-         Variables can use the same timeset as the geometry, or can use
-         other timesets. More than one variable can use the same timeset.
- 
-   example:  changing geometry at 5 steps, 0.0, 1.0, 2.0, 3.0, 4.0
-             variable 1 provided at these same five steps
-             variable 2 provided at 3 steps, 0.5, 1.25, 3.33
- 
-        This routine should return a value of 2, because only
-        two different timesets are needed. Timeset 1 would be for the
-        geometry and variable 1 (they both use it). Timeset 2 would
-        be for variable 2, which needs its own in this case.
-
-
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, vector and tensor types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_coords
-
-   Description:
-   -----------
-   Gets the coordinates for an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_coords(int part_number, float **coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) coord_array             = 2D float array which contains,
-                                   x,y,z coordinates of each node
-                                   in the part.
-
-       (IMPORTANT: The second dimension of this aray is 1-based!!!)
-
-                                (Array will have been allocated
-                                 3 by (number_of_nodes + 1) for the part
-                                 long - see USERD_get_gold_part_build_info)
-
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             coord_array[3][101]
-
-                           Ignore the coord_array[0][0]
-                                      coord_array[1][0]
-                                      coord_array[2][0] locations and start
-                           the node coordinates at:
-                             coord_array[0][1]
-                             coord_array[1][1]
-                             coord_array[2][1]
-
-                             coord_array[0][2]
-                             coord_array[1][2]
-                             coord_array[2][2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_element_ids_by_type
-
-   Description:
-   -----------
-   Gets the ids for the elements of a particular type for an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_element_ids_by_type(int part_number,
-                                          int element_type,
-                                          int *elemid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type            = One of the following (See global_extern.h)
-                                   Z_POINT    node point element
-                                   Z_BAR02    2 node bar
-                                   Z_BAR03    3 node bar
-                                   Z_TRI03    3 node triangle
-                                   Z_TRI06    6 node triangle
-                                   Z_QUA04    4 node quad
-                                   Z_QUA08    8 node quad
-                                   Z_TET04    4 node tetrahedron
-                                   Z_TET10   10 node tetrahedron
-                                   Z_PYR05    5 node pyramid
-                                   Z_PYR13   13 node pyramid
-                                   Z_PEN06    6 node pentahedron
-                                   Z_PEN15   15 node pentahedron
-                                   Z_HEX08    8 node hexahedron
-                                   Z_HEX20   20 node hexahedron
-
-   (OUT) elemid_array            = 1D array containing id of each
-                                   element of the type.
-
-                                  (Array will have been allocated
-                                   number_of_elements of the type long)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25]   when called with Z_TRI03
-
-                              conn_array[100]  when called with Z_QUA04
-
-                              conn_array[30]  when called with Z_HEX08
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and element
-     label status is TRUE
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_part_elements_by_type
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of a particular type in an
-   unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_part_elements_by_type(int part_number,
-                                       int element_type,
-                                       int **conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT    node point element
-                                 Z_BAR02    2 node bar
-                                 Z_BAR03    3 node bar
-                                 Z_TRI03    3 node triangle
-                                 Z_TRI06    6 node triangle
-                                 Z_QUA04    4 node quad
-                                 Z_QUA08    8 node quad
-                                 Z_TET04    4 node tetrahedron
-                                 Z_TET10   10 node tetrahedron
-                                 Z_PYR05    5 node pyramid
-                                 Z_PYR13   13 node pyramid
-                                 Z_PEN06    6 node pentahedron
-                                 Z_PEN15   15 node pentahedron
-                                 Z_HEX08    8 node hexahedron
-                                 Z_HEX20   20 node hexahedron
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_HEX08
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_node_ids
-
-   Description:
-   -----------
-   Gets the node ids of an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_node_ids(int part_number, int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node in the part.
-
-           (IMPORTANT: This array is 1-based!!!)
-
-                                   (Array will have been allocated
-                                    (number_of_nodes + 1) for the part long
-                                    see USERD_get_gold_part_build_info)
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             nodeid_array[101]
-
-                           Ignore the nodeid_array[0] location and start
-                           the node ids at:
-                             nodeid_array[1]
-
-                             nodeid_array[2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0  and node label
-     status is TRUE
-
-   * Will be based on Current_time_step
-
-   * The ids are purely labels, used when displaying or querying node ids.
-     However, any node id < 0 will never be displayed
-
-
---------------------------------------------------------------------
-USERD_get_reader_descrip
-
-   Description:
-   -----------
-   Gets the description of the reader, so gui can give more info
-
-   Specification:
-   -------------
-   int USERD_get_reader_descrip(char descrip[Z_MAXFILENP])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) descrip  = the description of the reader (max length is MAXFILENP,
-                                                   which is 255)
-
-   Notes:
-   -----
-   * OPTIONAL ROUTINE!   You can have it or not.
-
-
---------------------------------------------------------------------
-USERD_get_reader_version
-
-   Description:
-   -----------
-   Gets the version number of the user defined reader
-
-   Specification:
-   -------------
-   int USERD_get_reader_version(char version_number[Z_MAX_USERD_NAME])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful (and will assume is version 1.0)
-
-   Arguments:
-   ---------
-   (OUT) version_number       = the version number of the reader
-                                (max length is Z_MAX_USERD_NAME, which
-                                 is 20)
-
-   Notes:
-   -----
-   * This needs to be "2.000" or greater. Otherwise EnSight will assume
-     this reader is API 1.0 instead of 2.0
-
-
-
---------------------------------------------------------------------
-USERD_get_sol_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step for 
-   desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_sol_times(int timeset_number,
-                           float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) solution_times       = 1D array of solution times per time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps[timeset_number] long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_timeset_description -
-
-   Description:
-   -----------
-   Get the description to associate with the desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_timeset_description(int timeset_number,
-                                     char timeset_description[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) timeset_description  = timeset description string
-
-
-   Notes:
-   -----
-   * A string of NULLs is valid for timeset_description
-
-
-
-
---------------------------------------------------------------------
-USERD_get_var_by_component
-
-   Description:
-   -----------
-   Gets the values of a variable component.  Both unstructured and structured
-   parts use this routine.
-
-   if Z_PER_NODE:
-     Get the component value at each node for a given variable in the part.
-
-   or if Z_PER_ELEM:
-     Get the component value at each element of a specific part and type
-     for a given variable.
-
-   Specification:
-   -------------
-   int USERD_get_var_by_component(int which_variable,
-                                  int which_part,
-                                  int var_type,
-                                  int which_type,
-                                  int imag_data,
-                                  int component,
-                                  float *var_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   or:  Z_UNDEF, in which case you need not load any values into var_array
-
-
-   Arguments:
-   ---------
-   (IN)  which_variable          = The variable number
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-  
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-  
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-   (IN)  var_type                = Z_SCALAR
-                                   Z_VECTOR
-                                   Z_TENSOR   (symmetric tensor)
-                                   Z_TENSOR9  (asymmetric tensor)
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-                                   Z_POINT    node point element
-                                   Z_BAR02    2 node bar
-                                   Z_BAR03    3 node bar
-                                   Z_TRI03    3 node triangle
-                                   Z_TRI06    6 node triangle
-                                   Z_QUA04    4 node quad
-                                   Z_QUA08    8 node quad
-                                   Z_TET04    4 node tetrahedron
-                                   Z_TET10   10 node tetrahedron
-                                   Z_PYR05    5 node pyramid
-                                   Z_PYR13   13 node pyramid
-                                   Z_PEN06    6 node pentahedron
-                                   Z_PEN15   15 node pentahedron
-                                   Z_HEX08    8 node hexahedron
-                                   Z_HEX20   20 node hexahedron
-
-   (IN)  imag_data               = TRUE if imag component
-                                   FALSE if real component
- 
-   (IN)  component               = The component: (0       if Z_SCALAR)
-                                                  (0 - 2   if Z_VECTOR)
-                                                  (0 - 5   if Z_TENSOR)
-                                                  (0 - 8   if Z_TENSOR9)
- 
-                                 * 6 Symmetric Indicies, 0:5    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = |    22 23 | = |   1 5 | *
-                                 *     |          |   |       | *
-                                 *     |       33 |   |     2 | *
- 
-
-                                 * 9 General   Indicies, 0:8    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = | 21 22 23 | = | 6 1 5 | *
-                                 *     |          |   |       | *
-                                 *     | 31 32 33 |   | 7 8 2 | *
-
-   (OUT) var_array 
-
-      -----------------------------------------------------------------------
-      (IMPORTANT: this array is 1-based for both Z_PER_NODE and Z_PER_ELEM!!!)
-      -----------------------------------------------------------------------
-
-            if Z_PER_NODE:    = 1D array containing variable component value
-                                for each node.
-
-                                (Array will have been allocated
-                                 (number_of_nodes + 1) long)
-
-                      Info stored in this fashion:
-                            var_array[0] = not used
-                            var_array[1] = var component for node 1 of part
-                            var_array[2] = var_component for node 2 of part
-                            var_array[3] = var_component for node 3 of part
-                            etc.
-
-            if Z_PER_ELEM:    = 1D array containing variable component
-                                value for each element of a particular
-                                part and type.
-                                    
-                              (Array will have been allocated
-                               (number_of_elements[which_part][which_type] + 1)
-                                long.  See USERD_get_gold_part_build_info)
-
-                  Info stored in this fashion:
-                    var_array[1] = var component for elem 1 (of part and type)
-                    var_array[2] = var component for elem 2 (of part and type)
-                    var_array[3] = var component for elem 3 (of part and type)
-                    etc.
-
-   Notes:
-   -----
-   * Not called unless Num_variables is > 0
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-   * If the variable is not defined for this part, simply return with a
-     value of Z_UNDEF.  EnSight will treat the variable as undefined for
-     this part.
-
-
---------------------------------------------------------------------
-USERD_get_var_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_var_value_at_specific(int which_var,
-                                       int which_node_or_elem,
-                                       int which_part,
-                                       int which_elem_type,
-                                       int time_step,
-                                       float values[3],
-                                       int imag_data)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-              If Z_PER_NODE:
-                = The node number.  This is not the id, but is
-                                    the index of the global node 
-                                    list (1 based), or the block's
-                                    node list (1 based).
-
-                  Thus,  coord_array[1]
-                         coord_array[2]
-                         coord_array[3]
-                              .      |
-                              .      |which_node_or_elem index
-                              .             ----
-
-
-              If Z_PER_ELEM:
-                = The element number.  This is not the id, but is
-                                       the element number index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info),
-                                        or the block's element list (1 based).
-
-                  Thus,  for which_part:
-                         conn_array[which_elem_type][0]
-                         conn_array[which_elem_type][1]
-                         conn_array[which_elem_type][2]
-                              .                      |
-                              .          which_node_or_elem index
-                              .                        ----
-
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-  
-                                    (1-based index of part table, namely:
-  
-                                       1 ... Numparts_available.
-  
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-  
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-   (IN)  which_elem_type
-
-              If Z_PER_NODE, or block part:
-                = Not used
-
-              If Z_PER_ELEM:
-                = The element type.    This is the element type index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (IN)  imag_data   = TRUE if want imaginary value.
-                       FALSE if want real value.
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * The time step given is for the proper variable timeset.
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed. The user written code must manage its own files!!
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-                     = FALSE normally.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
---------------------------------------------------------------------
-USERD_set_server_number
-
-   Description:
-   -----------
-   Receives the server number of how many total servers.
-
-   Specification:
-   -------------
-   int USERD_set_server_number(int cur_serv,
-                               int tot_servs)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) cur_serv    = the current server.
-
-   (IN) tot_servs   = the total number of servers.
-
-   Notes:
-   -----
-   * Only useful if your user defined reader is being used with EnSight's
-     Server-of-Server capability.  And even then, it may or may not be
-     something that you can take advantage of.  If your data is already
-     partitioned in some manner, such that you can access the proper
-     portions using this information.
- 
-     For all non-SOS uses, this will simply be 1 of 1
-
-
-
---------------------------------------------------------------------
-USERD_set_time_set_and_step
-
-   Description:
-   -----------
-   Set the current time step in the desired timeset.  All functions that
-   need time, and that do not explicitly pass it in, will use the timeset
-   and step set by this routine, if needed.
-
-   Specification:
-   -------------
-   void USERD_set_time_set_and_step(int timeset_number,
-                                    int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) timeset_number  = the timeset number (1 based).
- 
-                          For example:  If USERD_get_number_of_timesets
-                                        returns 2, the valid timeset_number's
-                                        would be 1 and 2.
-
-   (IN) time_step       = The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step and Current_timeset would be set here
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-
-
----- end of doucment ----
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_USERD_2.01
+++ /dev/null
@@ -1,2787 +0,0 @@
-README_USERD_2.01
-=================
---------------------------------------
-EnSight User Defined Reader Capability   ===> (API 2.01)
---------------------------------------
-A user defined reader capability is included in EnSight which can allow
-otherwise unsupported structured or unstructured data to be read.  The user
-defined reader capability utilizes dynamic shared libraries composed of
-routines defined in this document but produced by you, the user, (or some
-third party). This capability is currently available for dec, ibm, hp, sgi,
-sun, linux, alpha linux, and NT servers.
-
-You should refer to beginning of README_USERD_2.0  and/or README_1.0_to_2.0
-for a discussion of the differences between API 1.0 and API 2.*.
-
-
-***>> API 2.01 adds the capabilty of handling ghost cells.
-
-
-API 2.01  (defined in this README_USERD_2.01 document)
-========
-This new API has been defined to be more efficient and includes access to new
-capabilities of EnSight 7.4.  It lends itself closely to the EnSight "gold"
-type format.
-
-Some of its advantages are::
-
- * Most intermediate temporary arrays have been eliminated, such that the user
-   defined routines write directly into internal part structures. This is a
-   considerable improvement in memory use, and improves speed as well since
-   far less memory need be allocated, initialized, etc.
-
- * Parts are self contained. Coordinates, connectivity and all variables are
-   provided on a part basis. This eliminates the need for several global to
-   local coordinate mapping operations and the need for node id connectivity
-   hashing.  This can greatly improve the speed at which models are loaded.
-
- * Model extents can be provided directly, such that EnSight need not read
-   all the coordinate data at load time.
-
- * Tensor variables are supported
-
- * Complex variables are supported
-
- * A routine is provided as EnSight exits, so cleanup operations such as
-   removing temporary files can be easily accomplished.
-
- * Geometry and variables can be provided on different time lines (timesets).
-
- * If your data format already provides boundary shell information, you can
-   use it instead of the "border" representation that EnSight would compute.
-
- * Ghost cells are supported, for both unstructured and structured models.
-
-
-****************************************************************************
-Note: A default dummy_gold reader and an Ensight Gold example of this new 2.01
-      user defined reader API has been included with your EnSight release.
-      Also, the SILO and ExodusII_gold reader included in the release
-      utilizes the 2.01 API. 
-****************************************************************************
-
-
-The process for producing a user defined reader is:
----------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy_gold library and for various other
-        working or sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $CEI_HOME/ensight76/user_defined_src/readers
-
-        examples:
-        --------
-        Basic dummy_gold routines provide skeleton for a new reader
-          $CEI_HOME/ensight76/user_defined_src/readers/dummy_gold
-
-        Sample library which reads unstructured binary EnSight Gold data
-          $CEI_HOME/ensight76/user_defined_src/readers/ensight_gold
-
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-        routines are called, which is provided in this file, along with
-        the example libraries, should make it possible for you to produce
-        code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-   This is a compiling and loading process which varies according to
-   the type of machine you are on.  In the user-defined-reader source
-   tree we have tried to isolate the machine dependent parts of the
-   build process using a set of files in the 'config' directory.  In this
-   directory there is a configuration file for each platform on which
-   EnSight is supported.  Before you can compile the installed readers
-   you should run the script called 'init' in the config directory.
-
-      i.e.  (for UNIX)
-            cd config
-            ./init sgi_6.5_n64
-            cd ..
-            make
-
-   If you are compiling for Windows NT, there are two options.  If you
-   have the Cygwin GNU utilities installed, you can use GNU make as for
-   Unix.  Otherwise, there is a script called makeall.cmd which will
-   build all of the readers using nmake.  The Makefiles in each reader
-   directory will work using either make or nmake.
-
-      i.e.  (WIN32 Cygwin)                 (using nmake)
-            cd config                      cd config
-            sh init win32                  cp win32 config
-            cd ..                          cd ..
-                                           mkdir lib
-            make                           makeall.cmd
-
-   If you have platform-specific portions of code in your reader, the
-   build system defines a set of flags which can be used within
-   #ifdef ... #endif regions in your source, as shown in the table
-   below.
-
-   Because the readers are now dynamically opened by EnSight, you may
-   have to include dependent libraries on your link-line to avoid having
-   unresolved symbols.  If you are having problems with a reader, start
-   ensight as "ensight7 -readerdbg" and you will get feedback on any
-   problems encountered in loading a reader.  If there are unresolved
-   symbols, you need to find the library which contains the missing
-   symbols and link it into your reader by adding it to the example
-   link commands below.
-
-   If you choose to use a different build environment for your reader,
-   you should take care to use compatible compilation flags to ensure
-   compatibilty with the EnSight executables, most notably on the SGI
-   and HP-UX 11.0 platforms, which should use the following flags:
-
-      sgi_6.2_o32: -mips2
-      sgi_6.2_n64: -mips4 -64
-      sgi_6.5_n32: -mips3
-      sgi_6.5_n64: -mips4 -64
-       hp_11.0_32: +DA2.0
-       hp_11.0_64: +DA2.0W
-
-    ______________________________________________________________________
-   | MACHINE | OS flag               |  SHARED LIBRARY NAME PRODUCED      |
-   |  TYPE   |------------------------------------------------------------|
-   |         |         LD COMMAND USED IN MAKEFILE                        |
-    ======================================================================
-    ______________________________________________________________________
-   | sgi     | -DSGI                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o              |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | hp      | -DHP                  |  libuserd-X.sl                     |
-   |         |------------------------------------------------------------|
-   |         | ld -b -o libuserd-X.sl libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | sun     | -DSUN                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | dec     | -DDEC                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o -lc          |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | linux   | -DLINUX               |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | alpha   | -DALINUX              |  libuserd-X.so                     |
-   | linux   |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | ibm     | -DIBM                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o -bnoentry -bexpall -lc |
-    ----------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice or in the standard reader location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   For example, if you created a reader for "mydata", you should create
-   the reader libuserd-mydata.so and place the file in your own reader
-   directory (see section 3 below) or in the standard location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers/libuserd-mydata.so
-
-
-3. By default EnSight will load all readers found in the directory:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   Files with names "libuserd-X.so" (where X is a name unique to the reader)
-   are assumed to be user-defined readers.
-
-   There are two methods which can be used to supplement the default
-   behavior.
-
-   (1) A feature which is useful for site-level or user-level configuration
-       is the optional environment variable $ENSIGHT7_READER.  This
-       variable directs EnSight to load all readers in the specified reader
-       directory (you should probably specify a full path) before loading
-       the built-in readers.  If the same reader exists in both directories
-       (as determined by the name returned by USERD_get_name_of_reader(),
-       NOT by the filename), the locally configured reader will take
-       precedence.
-
-   (2) A useful feature for end-users is the use of the libuserd-devel
-       reader.  EnSight will search for a reader named libuserd-devel.so
-       (.sl for HP or .dll for NT).  This reader can exist anywhere in the
-       library path (see below) of the user.  This is useful for an
-       individual actively developing a reader because the existence of a
-       libuserd-devel library will take precedence over any other library
-       which returns the same name from USERD_get_name_of_reader().
-
-   As an example, a site may install commonly used readers in a common
-   location, and users can set the ENSIGHT7_READER variable to access them:
-
-      setenv ENSIGHT7_READER /usr/local/lib/e7readers
-  
-   A user working on a new reader may compile the reader and place it in
-   a directory specified by the library path:
-
-      cp libuserd-myreader.so ~/lib/libuserd-devel.so
-      setenv <librarypath> ~/lib:$<librarypath>
-
-   The user is responsible for correctly configuring the library path
-   variable in order to make use of the libuserd-devel feature.  The
-   library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        linux           LD_LIBRARY_PATH
-        alpha linux     LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-As always, EnSight support is available if you need it.
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_part_coords                         part's node coordinates
-USERD_get_part_node_ids                       part's node ids
-USERD_get_part_elements_by_type               part's element connectivites
-USERD_get_part_element_ids_by_type            part's element ids
-
-
-Generally Needed for BLOCK data
---------------------------------------
-USERD_get_block_coords_by_component           block coordinates
-USERD_get_block_iblanking                     block iblanking values
-USERD_get_ghosts_in_block_flag                block ghost cell existence?
-USERD_get_block_ghost_flags                   block ghost cell flags
-
-  These routines, which formerly were only for unstructured data, will now
-  also be called for structured data if you specify that ids will be given
-  in the USERD_get_node_label_status and USERD_get_element_label_status rotuines
-  ------------------------------------------------------------------------------ 
-  USERD_get_part_node_ids                       part's node ids
-  USERD_get_part_element_ids_by_type            part's element ids
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_get_name_of_reader                      name of reader for GUI
-USERD_get_reader_version                      provide reader version number
-USERD_get_reader_descrip                      provide GUI more description(optional)
-
-USERD_set_filenames                           filenames entered in GUI
-USERD_set_server_number                       server which of how many
-
-USERD_get_number_of_timesets                  number of timesets
-USERD_get_timeset_description                 description of timeset
-USERD_get_geom_timeset_number                 timeset # to use for geom
-
-USERD_get_num_of_time_steps                   number of time steps
-USERD_get_sol_times                           solution time values
-USERD_set_time_set_and_step                   current timeset and time step
-
-
-USERD_get_changing_geometry_status            changing geometry?
-USERD_get_node_label_status                   node labels?
-USERD_get_element_label_status                element labels?
-USERD_get_model_extents                       provide model bounding extents
-USERD_get_number_of_files_in_dataset          number of files in model
-USERD_get_dataset_query_file_info             info about each model file
-USERD_get_descrip_lines                       file associated description lines
-USERD_get_number_of_model_parts               number of model parts
-USERD_get_part_build_info                     part/block type/descrip etc.
-USERD_get_maxsize_info                        part/block allocation maximums
-USERD_get_ghosts_in_model_flag                model contains ghost cells?
-
-USERD_get_border_availability                 part border provided?
-USERD_get_border_elements_by_type             part border conn and parent info
-
-USERD_get_number_of_variables                 number of variables
-USERD_get_gold_variable_info                  variable type/descrip etc.
-USERD_get_var_by_component                    part or block variable values
-USERD_get_constant_val                        constant variable's value
-USERD_get_var_value_at_specific               node's or element's variable
-                                                 value over time
-USERD_stop_part_building                      cleanup after part build routine
-
-USERD_bkup                                    archive routine
-
-USERD_exit_routine                            cleanup upon exit routine
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-        USERD_get_reader_descrip        (optional)
-
-2. Getting the reader version (also distinguishes between API's)
-
-        USERD_get_reader_version
-
-3. Setting filenames and getting timeset and time info
-
-        USERD_set_server_number
-        USERD_set_filenames
-        USERD_get_number_of_timesets
-        USERD_get_geom_timeset_number
-
-        for each timeset:
-          USERD_get_timeset_description
-          USERD_get_num_of_time_steps
-          USERD_get_sol_times
-
-        USERD_set_time_set_and_step
-
-4. Gathering info for part builder
-
-        USERD_set_time_set_and_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_descrip_lines                 (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_ghosts_in_model_flag
-        USERD_get_maxsize_info
-        USERD_get_get_ghosts_in_block_flag      (if any ghost cells in model)
-        USERD_get_model_extents     OR          (for model extents)
-             USERD_get_part_coords  AND/OR
-             USERD_get_block_coords_by_component
-
-5. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_gold_variable_info
-              
-6. Part building (per part created)
-
-        both unstructured and structured:
-        --------------------------------
-        USERD_set_time_set_and_step
-
-        if unstructured part:
-        --------------------
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-
-        else if structured part:
-        -----------------------
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-        USERD_get_block_ghost_flags          (If ghost cells in part)
-        USERD_get_part_node_ids              (If node ids given)
-        USERD_get_part_element_ids_by_type   (If element ids given)
-
-        both again:
-        ----------
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-7. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_set_and_step
-        USERD_get_constant_val
-          
-        scalars/vectors/tensors:
-        ------------------------
-        USERD_get_descrip_lines
-        USERD_set_time_set_and_step
-        USERD_get_var_by_component
-
-8. Changing geometry
-
-        changing coords only (per part):
-        --------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_part_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity (per part):
-        ---------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_ghosts_in_model_flag
-        USERD_get_get_ghosts_in_block_flag      (if any ghost cells in model)
-        USERD_get_model_extents   OR
-           USERD_get_part_coords  AND/OR
-           USERD_get_block_coords_by_component
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-        USERD_get_block_ghost_flags          (If ghost cells in part)
-        USERD_get_part_node_ids              (If node ids given)
-        USERD_get_part_element_ids_by_type   (If element ids given)
-
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-  
-9. Node or Element queries over time
-
-        USERD_get_var_value_at_specific
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-
-*******************************************************************************
-****************************** Special Note ***********************************
-*******************************************************************************
-
-You must use the global_extern.h file associated with the proper release of
-EnSight when you build readers.  Namely, this header file can change per EnSight
-release.  For example, readers compiled for EnSight 7.3 will not run properly in
-EnSight 7.4 and vica versa because there was a critical change in the
-global_extern.h file between these two versions.  In most cases the only thing
-needed to produce a workable reader is to remake it with the proper header file.
-
-*******************************************************************************
-*******************************************************************************
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available         = 0;
-static int Num_unstructured_parts     = 0;
-static int Num_structured_blocks      = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_timesets               = 1;
-static int Current_timeset            = 1;
-static int Geom_timeset_number        = 1;
-
-static int Num_time_steps[Z_MAXSETS]  = 1;
-static int Current_time_step          = 0;
-static int Num_variables              = 0;
-static int Num_dataset_files          = 0;
-
-static int Server_Number              = 1;    Which server of
-static int Tot_Servers                = 1;    the total number of servers
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
---------------------------------------------------------------------
-USERD_exit_routine
-
-   Description:
-   -----------
-   This routine is called as EnSight is exiting. It can be used to clean
-   up anything needed - such as removing temporary files, etc. - or can simply
-   be a dummy.
-
-   Specification:
-   -------------
-   void USERD_exit_routine( void )
-
-   Arguments:
-   ---------
-   none
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
-----------------------------------------------------------------------
-USERD_get_block_ghost_flags
-
-   Description:
-   -----------
-   Get the ghost_flags value at each element of a block containing ghost cells.
-
-   Specification:
-   -------------
-   int USERD_get_block_ghost_flags(int block_number,
-                                   int *ghost_flags)
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) ghost_flags             = 1D array containing ghost flag value
-                                     for each block cell.
-  
-                                    (Array will have been allocated
-                                     (i-1)*(j-1)*(k-1) for the block long)
-  
-            possible values are:    0  = non-ghost cell  (normal cell)
-                                   >0  = ghost cell
-  
-    Notes:
-    -----
-    * This routine is new in the 2.01 API
-
-    * This will be based on Current_time_step
-  
-    * Only called for structured "block" parts that have some ghost cells
-      as indicated by the USERD_get_ghost_in_block_flag.  The model must
-      of course also have been indicated to have some ghost cells in the
-      USERD_get_ghost_in_model_flag routine.
-  
-    * It is sufficient to set the value to be 1 to flag as a ghost cell,
-      but the value can be any non-zero value, so you could use it to
-      indicate which block or which server (for Server-of-server use) the
-      cell is actually in.
-
-
-
---------------------------------------------------------------------
-USERD_get_border_availability
-
-   Description:
-   -----------
-   Finds out if border elements are provided by the reader for the
-   desired part, or will need to be computed internally by EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_border_availability(int part_number,
-                                     int number_of_elements[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if border elements will be provided by the reader.
-          (number_of_elements array will be loaded and
-           USERD_get_border_elements_by_type will be called)
-
-   Z_ERR if border elements are not available - thus EnSight must compute.
-          (USERD_get_border_elements_by_type will not be called)
-
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of border element in
-                                  the part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-
-   Notes:
-   -----
-   * Only called if border representation is used.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_border_elements_by_type
-
-   Description:
-   -----------
-   Provides border element connectivity and parent information. 
-
-   Specification:
-   -------------
-   int USERD_get_border_elements_by_type(int part_number,
-                                         int element_type,
-                                         int **conn_array,
-                                         short *parent_element_type,
-                                         int *parent_element_num)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT    node point element
-                                 Z_BAR02    2 node bar
-                                 Z_BAR03    3 node bar
-                                 Z_TRI03    3 node triangle
-                                 Z_TRI06    6 node triangle
-                                 Z_QUA04    4 node quad
-                                 Z_QUA08    8 node quad
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each border element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_QUA08] = 30
-                           as obtained in:
-                            USERD_get_border_availability
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_QUA08
-
-   (OUT) parent_element_type   = 1D array containing element type of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   (OUT) parent_element_num   = 1D array containing element number of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   
-   Notes:
-   -----
-   * Not called unless USERD_get_border_availability returned Z_OK
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.  Note that
-     a part is allowed to be empty (number of nodes and elements equal
-     to zero).
-
-
---------------------------------------------------------------------
-USERD_get_constant_val
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var,
-                                  int imag_data)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   (IN)  imag_data            = TRUE if want imaginary data value.
-                                FALSE if want real data value.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine) (Is a long)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_MAXFILENP is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-     (See USERD_get_number_of_files_in_dataset)
-
-
---------------------------------------------------------------------
-USERD_get_descrip_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_descrip_lines(int which_type,
-                               int which_var,
-                               int imag_data,
-                               char line1[Z_BUFL],
-                               char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (IN)  imag_data            = TRUE if want imaginary data file.
-                                FALSE if want real data file.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-   * Prior to API 2.01:
-     -----------------
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-       API 1.0:
-         USERD_get_element_ids_for_part is used to obtain the ids,
-         on a part by part basis, if TRUE status is returned here.
-
-       API 2.0:
-         USERD_get_part_element_ids_by_type is used to obtain the ids,
-         on a per part, per type basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-   * Starting at API 2.01:
-     --------------------
-       For both unstructured and structured parts, you can read them
-       from your file if available, or can assign them, etc. They need
-       to be unique per part, and are often unique per model (especially
-       if you are dealing with a decomposed dataset).
-
-       USERD_get_part_element_ids_by_type is used to obtain the ids,
-       on an element type by part basis, if TRUE status is returned here.
-
-   * Will call USERD_get_part_element_ids_by_type for each type of
-     of each part if this routine returns TRUE.
---------------------------------------------------------------------
-USERD_get_geom_timeset_number -
-
-   Description:
-   -----------
-    Gets the timeset number to be used for geometry
-
-   Specification:
-   -------------
-   int USERD_get_geom_timeset_number( void )
-
-   Returns:
-   -------
-   Geom_timeset_number = The timeset number that will be used for geometry.   
-                         For example, if USERD_get_number_of timesets
-                         returns 2, the valid timeset numbers would be
-                         1 or 2.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   *  If your model is static, which you indicated by returning a zero
-      in USERD_get_number_of_timesets, you can return a zero here as well.
-
-
-
---------------------------------------------------------------------
-USERD_get_gold_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_gold_part_build_info(int *part_id,
-                                      int *part_types,
-                                      char *part_description[Z_BUFL],
-                                      int *number_of_nodes,
-                                      int *number_of_elements[Z_MAXTYPE],
-                                      int *ijk_dimensions[3],
-                                      int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-    (OUT) part_id                = Array containing the external part
-                                   ids for each of the model parts.
-
-                                   IMPORTANT:
-                                    Parts numbers must be >= 1, because
-                                    of the way they are used in the GUI
-
-               *******************************************
-                The ids provided here are the numbers by
-                which the parts will be referred to in the
-                GUI (if possible). They are basically
-                labels as far as you are concerned.
-
-                Note: The part numbers you pass to routines
-                which receive a part_number or block_number
-                or which_part as an argument are the 1-based
-                table index of the parts!
-
-                example:  If Numparts_available = 3
-
-                          Table index        part_id
-                          -----------        -------
-                           1                  13
-                           2                  57
-                           3                  125
-
-                           ^                   ^
-                           |                   |
-                           |                    These are placed in:
-                           |                      part_id[0] = 13
-                           |                      part_id[1] = 57
-                           |                      part_id[2] = 125
-                           |                    for GUI labeling purposes.
-                           |
-                            These implied table indices are the part_number,
-                            block_number, or which_part numbers that you would
-                            pass to routines like:
-
-                           USERD_get_part_coords(int part_number,...
-                           USERD_get_part_node_ids(int part_number,...
-                           USERD_get_part_elements_by_type(int part_number,...
-                           USERD_get_part_element_ids_by_type(int part_number,...
-                           USERD_get_block_coords_by_component(int block_number,...
-                           USERD_get_block_iblanking(int block_number,...
-                           USERD_get_block_ghost_flags(int block_number,...
-                           USERD_get_ghosts_in_block_flag(int block_number)
-                           USERD_get_border_availability(int part_number,...
-                           USERD_get_border_elements_by_type(int part_number,...
-                           USERD_get_var_by_component(int which_variable,
-                                                      int which_part,...
-                           USERD_get_var_value_at_specific(int which_var,
-                                                           int which_node_or_elem,
-                                                           int which_part,...
-               ********************************************
-
-                                    (Array will have been allocated
-                                     Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_nodes        = Number of unstructured nodes in the part
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                                Z_G_POINT =  ghost node point element
-                                Z_G_BAR02 =  2 node ghost bar
-                                Z_G_BAR03 =  3 node ghost bar
-                                Z_G_TRI03 =  3 node ghost triangle
-                                Z_G_TRI06 =  6 node ghost triangle
-                                Z_G_QUA04 =  4 node ghost quad
-                                Z_G_QUA08 =  8 node ghost quad
-                                Z_G_TET04 =  4 node ghost tetrahedron
-                                Z_G_TET10 = 10 node ghost tetrahedron
-                                Z_G_PYR05 =  5 node ghost pyramid
-                                Z_G_PYR13 = 13 node ghost pyramid
-                                Z_G_PEN06 =  6 node ghost pentahedron
-                                Z_G_PEN15 = 15 node ghost pentahedron
-                                Z_G_HEX08 =  8 node ghost hexahedron
-                                Z_G_HEX20 = 20 node ghost hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimensions
-                                  for each structured model part.
-                                           ----------
-                                  (Ignored if Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 3 long)
-
-                             ijk_dimensions[][0] = I dimension
-                             ijk_dimensions[][1] = J dimension
-                             ijk_dimensions[][2] = K dimension
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_gold_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_gold_variable_info(char **var_description,
-                                    char **var_filename,
-                                    int *var_type,
-                                    int *var_classify,
-                                    int *var_complex,
-                                    char **var_ifilename,
-                                    float *var_freq,
-                                    int *var_contran,
-                                    int *var_timeset)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-           variable description restrictions:
-           ----------------------------------
-           1. Only first 19 characters used in EnSight.
-           2. Leading and trailing whitespace will be removed by EnSight.
-           3. Illegal characters will be replaced by underscores.
-           4. Thay may not start with a numeric digit.
-           4. No two variables may have the same description.
-
-
-   (OUT) var_filename         = Variable real filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-                                            Z_TENSOR
-                                            Z_TENSOR9
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   (OUT) var_complex          = TRUE if complex, FALSE otherwise
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_ifilename        = Variable imaginary filenames (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_freq             = complex frequency  (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_contran          = TRUE if constant changes per time step
-                                FALSE if constant truly same at all time steps
- 
-                                (Array will have been allocated
-                                 Num_variables long)
-
-   (OUT) var_timeset          = Timeset the variable will use (1 based).
-                                (For static models, set it to 1)
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                 For example:  If USERD_get_number_of_timesets
-                                               returns 2, the valid
-                                               timeset_number's would be 1 or 2
-
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-                                               var_complex[0]
-                                               var_ifilename[0]
-                                               var_freq[0]
-                                               var_contran[0]
-                                               var_timeset[0]
-
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-                                               var_complex[1]
-                                               var_ifilename[1]
-                                               var_freq[1]
-                                               var_contran[1]
-                                               var_timeset[1]
-              etc.
-
-
-
-
---------------------------------------------------------------------
-USERD_get_ghosts_in_block_flag
-
-   Description:
-   -----------
-   Gets whether ghost cells present in block or not
-
-   Specification:
-   -------------
-  int USERD_get_ghosts_in_block_flag(int block_number)
-
-   Returns:
-   -------
-   TRUE  if any ghost cells in this structured part
-   FALSE if no ghost cells in this structured part
-
-   Arguments:
-   ---------
-   (IN) block_number      = The block part number
-                              (1-based index of part table, namely:
-
-                                1 ... Numparts_available.
-
-                              It is NOT the part_id that
-                              is loaded in USERD_get_gold_part_build_info)
-
-   Notes:
-   -----
-    * This routine is new in the 2.01 API
-    * This will be based on Current_time_step
-  
-    * Intended for structured parts only, value will be ignored for
-      unstructured parts
-
-
-
-
---------------------------------------------------------------------
-USERD_get_maxsize_info
-
-   Description:
-   -----------
-   Gets maximum part sizes for efficient memory allocation.
-
-   Transient models (especially those that increase in size) can cause
-   reallocations, at time step changes, to keep chewing up more and
-   more memory.   The way to avoid this is to know what the maximum
-   size of such memory will be, and allocate for this maximum initially.
-
-   Accordingly, if you choose to provide this information (it is optional),
-   EnSight will take advantage of it.
-
-
-   Specification:
-   -------------
-   int USERD_get_maxsize_info(int *max_number_of_nodes,
-                              int *max_number_of_elements[Z_MAXTYPE],
-                              int *max_ijk_dimensions[3])
-
-   Returns:
-   -------
-   Z_OK  if supplying maximum data
-   Z_ERR if not supplying maximum data, or some error occurred
-           while trying to obtain it.
-
-   Arguments:
-   ---------
-   (OUT) max_number_of_nodes    = Maximum number of unstructured nodes
-                                  in the part (over all time).
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) max_number_of_elements = 2D array containing maximum number of
-                                  each type of element for each
-                                  unstructured model part (over all time).
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                                Z_G_POINT =  ghost node point element
-                                Z_G_BAR02 =  2 node ghost bar
-                                Z_G_BAR03 =  3 node ghost bar
-                                Z_G_TRI03 =  3 node ghost triangle
-                                Z_G_TRI06 =  6 node ghost triangle
-                                Z_G_QUA04 =  4 node ghost quad
-                                Z_G_QUA08 =  8 node ghost quad
-                                Z_G_TET04 =  4 node ghost tetrahedron
-                                Z_G_TET10 = 10 node ghost tetrahedron
-                                Z_G_PYR05 =  5 node ghost pyramid
-                                Z_G_PYR13 = 13 node ghost pyramid
-                                Z_G_PEN06 =  6 node ghost pentahedron
-                                Z_G_PEN15 = 15 node ghost pentahedron
-                                Z_G_HEX08 =  8 node ghost hexahedron
-                                Z_G_HEX20 = 20 node ghost hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) max_ijk_dimensions  = 2D array containing maximum ijk dimensions
-                               for each structured model part (over all time).
-                                           ----------
-                                (Ignored if Z_UNSTRUCTURED type)
-
-                                (Array will have been allocated
-                                 Numparts_available by 3 long)
-
-                             max_ijk_dimensions[][0] = maximum I dimension
-                             max_ijk_dimensions[][1] = maximum J dimension
-                             max_ijk_dimensions[][2] = maximum K dimension
-
-   Notes:
-   -----
-   * You need to have first called USERD_get_number_of_model_parts and
-     USERD_get_gold_part_build_info, so Numparts_available is known and
-     so EnSight will know what the type is (Z_UNSTRUCTURED, Z_STRUCTURED,
-     or Z_IBLANKED) of each part.
-
-   * This will NOT be based on Current_time_step - it is to be the maximum
-     values over all time!!
-
-   * This information is optional.  If you return Z_ERR, Ensight will still
-     process things fine, reallocating as needed, etc.  However, for
-     large transient models you will likely use considerably more memory
-     and take more processing time for the memory reallocations. So, if it
-     is possible to provide this information "up front", it is recommended
-     to do so.
-
-
---------------------------------------------------------------------
-USERD_get_ghosts_in_model_flag
-
-   Description:
-   -----------
-   Answers the question as to whether any ghost cells in the model.
-
-   Specification:
-   -------------
-  int USERD_get_ghosts_in_model_flag( void )
-
-   Returns:
-   -------
-   TRUE  if any ghost cells in the model
-   FALSE if no ghost cells in the model
-
-   Arguments:
-   ---------
-  
-   Notes:
-   -----
-    * This routine is new in the 2.01 API
-
-
-
---------------------------------------------------------------------
-USERD_get_model_extents
-
-   Description:
-   -----------
-   Gets the model bounding box extents.  If this routine supplys them
-   EnSight will not have to spend time doing so.  If this routine
-   returns Z_ERR, EnSight will have to take the time to touch all the
-   nodes and gather the extent info.
-
-   Specification:
-   -------------
-   int USERD_get_model_extents(float extents[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful  (whereupon EnSight will determine by reading
-                             all coords of all parts)
-
-   Arguments:
-   ---------
-   (OUT) extents[0]   = min x
-                [1]   = max x
-                [2]   = min y
-                [3]   = max y
-                [4]   = min z
-                [5]   = max z
-
-   Notes:
-   -----
-   * This will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Please be sure to provide a name for your custom
-     reader format.
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-   * Prior to API 2.01:
-     -----------------
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  They must also be
-       positive numbers greater than zero.
-
-         USERD_get_part_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         (Unlike API 1.0, where the connectivity of elements had to be
-          according to the node ids - API 2.0's element connectivities
-          are not affected either way by the status here.)
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-   * Starting at API 2.01:
-     --------------------
-       For both unstructured and structured parts, you can read them
-       from your file if available, or can assign them, etc. They need
-       to be unique per part, and are often unique per model. They must
-       also be positive numbers greater than zero.
-
-       USERD_get_part_node_ids is used to obtain the ids, if the
-       status returned here is TRUE.
-
-   * Will call USERD_get_part_node_ids for each part if this routine
-     returns TRUE.
-
-
-
---------------------------------------------------------------------
-USERD_get_num_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available for desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_num_of_time_steps( int timeset_number )
-
-   Returns:
-   -------
-   Number of time steps in timeset  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   (IN) timeset number = the timeset number
-
-                         For example: If USERD_get_number_of_timesets
-                                      returns 2, the valid
-                                      timeset_number's would be 1 and 2
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps[timeset_number] would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_timesets
-
-   Description:
-   -----------
-    Gets the number of timesets used in the model.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_timesets( void )
-
-   Returns:
-   -------
-   Number of timesets in the model
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Num_timesets would be set here
-
-   * If you have a static model, both geometry and variables, you should
-     return a value of zero.
- 
-   * If you have a transient model, then you should return one or more.
- 
-   For example:
- 
-      Geometry    Variables                                 No. of timesets
-      ---------   ------------------------------            ---------------
-      static      static                                      0
-      static      transient, all using same timeset           1
- 
-      transient   transient, all using same timeset as geom   1
- 
-      static      transient, using 3 different timesets       3
- 
-      transient   transient, using 3 different timesets and
-                             none of them the same as the
-                             geometry timeset                 4
-          etc.
- 
-   NOTE: ALL GEOMETRY MUST USE THE SAME TIMESET!!! You will have to provide
-                                                   the timeset number to use
-                                                   for geometry in:
-                                               USERD_get_geom_timeset_number
- 
-         Variables can use the same timeset as the geometry, or can use
-         other timesets. More than one variable can use the same timeset.
- 
-   example:  changing geometry at 5 steps, 0.0, 1.0, 2.0, 3.0, 4.0
-             variable 1 provided at these same five steps
-             variable 2 provided at 3 steps, 0.5, 1.25, 3.33
- 
-        This routine should return a value of 2, because only
-        two different timesets are needed. Timeset 1 would be for the
-        geometry and variable 1 (they both use it). Timeset 2 would
-        be for variable 2, which needs its own in this case.
-
-
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, vector and tensor types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_coords
-
-   Description:
-   -----------
-   Gets the coordinates for an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_coords(int part_number, float **coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) coord_array             = 2D float array which contains,
-                                   x,y,z coordinates of each node
-                                   in the part.
-
-       (IMPORTANT: The second dimension of this aray is 1-based!!!)
-
-                                (Array will have been allocated
-                                 3 by (number_of_nodes + 1) for the part
-                                 long - see USERD_get_gold_part_build_info)
-
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             coord_array[3][101]
-
-                           Ignore the coord_array[0][0]
-                                      coord_array[1][0]
-                                      coord_array[2][0] locations and start
-                           the node coordinates at:
-                             coord_array[0][1]
-                             coord_array[1][1]
-                             coord_array[2][1]
-
-                             coord_array[0][2]
-                             coord_array[1][2]
-                             coord_array[2][2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_element_ids_by_type
-
-   Description:
-   -----------
-   Gets the ids for the elements of a particular type for an unstructured
-   or structured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_element_ids_by_type(int part_number,
-                                          int element_type,
-                                          int *elemid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type            = One of the following (See global_extern.h)
-                                   Z_POINT      node point element
-                                   Z_BAR02      2 node bar
-                                   Z_BAR03      3 node bar
-                                   Z_TRI03      3 node triangle
-                                   Z_TRI06      6 node triangle
-                                   Z_QUA04      4 node quad
-                                   Z_QUA08      8 node quad
-                                   Z_TET04      4 node tetrahedron
-                                   Z_TET10     10 node tetrahedron
-                                   Z_PYR05      5 node pyramid
-                                   Z_PYR13     13 node pyramid
-                                   Z_PEN06      6 node pentahedron
-                                   Z_PEN15     15 node pentahedron
-                                   Z_HEX08      8 node hexahedron
-                                   Z_HEX20     20 node hexahedron
-
-                                   Z_G_POINT    ghost node point element
-                                   Z_G_BAR02    2 node ghost bar
-                                   Z_G_BAR03    3 node ghost bar
-                                   Z_G_TRI03    3 node ghost triangle
-                                   Z_G_TRI06    6 node ghost triangle
-                                   Z_G_QUA04    4 node ghost quad
-                                   Z_G_QUA08    8 node ghost quad
-                                   Z_G_TET04    4 node ghost tetrahedron
-                                   Z_G_TET10   10 node ghost tetrahedron
-                                   Z_G_PYR05    5 node ghost pyramid
-                                   Z_G_PYR13   13 node ghost pyramid
-                                   Z_G_PEN06    6 node ghost pentahedron
-                                   Z_G_PEN15   15 node ghost pentahedron
-                                   Z_G_HEX08    8 node ghost hexahedron
-                                   Z_G_HEX20   20 node ghost hexahedron
-
-   (OUT) elemid_array            = 1D array containing id of each
-                                   element of the type.
-
-                                  (Array will have been allocated
-                                   number_of_elements of the type long)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25]   when called with Z_TRI03
-
-                              conn_array[100]  when called with Z_QUA04
-
-                              conn_array[30]  when called with Z_HEX08
-
-   Notes:
-   -----
-   * Not called unless element label status is set to TRUE in
-     USERD_get_element_label_status
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_part_elements_by_type
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of a particular type in an
-   unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_part_elements_by_type(int part_number,
-                                       int element_type,
-                                       int **conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT      node point element
-                                 Z_BAR02      2 node bar
-                                 Z_BAR03      3 node bar
-                                 Z_TRI03      3 node triangle
-                                 Z_TRI06      6 node triangle
-                                 Z_QUA04      4 node quad
-                                 Z_QUA08      8 node quad
-                                 Z_TET04      4 node tetrahedron
-                                 Z_TET10     10 node tetrahedron
-                                 Z_PYR05      5 node pyramid
-                                 Z_PYR13     13 node pyramid
-                                 Z_PEN06      6 node pentahedron
-                                 Z_PEN15     15 node pentahedron
-                                 Z_HEX08      8 node hexahedron
-                                 Z_HEX20     20 node hexahedron
-
-                                 Z_G_POINT    ghost node point element
-                                 Z_G_BAR02    2 node ghost bar
-                                 Z_G_BAR03    3 node ghost bar
-                                 Z_G_TRI03    3 node ghost triangle
-                                 Z_G_TRI06    6 node ghost triangle
-                                 Z_G_QUA04    4 node ghost quad
-                                 Z_G_QUA08    8 node ghost quad
-                                 Z_G_TET04    4 node ghost tetrahedron
-                                 Z_G_TET10   10 node ghost tetrahedron
-                                 Z_G_PYR05    5 node ghost pyramid
-                                 Z_G_PYR13   13 node ghost pyramid
-                                 Z_G_PEN06    6 node ghost pentahedron
-                                 Z_G_PEN15   15 node ghost pentahedron
-                                 Z_G_HEX08    8 node ghost hexahedron
-                                 Z_G_HEX20   20 node ghost hexahedron
-
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_HEX08
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_node_ids
-
-   Description:
-   -----------
-   Gets the node ids of an unstructured or structured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_node_ids(int part_number, int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node in the part.
-
-           (IMPORTANT: This array is 1-based!!!)
-
-                                   (Array will have been allocated
-                                    (number_of_nodes + 1) for the part long
-                                    see USERD_get_gold_part_build_info)
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             nodeid_array[101]
-
-                           Ignore the nodeid_array[0] location and start
-                           the node ids at:
-                             nodeid_array[1]
-
-                             nodeid_array[2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless node label status is TRUE, as returned from
-     USERD_get_node_label_status
-
-   * Will be based on Current_time_step
-
-   * The ids are purely labels, used when displaying or querying node ids.
-     However, any node id < 0 will never be displayed
-
-
---------------------------------------------------------------------
-USERD_get_reader_descrip
-
-   Description:
-   -----------
-   Gets the description of the reader, so gui can give more info
-
-   Specification:
-   -------------
-   int USERD_get_reader_descrip(char descrip[Z_MAXFILENP])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) descrip  = the description of the reader (max length is MAXFILENP,
-                                                   which is 255)
-
-   Notes:
-   -----
-   * OPTIONAL ROUTINE!   You can have it or not.
-
-
---------------------------------------------------------------------
-USERD_get_reader_version
-
-   Description:
-   -----------
-   Gets the version number of the user defined reader
-
-   Specification:
-   -------------
-   int USERD_get_reader_version(char version_number[Z_MAX_USERD_NAME])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful (and will assume is version 1.0)
-
-   Arguments:
-   ---------
-   (OUT) version_number       = the version number of the reader
-                                (max length is Z_MAX_USERD_NAME, which
-                                 is 20)
-
-   Notes:
-   -----
-   * This needs to be "2.000" or greater. Otherwise EnSight will assume
-     this reader is API 1.0
-
-   * should set it to "2.010" for this version of the API
-
-
-
-
---------------------------------------------------------------------
-USERD_get_sol_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step for 
-   desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_sol_times(int timeset_number,
-                           float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) solution_times       = 1D array of solution times per time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps[timeset_number] long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_timeset_description -
-
-   Description:
-   -----------
-   Get the description to associate with the desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_timeset_description(int timeset_number,
-                                     char timeset_description[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) timeset_description  = timeset description string
-
-
-   Notes:
-   -----
-   * A string of NULLs is valid for timeset_description
-
-
-
-
---------------------------------------------------------------------
-USERD_get_var_by_component
-
-   Description:
-   -----------
-   Gets the values of a variable component.  Both unstructured and structured
-   parts use this routine.
-
-   if Z_PER_NODE:
-     Get the component value at each node for a given variable in the part.
-
-   or if Z_PER_ELEM:
-     Get the component value at each element of a specific part and type
-     for a given variable.
-
-   Specification:
-   -------------
-   int USERD_get_var_by_component(int which_variable,
-                                  int which_part,
-                                  int var_type,
-                                  int which_type,
-                                  int imag_data,
-                                  int component,
-                                  float *var_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   or:  Z_UNDEF, in which case you need not load any values into var_array
-
-
-   Arguments:
-   ---------
-   (IN)  which_variable          = The variable number
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-   (IN)  var_type                = Z_SCALAR
-                                   Z_VECTOR
-                                   Z_TENSOR   (symmetric tensor)
-                                   Z_TENSOR9  (asymmetric tensor)
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-                                   Z_POINT      node point element
-                                   Z_BAR02      2 node bar
-                                   Z_BAR03      3 node bar
-                                   Z_TRI03      3 node triangle
-                                   Z_TRI06      6 node triangle
-                                   Z_QUA04      4 node quad
-                                   Z_QUA08      8 node quad
-                                   Z_TET04      4 node tetrahedron
-                                   Z_TET10     10 node tetrahedron
-                                   Z_PYR05      5 node pyramid
-                                   Z_PYR13     13 node pyramid
-                                   Z_PEN06      6 node pentahedron
-                                   Z_PEN15     15 node pentahedron
-                                   Z_HEX08      8 node hexahedron
-                                   Z_HEX20     20 node hexahedron
-
-                                   Z_G_POINT    ghost node point element
-                                   Z_G_BAR02    2 node ghost bar
-                                   Z_G_BAR03    3 node ghost bar
-                                   Z_G_TRI03    3 node ghost triangle
-                                   Z_G_TRI06    6 node ghost triangle
-                                   Z_G_QUA04    4 node ghost quad
-                                   Z_G_QUA08    8 node ghost quad
-                                   Z_G_TET04    4 node ghost tetrahedron
-                                   Z_G_TET10   10 node ghost tetrahedron
-                                   Z_G_PYR05    5 node ghost pyramid
-                                   Z_G_PYR13   13 node ghost pyramid
-                                   Z_G_PEN06    6 node ghost pentahedron
-                                   Z_G_PEN15   15 node ghost pentahedron
-                                   Z_G_HEX08    8 node ghost hexahedron
-                                   Z_G_HEX20   20 node ghost hexahedron
-
-   (IN)  imag_data               = TRUE if imag component
-                                   FALSE if real component
- 
-   (IN)  component               = The component: (0       if Z_SCALAR)
-                                                  (0 - 2   if Z_VECTOR)
-                                                  (0 - 5   if Z_TENSOR)
-                                                  (0 - 8   if Z_TENSOR9)
- 
-                                 * 6 Symmetric Indicies, 0:5    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = |    22 23 | = |   1 5 | *
-                                 *     |          |   |       | *
-                                 *     |       33 |   |     2 | *
- 
-
-                                 * 9 General   Indicies, 0:8    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = | 21 22 23 | = | 6 1 5 | *
-                                 *     |          |   |       | *
-                                 *     | 31 32 33 |   | 7 8 2 | *
-
-   (OUT) var_array 
-
-      -----------------------------------------------------------------------
-      (IMPORTANT: this array is 1-based for both Z_PER_NODE and Z_PER_ELEM!!!)
-      -----------------------------------------------------------------------
-
-            if Z_PER_NODE:    = 1D array containing variable component value
-                                for each node.
-
-                                (Array will have been allocated
-                                 (number_of_nodes + 1) long)
-
-                      Info stored in this fashion:
-                            var_array[0] = not used
-                            var_array[1] = var component for node 1 of part
-                            var_array[2] = var_component for node 2 of part
-                            var_array[3] = var_component for node 3 of part
-                            etc.
-
-            if Z_PER_ELEM:    = 1D array containing variable component
-                                value for each element of a particular
-                                part and type.
-                                    
-                              (Array will have been allocated
-                               (number_of_elements[which_part][which_type] + 1)
-                                long.  See USERD_get_gold_part_build_info)
-
-                  Info stored in this fashion:
-                    var_array[1] = var component for elem 1 (of part and type)
-                    var_array[2] = var component for elem 2 (of part and type)
-                    var_array[3] = var component for elem 3 (of part and type)
-                    etc.
-
-   Notes:
-   -----
-   * Not called unless Num_variables is > 0
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-   * If the variable is not defined for this part, simply return with a
-     value of Z_UNDEF.  EnSight will treat the variable as undefined for
-     this part.
-
-
---------------------------------------------------------------------
-USERD_get_var_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_var_value_at_specific(int which_var,
-                                       int which_node_or_elem,
-                                       int which_part,
-                                       int which_elem_type,
-                                       int time_step,
-                                       float values[3],
-                                       int imag_data)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-              If Z_PER_NODE:
-                = The node number.  This is not the id, but is
-                                    the index of the global node 
-                                    list (1 based), or the block's
-                                    node list (1 based).
-
-                  Thus,  coord_array[1]
-                         coord_array[2]
-                         coord_array[3]
-                              .      |
-                              .      |which_node_or_elem index
-                              .             ----
-
-
-              If Z_PER_ELEM:
-                = The element number.  This is not the id, but is
-                                       the element number index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info),
-                                        or the block's element list (1 based).
-
-                  Thus,  for which_part:
-                         conn_array[which_elem_type][0]
-                         conn_array[which_elem_type][1]
-                         conn_array[which_elem_type][2]
-                              .                      |
-                              .          which_node_or_elem index
-                              .                        ----
-
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-
-   (IN)  which_elem_type
-
-              If Z_PER_NODE, or block part:
-                = Not used
-
-              If Z_PER_ELEM:
-                = The element type.    This is the element type index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (IN)  imag_data   = TRUE if want imaginary value.
-                       FALSE if want real value.
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * The time step given is for the proper variable timeset.
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed. The user written code must manage its own files!!
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-                     = FALSE normally.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
---------------------------------------------------------------------
-USERD_set_server_number
-
-   Description:
-   -----------
-   Receives the server number of how many total servers.
-
-   Specification:
-   -------------
-   int USERD_set_server_number(int cur_serv,
-                               int tot_servs)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) cur_serv    = the current server.
-
-   (IN) tot_servs   = the total number of servers.
-
-   Notes:
-   -----
-   * Only useful if your user defined reader is being used with EnSight's
-     Server-of-Server capability.  And even then, it may or may not be
-     something that you can take advantage of.  If your data is already
-     partitioned in some manner, such that you can access the proper
-     portions using this information.
- 
-     For all non-SOS uses, this will simply be 1 of 1
-
-
-
---------------------------------------------------------------------
-USERD_set_time_set_and_step
-
-   Description:
-   -----------
-   Set the current time step in the desired timeset.  All functions that
-   need time, and that do not explicitly pass it in, will use the timeset
-   and step set by this routine, if needed.
-
-   Specification:
-   -------------
-   void USERD_set_time_set_and_step(int timeset_number,
-                                    int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) timeset_number  = the timeset number (1 based).
- 
-                          For example:  If USERD_get_number_of_timesets
-                                        returns 2, the valid timeset_number's
-                                        would be 1 and 2.
-
-   (IN) time_step       = The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step and Current_timeset would be set here
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-
-
----- end of doucment ----
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_USERD_2.03
+++ /dev/null
@@ -1,3838 +0,0 @@
-README_USERD_2.03
-=================
---------------------------------------
-EnSight User Defined Reader Capability   ===> (API 2.03)
---------------------------------------
-A user defined reader capability is included in EnSight which can allow
-otherwise unsupported structured or unstructured data to be read.  The user
-defined reader capability utilizes dynamic shared libraries composed of
-routines defined in this document but produced by you, the user, (or some
-third party). This capability is currently available for dec, ibm, hp, sgi,
-sun, linux, alpha linux, and NT servers.
-
-You should refer to beginning of README_USERD_2.0  and/or README_1.0_to_2.0
-for a discussion of the differences between API 1.0 and API 2.*.
-
-
-***>> API 2.03 additional capabilities (beyond API 2.01):
-1. Routines to handle materials
-2. Routines to handle nsided and nfaced elements
-3. Modified routine to handle structured ranges
-
-
-****************************************************************************
-Note: The dummy_gold reader, the Ensight Gold example reader, and the
-      SILO reader have been moved to this 2.03 API level.
-****************************************************************************
-
-
-The process for producing a user defined reader is:
----------------------------------------------------
-1. Write code for all pertinent routines in the library (Unless someone else
-   has done this for you).
-
-        This is of course where the work is done by the user.  The word
-        "pertinent" is used because depending on the nature of the data, some
-        of the routines in the library may be dummy routines.
-
-        The source code for a dummy_gold library and for various other
-        working or sample libraries is copied from the installation CD during
-        installation.  These will be located in directories under:
-
-        $CEI_HOME/ensight76/user_defined_src/readers
-
-        examples:
-        --------
-        Basic dummy_gold routines provide skeleton for a new reader
-          $CEI_HOME/ensight76/user_defined_src/readers/dummy_gold
-
-        Sample library which reads unstructured binary EnSight Gold data
-          $CEI_HOME/ensight76/user_defined_src/readers/ensight_gold
-
-        You may find it useful to place your library source in this area as
-        well, but are not limited to this location.
-
- * ===>	The descriptions of each library routine and the order that the
-        routines are called, which is provided in this file, along with
-        the example libraries, should make it possible for you to produce
-        code for your own data reader.	
-
-
-2. Produce the dynamic shared library.
-
-   This is a compiling and loading process which varies according to
-   the type of machine you are on.  In the user-defined-reader source
-   tree we have tried to isolate the machine dependent parts of the
-   build process using a set of files in the 'config' directory.  In this
-   directory there is a configuration file for each platform on which
-   EnSight is supported.  Before you can compile the installed readers
-   you should run the script called 'init' in the config directory.
-
-      i.e.  (for UNIX)
-            cd config
-            ./init sgi_6.5_n64
-            cd ..
-            make
-
-   If you are compiling for Windows NT, there are two options.  If you
-   have the Cygwin GNU utilities installed, you can use GNU make as for
-   Unix.  Otherwise, there is a script called makeall.cmd which will
-   build all of the readers using nmake.  The Makefiles in each reader
-   directory will work using either make or nmake.
-
-      i.e.  (WIN32 Cygwin)                 (using nmake)
-            cd config                      cd config
-            sh init win32                  cp win32 config
-            cd ..                          cd ..
-                                           mkdir lib
-            make                           makeall.cmd
-
-   If you have platform-specific portions of code in your reader, the
-   build system defines a set of flags which can be used within
-   #ifdef ... #endif regions in your source, as shown in the table
-   below.
-
-   Because the readers are now dynamically opened by EnSight, you may
-   have to include dependent libraries on your link-line to avoid having
-   unresolved symbols.  If you are having problems with a reader, start
-   ensight as "ensight7 -readerdbg" and you will get feedback on any
-   problems encountered in loading a reader.  If there are unresolved
-   symbols, you need to find the library which contains the missing
-   symbols and link it into your reader by adding it to the example
-   link commands below.
-
-   If you choose to use a different build environment for your reader,
-   you should take care to use compatible compilation flags to ensure
-   compatibilty with the EnSight executables, most notably on the SGI
-   and HP-UX 11.0 platforms, which should use the following flags:
-
-      sgi_6.2_o32: -mips2
-      sgi_6.2_n64: -mips4 -64
-      sgi_6.5_n32: -mips3
-      sgi_6.5_n64: -mips4 -64
-       hp_11.0_32: +DA2.0
-       hp_11.0_64: +DA2.0W
-
-    ______________________________________________________________________
-   | MACHINE | OS flag               |  SHARED LIBRARY NAME PRODUCED      |
-   |  TYPE   |------------------------------------------------------------|
-   |         |         LD COMMAND USED IN MAKEFILE                        |
-    ======================================================================
-    ______________________________________________________________________
-   | sgi     | -DSGI                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o              |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | hp      | -DHP                  |  libuserd-X.sl                     |
-   |         |------------------------------------------------------------|
-   |         | ld -b -o libuserd-X.sl libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | sun     | -DSUN                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o                        |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | dec     | -DDEC                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -all -o libuserd-X.so libuserd-X.o -lc          |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | linux   | -DLINUX               |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | alpha   | -DALINUX              |  libuserd-X.so                     |
-   | linux   |------------------------------------------------------------|
-   |         | ld -shared -o libuserd-X.so libuserd-X.o -lc               |
-    ----------------------------------------------------------------------
-    ______________________________________________________________________
-   | ibm     | -DIBM                 |  libuserd-X.so                     |
-   |         |------------------------------------------------------------|
-   |         | ld -G -o libuserd-X.so libuserd-X.o -bnoentry -bexpall -lc |
-    ----------------------------------------------------------------------
-
-   Once you have created your library, you should place it in a directory
-   of your choice or in the standard reader location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   For example, if you created a reader for "mydata", you should create
-   the reader libuserd-mydata.so and place the file in your own reader
-   directory (see section 3 below) or in the standard location:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers/libuserd-mydata.so
-
-
-3. By default EnSight will load all readers found in the directory:
-
-      $CEI_HOME/ensight76/machines/$CEI_ARCH/lib_readers
-
-   Files with names "libuserd-X.so" (where X is a name unique to the reader)
-   are assumed to be user-defined readers.
-
-   There are two methods which can be used to supplement the default
-   behavior.
-
-   (1) A feature which is useful for site-level or user-level configuration
-       is the optional environment variable $ENSIGHT7_READER.  This
-       variable directs EnSight to load all readers in the specified reader
-       directory (you should probably specify a full path) before loading
-       the built-in readers.  If the same reader exists in both directories
-       (as determined by the name returned by USERD_get_name_of_reader(),
-       NOT by the filename), the locally configured reader will take
-       precedence.
-
-   (2) A useful feature for end-users is the use of the libuserd-devel
-       reader.  EnSight will search for a reader named libuserd-devel.so
-       (.sl for HP or .dll for NT).  This reader can exist anywhere in the
-       library path (see below) of the user.  This is useful for an
-       individual actively developing a reader because the existence of a
-       libuserd-devel library will take precedence over any other library
-       which returns the same name from USERD_get_name_of_reader().
-
-   As an example, a site may install commonly used readers in a common
-   location, and users can set the ENSIGHT7_READER variable to access them:
-
-      setenv ENSIGHT7_READER /usr/local/lib/e7readers
-  
-   A user working on a new reader may compile the reader and place it in
-   a directory specified by the library path:
-
-      cp libuserd-myreader.so ~/lib/libuserd-devel.so
-      setenv <librarypath> ~/lib:$<librarypath>
-
-   The user is responsible for correctly configuring the library path
-   variable in order to make use of the libuserd-devel feature.  The
-   library environment variables used are:
-
-        Machine type    Environment variable to set
-        ------------    ---------------------------
-        sgi             LD_LIBRARY_PATH
-        dec             LD_LIBRARY_PATH
-        sun             LD_LIBRARY_PATH
-        linux           LD_LIBRARY_PATH
-        alpha linux     LD_LIBRARY_PATH
-        hp              SHLIB_PATH
-        ibm             LIBPATH
-
-As always, EnSight support is available if you need it.
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-Generally Needed for UNSTRUCTURED data
---------------------------------------
-USERD_get_part_coords                 part's node coordinates
-USERD_get_part_node_ids               part's node ids
-USERD_get_part_elements_by_type       part's element connectivites
-USERD_get_part_element_ids_by_type    part's element ids
-
-
-Generally Needed for BLOCK data
---------------------------------------
-USERD_get_block_coords_by_component   block coordinates
-USERD_get_block_iblanking             block iblanking values
-USERD_get_ghosts_in_block_flag        block ghost cell existence?
-USERD_get_block_ghost_flags           block ghost cell flags
-
-  These routines, which formerly were only for unstructured data, will now
-  also be called for structured data if you specify that ids will be given
-  in the USERD_get_node_label_status and USERD_get_element_label_status rotuines
-  ------------------------------------------------------------------------------ 
-  USERD_get_part_node_ids               part's node ids
-  USERD_get_part_element_ids_by_type    part's element ids
-
-
-Generally needed for either or both kinds of data
--------------------------------------------------
-USERD_get_name_of_reader              name of reader for GUI
-USERD_get_reader_version              provide reader version number
-USERD_get_reader_descrip              provide GUI more description (optional)
-
-USERD_set_filenames                   filenames entered in GUI
-USERD_set_server_number               server which of how many
-
-USERD_get_number_of_timesets          number of timesets
-USERD_get_timeset_description         description of timeset
-USERD_get_geom_timeset_number         timeset # to use for geom
-
-USERD_get_num_of_time_steps           number of time steps
-USERD_get_sol_times                   solution time values
-USERD_set_time_set_and_step           current timeset and time step
-
-USERD_get_gold_part_build_info        Gets the info needed for part building process
-USERD_get_changing_geometry_status    changing geometry?
-USERD_get_node_label_status           node labels?
-USERD_get_element_label_status        element labels?
-USERD_get_model_extents               provide model bounding extents
-USERD_get_number_of_files_in_dataset  number of files in model
-USERD_get_dataset_query_file_info     info about each model file
-USERD_get_descrip_lines               file associated description lines
-USERD_get_number_of_model_parts       number of model parts
-USERD_get_part_build_info             part/block type/descrip etc.
-USERD_get_maxsize_info                part/block allocation maximums
-USERD_get_ghosts_in_model_flag        model contains ghost cells?
-USERD_get_nsided_conn                 Gets the element connectivities for nsided
-                                        elements. (utilizes the number of nodes
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_nodes_per_face       Gets the number of nodes per face for nfaced
-                                        elements (utilizes the number of faces
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_conn                 Gets the element connectivities for nfaced
-                                        elements (utilizes the number of nodes
-                                        per face obtained in
-                                        USERD_get_nfaced_nodes_per_face)
-
-
-USERD_get_border_availability         part border provided?
-USERD_get_border_elements_by_type     part border conn and parent info
-
-USERD_get_number_of_variables         number of variables
-USERD_get_gold_variable_info          variable type/descrip etc.
-USERD_get_var_by_component            part or block variable values
-USERD_get_constant_val                constant variable's value
-USERD_get_var_value_at_specific       node's or element's variable value over time
-USERD_stop_part_building              cleanup after part build routine
-
-USERD_get_number_of_material_sets     Gets the number of material sets
-USERD_get_matf_set_info               Gets the material set indices and names
-USERD_get_number_of_materials         Gets the number of materials
-USERD_get_matf_var_info               Gets the material indices and descriptions
-USERD_size_matf_data                  Gets the length of either the
-                                        material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-USERD_load_matf_data                  Gets the material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-
-USERD_bkup                            archive routine
-
-USERD_exit_routine                    cleanup upon exit routine
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-1. Setting name in the gui, and specifying one or two input fields
-
-        USERD_get_name_of_reader
-        USERD_get_reader_descrip        (optional)
-
-2. Getting the reader version (also distinguishes between API's)
-
-        USERD_get_reader_version
-
-3. Setting filenames and getting timeset and time info
-
-        USERD_set_server_number
-        USERD_set_filenames
-        USERD_get_number_of_timesets
-        USERD_get_geom_timeset_number
-
-        for each timeset:
-          USERD_get_timeset_description
-          USERD_get_num_of_time_steps
-          USERD_get_sol_times
-
-        USERD_set_time_set_and_step
-
-4. Gathering info for part builder
-
-        USERD_set_time_set_and_step
-        USERD_get_changing_geometry_status
-        USERD_get_node_label_status
-        USERD_get_element_label_status
-        USERD_get_number_of_files_in_dataset
-        USERD_get_dataset_query_file_info
-        USERD_get_descrip_lines                 (for geometry)
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_ghosts_in_model_flag
-        USERD_get_maxsize_info
-        USERD_get_get_ghosts_in_block_flag      (if any ghost cells in model)
-        USERD_get_model_extents     OR          (for model extents)
-             USERD_get_part_coords  AND/OR
-             USERD_get_block_coords_by_component
-
-5. Gathering Variable info
-
-        USERD_get_number_of_variables
-        USERD_get_gold_variable_info
-              
-6. Part building (per part created)
-
-        both unstructured and structured:
-        --------------------------------
-        USERD_set_time_set_and_step
-
-        if unstructured part:
-        --------------------
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-
-        If any nsided elements:
-
-          USERD_get_nsided_conn
-
-        If any nfaced elements:
-
-          USERD_get_nfaced_nodes_per_face
-          USERD_get_nfaced_conn
-
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-
-        else if structured part:
-        -----------------------
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-        USERD_get_block_ghost_flags          (If ghost cells in part)
-        USERD_get_part_node_ids              (If node ids given)
-        USERD_get_part_element_ids_by_type   (If element ids given)
-
-        both again:
-        ----------
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-        USERD_stop_part_building      (only once when part builder
-                                       dialog is closed)
-
-7. Loading Variables
-          
-        constants:
-        ---------
-        USERD_set_time_set_and_step
-        USERD_get_constant_val
-          
-        scalars/vectors/tensors:
-        ------------------------
-        USERD_get_descrip_lines
-        USERD_set_time_set_and_step
-        USERD_get_var_by_component
-
-8. Changing geometry
-
-        changing coords only (per part):
-        --------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_part_coords
-        USERD_get_block_coords_by_component
-
-        changing connectivity (per part):
-        ---------------------
-        USERD_set_time_set_and_step
-        USERD_get_descrip_lines
-        USERD_get_number_of_model_parts
-        USERD_get_gold_part_build_info
-        USERD_get_ghosts_in_model_flag
-        USERD_get_get_ghosts_in_block_flag      (if any ghost cells in model)
-        USERD_get_model_extents   OR
-           USERD_get_part_coords  AND/OR
-           USERD_get_block_coords_by_component
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-        USERD_get_part_coords
-        USERD_get_part_node_ids
-        USERD_get_block_iblanking
-        USERD_get_block_coords_by_component
-        USERD_get_block_ghost_flags          (If ghost cells in part)
-        USERD_get_part_node_ids              (If node ids given)
-        USERD_get_part_element_ids_by_type   (If element ids given)
-
-        USERD_get_border_availability        (If border representation
-        USERD_get_border_elements_by_type     is selected)
-
-  
-9. Node or Element queries over time
-
-        USERD_get_var_value_at_specific
-
-10. To see if materials in the model
-
-        USERD_get_number_of_material_sets
-        USERD_get_matf_set_info
-
-        If any material sets in the model (calls these once per material set):
-          USERD_get_number_of_materials
-          USERD_get_matf_var_info
-
-        For each elment type of each part containing material ids, calls:
-          USERD_size_matf_data
-          USERD_load_matf_data
-
-        If there are any elements with mixed materials, when a domain or
-        interface is created, calls these again per part:
-
-          USERD_size_matf_data
-          USERD_load_matf_data
-
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-And it references:
-
-       #include "global_extern_proto.h"
-
-
-
-*******************************************************************************
-****************************** Special Note ***********************************
-*******************************************************************************
-
-Make sure you use the proper define in the global_extern.h header file, namely:
-#define USERD_API_203
-
-Also, Make sure the api version in the USERD_get_reader_version routine is set
-to "2.03" or larger.
-
-Make sure your reader has access to the global_extern_proto.h   This is a new
-file which is accessed from the new global_extern.h
-
-*******************************************************************************
-*******************************************************************************
-
-
-Basis of arrays:
----------------
-Unless explicitly stated otherwise, all arrays are zero based - in true C
-fashion.
-
-
-Global variables:
-----------------
-You will generally need to have a few global variables which are shared by
-the various library routines. The detailed specifications below have assumed
-the following are available.  (Their names describe their purpose, and they
-will be used in helping describe the details of the routines below).
-
-static int Numparts_available         = 0;
-static int Num_unstructured_parts     = 0;
-static int Num_structured_blocks      = 0;
-
-/* Note: Numparts_available = Num_unstructured_parts + Num_structured_blocks */
-
-static int Num_timesets               = 1;
-static int Current_timeset            = 1;
-static int Geom_timeset_number        = 1;
-
-static int Num_time_steps[Z_MAXSETS]  = 1;
-static int Current_time_step          = 0;
-static int Num_variables              = 0;
-static int Num_dataset_files          = 0;
-
-static int Server_Number              = 1;    Which server of
-static int Tot_Servers                = 1;    the total number of servers
-
-
-
-_________________________________________
------------------------------------------
-Library Routines (in alphabetical order):
-_________________________________________
------------------------------------------
-
---------------------------------------------------------------------
-USERD_bkup
-
-   Description:
-   -----------
-   This routine is called during the EnSight archive process.  You can
-   use it to save or restore info relating to your user defined reader.
-
-   Specification:
-   -------------
-   int USERD_bkup(FILE *archive_file,
-                  int backup_type)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  archive_file         = The archive file pointer
-
-   (IN)  backup_type          = Z_SAVE_ARCHIVE for saving archive
-                                Z_REST_ARCHIVE for restoring archive
-
-   Notes:
-   -----
-   * Since EnSight's archive file is saved in binary form, you should
-     also do any writing to it or reading from it in binary.
-
-   * You should archive any variables, which will be needed for
-     future operations, that will not be read or computed again
-     before they will be needed.  These are typically global
-     variables.
-
-   * Make sure that the number of bytes that you write on a save and
-     the number of bytes that you read on a restore are identical!!
-
-   * If any of the variables you save are allocated arrays, you must
-     do the allocations before restoring into them.
-
---------------------------------------------------------------------
-USERD_exit_routine
-
-   Description:
-   -----------
-   This routine is called as EnSight is exiting. It can be used to clean
-   up anything needed - such as removing temporary files, etc. - or can simply
-   be a dummy.
-
-   Specification:
-   -------------
-   void USERD_exit_routine( void )
-
-   Arguments:
-   ---------
-   none
-
---------------------------------------------------------------------
-USERD_get_block_coords_by_component
-
-   Description:
-   -----------
-   Get the coordinates of a given structured block, a component at a time.
-
-   Specification:
-   -------------
-   int USERD_get_block_coords_by_component(int block_number,
-                                           int which_component,
-                                           float *coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  which_component         = Z_COMPX if x component wanted
-                                 = Z_COMPY if y component wanted
-                                 = Z_COMPZ if z component wanted
-
-   (OUT) coord_array             = 1D array containing x,y, or z
-                                   coordinate component of each node
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_block_iblanking
-
-   Description:
-   -----------
-   Get the iblanking value at each node of a block (if the block is
-   iblanked).
-
-   Specification:
-   -------------
-   int USERD_get_block_iblanking(int block_number,
-                                 int *iblank_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) iblank_array            = 1D array containing iblank value
-                                   for each node.
-
-                                  (Array will have been allocated
-                                   i*j*k for the block long)
-
-          possible values are:   Z_EXT     = exterior
-                                 Z_INT     = interior
-                                 Z_BND     = boundary
-                                 Z_INTBND  = internal boundary
-                                 Z_SYM     = symmetry plane
-
-   Notes:
-   -----
-   * Not called unless Num_structured_blocks is > 0  and you have
-     some iblanked blocks
-
-   * Will be based on Current_time_step
-
-
-
-----------------------------------------------------------------------
-USERD_get_block_ghost_flags
-
-   Description:
-   -----------
-   Get the ghost_flags value at each element of a block containing ghost cells.
-
-   Specification:
-   -------------
-   int USERD_get_block_ghost_flags(int block_number,
-                                   int *ghost_flags)
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  block_number            = The block number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) ghost_flags             = 1D array containing ghost flag value
-                                     for each block cell.
-  
-                                    (Array will have been allocated
-                                     (i-1)*(j-1)*(k-1) for the block long)
-  
-            possible values are:    0  = non-ghost cell  (normal cell)
-                                   >0  = ghost cell
-  
-    Notes:
-    -----
-    * This routine is new in the 2.01 API
-
-    * This will be based on Current_time_step
-  
-    * Only called for structured "block" parts that have some ghost cells
-      as indicated by the USERD_get_ghost_in_block_flag.  The model must
-      of course also have been indicated to have some ghost cells in the
-      USERD_get_ghost_in_model_flag routine.
-  
-    * It is sufficient to set the value to be 1 to flag as a ghost cell,
-      but the value can be any non-zero value, so you could use it to
-      indicate which block or which server (for Server-of-server use) the
-      cell is actually in.
-
-
-
---------------------------------------------------------------------
-USERD_get_border_availability
-
-   Description:
-   -----------
-   Finds out if border elements are provided by the reader for the
-   desired part, or will need to be computed internally by EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_border_availability(int part_number,
-                                     int number_of_elements[Z_MAXTYPE])
-
-   Returns:
-   -------
-   Z_OK  if border elements will be provided by the reader.
-          (number_of_elements array will be loaded and
-           USERD_get_border_elements_by_type will be called)
-
-   Z_ERR if border elements are not available - thus EnSight must compute.
-          (USERD_get_border_elements_by_type will not be called)
-
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of border element in
-                                  the part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-
-   Notes:
-   -----
-   * Only called if border representation is used.
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_border_elements_by_type
-
-   Description:
-   -----------
-   Provides border element connectivity and parent information. 
-
-   Specification:
-   -------------
-   int USERD_get_border_elements_by_type(int part_number,
-                                         int element_type,
-                                         int **conn_array,
-                                         short *parent_element_type,
-                                         int *parent_element_num)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT    node point element
-                                 Z_BAR02    2 node bar
-                                 Z_BAR03    3 node bar
-                                 Z_TRI03    3 node triangle
-                                 Z_TRI06    6 node triangle
-                                 Z_QUA04    4 node quad
-                                 Z_QUA08    8 node quad
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each border element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_QUA08] = 30
-                           as obtained in:
-                            USERD_get_border_availability
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_QUA08
-
-   (OUT) parent_element_type   = 1D array containing element type of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   (OUT) parent_element_num   = 1D array containing element number of the
-                                 parent element (the one that the border
-                                 element is a face/edge of).
-
-                                (Array will have been allocated
-                                 num_of_elements of the type long)
-
-   
-   Notes:
-   -----
-   * Not called unless USERD_get_border_availability returned Z_OK
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_changing_geometry_status
-
-   Description:
-   -----------
-   Gets the changing geometry status for the model
-
-   Specification:
-   -------------
-   int USERD_get_changing_geometry_status( void )
-
-   Returns:
-   -------
-   Z_STATIC        if geometry does not change
-   Z_CHANGE_COORDS if changing coordinates only
-   Z_CHANGE_CONN   if changing connectivity
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * EnSight does not support changing number of parts.  But the
-     coords and/or the connectivity of the parts can change.  Note that
-     a part is allowed to be empty (number of nodes and elements equal
-     to zero).
-
-
---------------------------------------------------------------------
-USERD_get_constant_val
-
-   Description:
-   -----------
-   Get the value of a constant at a time step
-
-   Specification:
-   -------------
-   float USERD_get_constant_value(int which_var,
-                                  int imag_data)
-
-   Returns:
-   -------
-   Value of the requested constant variable
-
-   Arguments:
-   ---------
-   (IN)  which_var            = The variable number
-
-   (IN)  imag_data            = TRUE if want imaginary data value.
-                                FALSE if want real data value.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_dataset_query_file_info
-
-   Description:
-   -----------
-   Get the information about files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) qfiles   = Structure containing information about each file
-                    of the dataset. The Z_QFILES structure is defined
-                    in the global_extern.h file
-
-                   (The structure will have been allocated
-                    Num_dataset_files long, with 10 description
-                    lines per file).
-
-      qfiles[].name        = The name of the file
-                             (Z_MAXFILENP is the dimensioned length
-                              of the name)
-
-      qfiles[].sizeb       = The number of bytes in the file
-                             (Typically obtained with a call to the
-                              "stat" system routine) (Is a long)
-
-      qfiles[].timemod     = The time the file was last modified 
-                             (Z_MAXTIMLEN is the dimensioned length
-                              of this string)
-                             (Typically obtained with a call to the
-                              "stat" system routine)
-
-      qfiles[].num_d_lines = The number of description lines you
-                              are providing from the file. Max = 10
-
-      qfiles[].f_desc[]    = The description line(s) per file,
-                              qfiles[].num_d_lines of them
-                              (Z_MAXFILENP is the allocated length of
-                               each line)
-
-   Notes:
-   -----
-   * If Num_dataset_files is 0, this routine will not be called.
-     (See USERD_get_number_of_files_in_dataset)
-
-
---------------------------------------------------------------------
-USERD_get_descrip_lines
-
-   Description:
-   -----------
-   Get two description lines associated with geometry per time step,
-   or one description line associated with a variable per time step.
-
-   Specification:
-   -------------
-   int USERD_get_descrip_lines(int which_type,
-                               int which_var,
-                               int imag_data,
-                               char line1[Z_BUFL],
-                               char line2[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_type           = Z_GEOM for geometry (2 lines)
-                              = Z_VARI for variable (1 line)
-
-   (IN)  which_var            = If it is a variable, which one.
-                                Ignored if geometry type.
-
-   (IN)  imag_data            = TRUE if want imaginary data file.
-                                FALSE if want real data file.
-
-   (OUT) line1                = The 1st geometry description line,
-                                or the variable description line.
-
-   (OUT) line2                = The 2nd geometry description line
-                                Not used if variable type.
-
-   Notes:
-   -----
-   * Will be based on Current_time_step
-
-   * These are the lines EnSight can echo to the screen in
-     annotation mode.
-
-
-
---------------------------------------------------------------------
-USERD_get_element_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether element labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_element_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if element labels will be provided
-   FALSE       if element labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * element lables are needed in order to do any element querying, or
-     element labeling on-screen within EnSight.
-
-   * Prior to API 2.01:
-     -----------------
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.
-
-       API 1.0:
-         USERD_get_element_ids_for_part is used to obtain the ids,
-         on a part by part basis, if TRUE status is returned here.
-
-       API 2.0:
-         USERD_get_part_element_ids_by_type is used to obtain the ids,
-         on a per part, per type basis, if TRUE status is returned here.
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them youself!!
-
-   * Starting at API 2.01:
-     --------------------
-       For both unstructured and structured parts, you can read them
-       from your file if available, or can assign them, etc. They need
-       to be unique per part, and are often unique per model (especially
-       if you are dealing with a decomposed dataset).
-
-       USERD_get_part_element_ids_by_type is used to obtain the ids,
-       on an element type by part basis, if TRUE status is returned here.
-
-   * Will call USERD_get_part_element_ids_by_type for each type of
-     of each part if this routine returns TRUE.
---------------------------------------------------------------------
-USERD_get_geom_timeset_number -
-
-   Description:
-   -----------
-    Gets the timeset number to be used for geometry
-
-   Specification:
-   -------------
-   int USERD_get_geom_timeset_number( void )
-
-   Returns:
-   -------
-   Geom_timeset_number = The timeset number that will be used for geometry.   
-                         For example, if USERD_get_number_of timesets
-                         returns 2, the valid timeset numbers would be
-                         1 or 2.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   *  If your model is static, which you indicated by returning a zero
-      in USERD_get_number_of_timesets, you can return a zero here as well.
-
-
-
---------------------------------------------------------------------
-USERD_get_gold_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for the part building process.
-
-   Specification:
-   -------------
-   int USERD_get_gold_part_build_info(int *part_id,
-                                      int *part_types,
-                                      char *part_description[Z_BUFL],
-                                      int *number_of_nodes,
-                                      int *number_of_elements[Z_MAXTYPE],
-                                      int *ijk_dimensions[9],
-                                      int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-    (OUT) part_id                = Array containing the external part
-                                   ids for each of the model parts.
-
-                                   IMPORTANT:
-                                    Parts numbers must be >= 1, because
-                                    of the way they are used in the GUI
-
-               *******************************************
-                The ids provided here are the numbers by
-                which the parts will be referred to in the
-                GUI (if possible). They are basically
-                labels as far as you are concerned.
-
-                Note: The part numbers you pass to routines
-                which receive a part_number or block_number
-                or which_part as an argument are the 1-based
-                table index of the parts!
-
-                example:  If Numparts_available = 3
-
-                          Table index        part_id
-                          -----------        -------
-                           1                  13
-                           2                  57
-                           3                  125
-
-                           ^                   ^
-                           |                   |
-                           |                    These are placed in:
-                           |                      part_id[0] = 13
-                           |                      part_id[1] = 57
-                           |                      part_id[2] = 125
-                           |                    for GUI labeling purposes.
-                           |
-                            These implied table indices are the part_number,
-                            block_number, or which_part numbers that you would
-                            pass to routines like:
-
-                           USERD_get_part_coords(int part_number,...
-                           USERD_get_part_node_ids(int part_number,...
-                           USERD_get_part_elements_by_type(int part_number,...
-                           USERD_get_part_element_ids_by_type(int part_number,...
-                           USERD_get_block_coords_by_component(int block_number,...
-                           USERD_get_block_iblanking(int block_number,...
-                           USERD_get_block_ghost_flags(int block_number,...
-                           USERD_get_ghosts_in_block_flag(int block_number)
-                           USERD_get_border_availability(int part_number,...
-                           USERD_get_border_elements_by_type(int part_number,...
-                           USERD_get_var_by_component(int which_variable,
-                                                      int which_part,...
-                           USERD_get_var_value_at_specific(int which_var,
-                                                           int which_node_or_elem,
-                                                           int which_part,...
-               ********************************************
-
-                                    (Array will have been allocated
-                                     Numparts_available long)
-
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
-
-                                       Z_UNSTRUCTURED or
-                                       Z_STRUCTURED  or
-                                       Z_IBLANKED
-
-                                  (Array will have been allocated
-                                   Numparts_available long)
-
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
-
-                                  (Array will have been allocated
-                                   Numparts_available by Z_BUFL
-                                   long)
-
-   (OUT) number_of_nodes        = Number of unstructured nodes in the part
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                                Z_G_POINT =  ghost node point element
-                                Z_G_BAR02 =  2 node ghost bar
-                                Z_G_BAR03 =  3 node ghost bar
-                                Z_G_TRI03 =  3 node ghost triangle
-                                Z_G_TRI06 =  6 node ghost triangle
-                                Z_G_QUA04 =  4 node ghost quad
-                                Z_G_QUA08 =  8 node ghost quad
-                                Z_G_TET04 =  4 node ghost tetrahedron
-                                Z_G_TET10 = 10 node ghost tetrahedron
-                                Z_G_PYR05 =  5 node ghost pyramid
-                                Z_G_PYR13 = 13 node ghost pyramid
-                                Z_G_PEN06 =  6 node ghost pentahedron
-                                Z_G_PEN15 = 15 node ghost pentahedron
-                                Z_G_HEX08 =  8 node ghost hexahedron
-                                Z_G_HEX20 = 20 node ghost hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) ijk_dimensions         = 2D array containing ijk dimension info
-                                  for structured blocks
-
-                                  For Z_UNSTRUCTURED - is ignored
-
-                                  For Z_STRUCTURED or Z_IBLANKED
-
-        Prior to version 2.03:
-        ----------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 3 long)
-
-                              ijk_dimensions[][0] = I dimension
-                              ijk_dimensions[][1] = J dimension
-                              ijk_dimensions[][2] = K dimension
-
-
-        Starting at version 2.03:
-        ------------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 9 long)
-
-                              There are two ways to do this:
-                              ------------------------------
-                              1. The simple one, without ranges.
-
-                                   This is good for all structured models
-                                   that will NOT be used in EnSight's
-                                   Server of Servers
-
-                                   Simply provide the ijk dimensions in the
-                                   first three slots and place a -1 in
-                                   the 4th slot.  (The remaining slots will
-                                   be ignored).
-
-                              Thus,
-                              ijk_dimensions[][0] = I dimension of block
-                              ijk_dimensions[][1] = J dimension of block
-                              ijk_dimensions[][2] = K dimension of block
-                              ijk_dimensions[][3] = -1
-
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][4] = -1
-                              |       |       |
-                              |       |       |
-                            2 *-------*-------*
-                              |       |       |
-                              |       |       |
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
-
-
-
-                              2. Using ranges.
-
-                                  This one can be used anytime, but MUST
-                                  be used if EnSight's Server of Servers
-                                  is to be used!
-
-                                  The first 3 slots contain the ijk dimension
-                                  of the complete block (of which this may be
-                                  a portion).  The last 6 slots contain the
-                                  ijk min and max ranges within the complete.
-
-                              Thus,
-                              ijk_dimensions[][0] = I dim of complete block
-                              ijk_dimensions[][1] = J dim of complete block
-                              ijk_dimensions[][2] = K dim of complete block
-
-                              ijk_dimensions[][3] = Imin of portion (1-based)
-                              ijk_dimensions[][4] = Imax of portion (1-based)
-                              ijk_dimensions[][5] = Jmin of portion (1-based)
-                              ijk_dimensions[][6] = Jmax of portion (1-based)
-                              ijk_dimensions[][7] = Kmin of portion (1-based)
-                              ijk_dimensions[][8] = Kmax of portion (1-based)
-
-
-                              example1: (Model has one part, a simple 2D block,
-                                         and want whole thing)
-
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][3] = 1
-                              |       |       |    ijk_dimension[0][4] = 3
-                              |       |       |    ijk_dimension[0][5] = 1
-                            2 *-------*-------*    ijk_dimension[0][6] = 4
-                              |       |       |    ijk_dimension[0][7] = 1
-                              |       |       |    ijk_dimension[0][8] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
-
-
-                              example2: (Want to have the block represented
-                                         in two portions - 2 parts)
-
-                        (J planes)                 top portion
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              .       .       .    ijk_dimension[0][3] = 1
-                              .       .       .    ijk_dimension[0][4] = 3
-                              .       .       .    ijk_dimension[0][5] = 3
-                            2 .................    ijk_dimension[0][6] = 4
-                              .       .       .    ijk_dimension[0][7] = 1
-                              .       .       .    ijk_dimension[0][8] = 1
-                              .       .       .
-                            1 .................
-                              1       2       3  (I planes)
-
-
-                        (J planes)                 bottom portion
-                            4 .................
-                              .       .       .    ijk_dimension[1][0] = 3
-                              .       .       .    ijk_dimension[2][1] = 4
-                              .       .       .    ijk_dimension[3][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[1][3] = 1
-                              |       |       |    ijk_dimension[1][4] = 3
-                              |       |       |    ijk_dimension[1][5] = 1
-                            2 *-------*-------*    ijk_dimension[1][6] = 3
-                              |       |       |    ijk_dimension[1][7] = 1
-                              |       |       |    ijk_dimension[1][8] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
-
-
-        And note that if you were partioning this block for
-        EnSight's Server of Servers, you would only have one part,
-        instead of two.  Each SOS server would return its appropriate
-        ranges in the last 6 slots. The first 3 slots would remain constant.
-
-
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
-
-      iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                       [][Z_INT]     = TRUE if internal (inside)
-                       [][Z_BND]     = TRUE if boundary
-                       [][Z_INTBND]  = TRUE if internal boundary
-                       [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   * If you haven't built a table of pointers to the different parts,
-     you might want to do so here as you gather the needed info.
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_gold_variable_info
-
-   Description:
-   -----------
-   Get the variable descriptions, types and filenames
-
-   Specification:
-   -------------
-   int USERD_get_gold_variable_info(char **var_description,
-                                    char **var_filename,
-                                    int *var_type,
-                                    int *var_classify,
-                                    int *var_complex,
-                                    char **var_ifilename,
-                                    float *var_freq,
-                                    int *var_contran,
-                                    int *var_timeset)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) var_description      = Variable descriptions
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-           variable description restrictions:
-           ----------------------------------
-           1. Only first 19 characters used in EnSight.
-           2. Leading and trailing whitespace will be removed by EnSight.
-           3. Illegal characters will be replaced by underscores.
-           4. Thay may not start with a numeric digit.
-           4. No two variables may have the same description.
-
-
-   (OUT) var_filename         = Variable real filenames
-
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_type             = Variable type
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_CONSTANT
-                                            Z_SCALAR
-                                            Z_VECTOR
-                                            Z_TENSOR
-                                            Z_TENSOR9
-
-   (OUT) var_classify         = Variable classification
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                types are:  Z_PER_NODE
-                                            Z_PER_ELEM
-
-   (OUT) var_complex          = TRUE if complex, FALSE otherwise
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_ifilename        = Variable imaginary filenames (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables by Z_BUFL long)
-
-   (OUT) var_freq             = complex frequency  (if complex)
- 
-                                (Array will have been allocated
-                                 Num_variables long)
- 
-   (OUT) var_contran          = TRUE if constant changes per time step
-                                FALSE if constant truly same at all time steps
- 
-                                (Array will have been allocated
-                                 Num_variables long)
-
-   (OUT) var_timeset          = Timeset the variable will use (1 based).
-                                (For static models, set it to 1)
-
-                                (Array will have been allocated
-                                 Num_variables long)
-
-                                 For example:  If USERD_get_number_of_timesets
-                                               returns 2, the valid
-                                               timeset_number's would be 1 or 2
-
-
-   Notes:
-   -----
-   * The implied variable numbers apply, but be aware that the
-     arrays are zero based.
-     So for variable 1, will need to provide   var_description[0]
-                                               var_filename[0]
-                                               var_type[0]
-                                               var_classify[0]
-                                               var_complex[0]
-                                               var_ifilename[0]
-                                               var_freq[0]
-                                               var_contran[0]
-                                               var_timeset[0]
-
-
-        for variable 2, will need to provide   var_description[1]
-                                               var_filename[1]
-                                               var_type[1]
-                                               var_classify[1]
-                                               var_complex[1]
-                                               var_ifilename[1]
-                                               var_freq[1]
-                                               var_contran[1]
-                                               var_timeset[1]
-              etc.
-
-
-
-
---------------------------------------------------------------------
-USERD_get_ghosts_in_block_flag
-
-   Description:
-   -----------
-   Gets whether ghost cells present in block or not
-
-   Specification:
-   -------------
-  int USERD_get_ghosts_in_block_flag(int block_number)
-
-   Returns:
-   -------
-   TRUE  if any ghost cells in this structured part
-   FALSE if no ghost cells in this structured part
-
-   Arguments:
-   ---------
-   (IN) block_number      = The block part number
-                              (1-based index of part table, namely:
-
-                                1 ... Numparts_available.
-
-                              It is NOT the part_id that
-                              is loaded in USERD_get_gold_part_build_info)
-
-   Notes:
-   -----
-    * This routine is new in the 2.01 API
-    * This will be based on Current_time_step
-  
-    * Intended for structured parts only, value will be ignored for
-      unstructured parts
-
-
-
---------------------------------------------------------------------
-USERD_get_ghosts_in_model_flag
-
-   Description:
-   -----------
-   Answers the question as to whether any ghost cells in the model.
-
-   Specification:
-   -------------
-  int USERD_get_ghosts_in_model_flag( void )
-
-   Returns:
-   -------
-   TRUE  if any ghost cells in the model
-   FALSE if no ghost cells in the model
-
-   Arguments:
-   ---------
-  
-   Notes:
-   -----
-    * This routine is new in the 2.01 API
-
--------------------------------------------------------------------------
-USERD_get_matf_set_info
-
-   Description:
-   -----------
-   Get the material set ids and names
-
-   Specification:
-   -------------
-   int USERD_get_matf_set_info(int *mat_set_ids,
-                               char **mat_set_name)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) mat_set_ids  = 1D material set ids array
-
-                               (Array will have been allocated
-                                Num_material_sets long)
-
-   (OUT) mat_set_name = 2D material set name array
-
-                               (Array will have been allocated
-                                Num_material_sets by Z_BUFL long)
-
-   Notes:
-   -----
-   * Will not be called if Num_material_sets is zero
-   * See USERD_get_number_of_material_sets header for explanatory example
-
-
---------------------------------------------------------------------
-USERD_get_matf_var_info
-
-   Description:
-   -----------
-   Gets the material ids and descriptions for the material set
-
-   Specification:
-   -------------
-   int USERD_get_matf_var_info(int set_index,
-                               int *mat_ids,
-                               char **mat_desc)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  set_index               = the material set index (zero based)
-
-   (OUT) mat_ids[set_index]      = 1D integer array containing the material
-                                   ids to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] long)
-
-   (OUT) mat_desc[set_index]     = 2D char array containing the material
-                                   descriptions to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] by Z_BUFL long)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
-
-
---------------------------------------------------------------------
-USERD_get_maxsize_info
-
-   Description:
-   -----------
-   Gets maximum part sizes for efficient memory allocation.
-
-   Transient models (especially those that increase in size) can cause
-   reallocations, at time step changes, to keep chewing up more and
-   more memory.   The way to avoid this is to know what the maximum
-   size of such memory will be, and allocate for this maximum initially.
-
-   Accordingly, if you choose to provide this information (it is optional),
-   EnSight will take advantage of it.
-
-
-   Specification:
-   -------------
-   int USERD_get_maxsize_info(int *max_number_of_nodes,
-                              int *max_number_of_elements[Z_MAXTYPE],
-                              int *max_ijk_dimensions[3])
-
-   Returns:
-   -------
-   Z_OK  if supplying maximum data
-   Z_ERR if not supplying maximum data, or some error occurred
-           while trying to obtain it.
-
-   Arguments:
-   ---------
-   (OUT) max_number_of_nodes    = Maximum number of unstructured nodes
-                                  in the part (over all time).
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
-
-   (OUT) max_number_of_elements = 2D array containing maximum number of
-                                  each type of element for each
-                                  unstructured model part (over all time).
-                                  ------------
-                                  Possible types are:
-
-                                Z_POINT   =  point
-                                Z_BAR02   =  2-noded bar
-                                Z_BAR03   =  3-noded bar
-                                Z_TRI03   =  3-noded triangle
-                                Z_TRI06   =  6-noded triangle
-                                Z_QUA04   =  4-noded quadrilateral
-                                Z_QUA08   =  8-noded quadrilateral
-                                Z_TET04   =  4-noded tetrahedron
-                                Z_TET10   = 10-noded tetrahedron
-                                Z_PYR05   =  5-noded pyramid
-                                Z_PYR13   = 13-noded pyramid
-                                Z_PEN06   =  6-noded pentahedron
-                                Z_PEN15   = 15-noded pentahedron
-                                Z_HEX08   =  8-noded hexahedron
-                                Z_HEX20   = 20-noded hexahedron
-
-                                Z_G_POINT =  ghost node point element
-                                Z_G_BAR02 =  2 node ghost bar
-                                Z_G_BAR03 =  3 node ghost bar
-                                Z_G_TRI03 =  3 node ghost triangle
-                                Z_G_TRI06 =  6 node ghost triangle
-                                Z_G_QUA04 =  4 node ghost quad
-                                Z_G_QUA08 =  8 node ghost quad
-                                Z_G_TET04 =  4 node ghost tetrahedron
-                                Z_G_TET10 = 10 node ghost tetrahedron
-                                Z_G_PYR05 =  5 node ghost pyramid
-                                Z_G_PYR13 = 13 node ghost pyramid
-                                Z_G_PEN06 =  6 node ghost pentahedron
-                                Z_G_PEN15 = 15 node ghost pentahedron
-                                Z_G_HEX08 =  8 node ghost hexahedron
-                                Z_G_HEX20 = 20 node ghost hexahedron
-
-                               (Ignored unless Z_UNSTRUCTURED type)
-
-                                  (Array will have been allocated
-                                   Numparts_available by
-                                   Z_MAXTYPE long)
-
-   (OUT) max_ijk_dimensions  = 2D array containing maximum ijk dimensions
-                               for each structured model part (over all time).
-                                           ----------
-                                (Ignored if Z_UNSTRUCTURED type)
-
-                                (Array will have been allocated
-                                 Numparts_available by 3 long)
-
-                             max_ijk_dimensions[][0] = maximum I dimension
-                             max_ijk_dimensions[][1] = maximum J dimension
-                             max_ijk_dimensions[][2] = maximum K dimension
-
-   Notes:
-   -----
-   * You need to have first called USERD_get_number_of_model_parts and
-     USERD_get_gold_part_build_info, so Numparts_available is known and
-     so EnSight will know what the type is (Z_UNSTRUCTURED, Z_STRUCTURED,
-     or Z_IBLANKED) of each part.
-
-   * This will NOT be based on Current_time_step - it is to be the maximum
-     values over all time!!
-
-   * This information is optional.  If you return Z_ERR, Ensight will still
-     process things fine, reallocating as needed, etc.  However, for
-     large transient models you will likely use considerably more memory
-     and take more processing time for the memory reallocations. So, if it
-     is possible to provide this information "up front", it is recommended
-     to do so.
-
-
---------------------------------------------------------------------
-USERD_get_model_extents
-
-   Description:
-   -----------
-   Gets the model bounding box extents.  If this routine supplys them
-   EnSight will not have to spend time doing so.  If this routine
-   returns Z_ERR, EnSight will have to take the time to touch all the
-   nodes and gather the extent info.
-
-   Specification:
-   -------------
-   int USERD_get_model_extents(float extents[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful  (whereupon EnSight will determine by reading
-                             all coords of all parts)
-
-   Arguments:
-   ---------
-   (OUT) extents[0]   = min x
-                [1]   = max x
-                [2]   = min y
-                [3]   = max y
-                [4]   = min z
-                [5]   = max z
-
-   Notes:
-   -----
-   * This will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_name_of_reader
-
-   Description:
-   -----------
-   Gets the name of your user defined reader.  The user interface will
-   ask for this and include it in the available reader list.
-
-   Specification:
-   -------------
-   int USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-				int *two_fields)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) reader_name          = the name of the your reader or data format.
-                              (max length is Z_MAX_USERD_NAME, which is 20)
-
-   (OUT) *two_fields          = FALSE if only one data field required
-				      in the data dialog of EnSight.
-				TRUE if two data fields required.
-
-   Notes:
-   -----
-   * Always called.  Please be sure to provide a name for your custom
-     reader format.
-
---------------------------------------------------------------------
-USERD_get_nfaced_conn
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided faces of nfaced elements
-
-   Specification:
-   -------------int
-   int USERD_get_nfaced_conn(int part_number,
-                             int *nfaced_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number        = the part number
-
-   (OUT) nfaced_conn_array  = 1D array of nsided face connectivies of nfaced
-                              elements
-
-                              (int array will have been allocated long enough to
-                               hold all the nsided face connectivities. Which is
-                               the sum of all the nodes per face values in the
-                               nfaced_npf_array of USERD_get_nfaced_nodes_per_face)
-
-   Notes:
-   -----
- * Will not be called unless there are some nfaced elements in the part
-
- * Providing nfaced information to Ensight:
-
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-
-
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In USERD_get_faced_nodes_per_face:     |
-           length of nfaced_npf_array will be:  12
-
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In this function:                            |
-            length of the nfaced_conn_array will be:  48
-
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-
---------------------------------------------------------------------
-USERD_get_nfaced_nodes_per_face -
-
-   Description:
-   -----------
-   Gets the array containing the number of nodes per face for each face
-   of the nfaced elements.
-
-   Specification:
-   -------------
-   int USERD_get_nfaced_nodes_per_face(int part_number,
-                                       int *nfaced_npf_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number       = the part number
-
-   (OUT) nfaced_npf_array  = 1D array of nodes per face for all faces of
-                             nfaced elements
-
-                             (int array will have been allocated long enough
-                              to hold all the nodes_per_face values. Which is
-                              the sum of all the number of faces per element
-                              values in the conn_array of
-                              USERD_get_part_elements_by_type)
-
-   Notes:
-   -----
-   * Will not be called unless there are some nfaced elements in the
-     the part
-
-   * Providing nfaced information to Ensight:
-
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-
-
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In this routine:                       |
-           length of nfaced_npf_array will be:  12
-
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In USERD_get_nfaced_conn:                    |
-            length of the nfaced_conn_array will be:  48
-
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-
-
---------------------------------------------------------------------
-USERD_get_node_label_status
-
-   Description:
-   -----------
-   Answers the question as to whether node labels will be provided.
-
-   Specification:
-   -------------
-   int USERD_get_node_label_status( void )
-
-   Returns:
-   -------
-   TRUE        if node labels will be provided
-   FALSE       if node labels will NOT be provided
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Node ids are needed in order to do any node querying, or node
-     labeling on-screen within EnSight.
-
-   * Prior to API 2.01:
-     -----------------
-       For unstructured parts, you can read them from your file if
-       available, or can assign them, etc. They need to be unique
-       per part, and are often unique per model.  They must also be
-       positive numbers greater than zero.
-
-         USERD_get_part_node_ids is used to obtain the ids, if the
-         status returned here is TRUE.
-
-         (Unlike API 1.0, where the connectivity of elements had to be
-          according to the node ids - API 2.0's element connectivities
-          are not affected either way by the status here.)
-
-       For structured parts, EnSight will assign ids if you return a
-         status of TRUE here.  You cannot assign them yourself!!
-
-   * Starting at API 2.01:
-     --------------------
-       For both unstructured and structured parts, you can read them
-       from your file if available, or can assign them, etc. They need
-       to be unique per part, and are often unique per model. They must
-       also be positive numbers greater than zero.
-
-       USERD_get_part_node_ids is used to obtain the ids, if the
-       status returned here is TRUE.
-
-   * Will call USERD_get_part_node_ids for each part if this routine
-     returns TRUE.
-
---------------------------------------------------------------------
-USERD_get_nsided_conn -
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided elements
-
-   Specification:
-   -------------
-   int USERD_get_nsided_conn(int part_number,
-                             int *nsided_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number         = the part number
-
-   (OUT) nsided_conn_array   = 1D array of nsided connectivies
-
-                               (int array will have been allocated long enough
-                                to hold all the nsided connectivities. Which is
-                                the sum of all the nodes_per_element values in
-                                the conn_array of USERD_get_part_elements_by_type)
-
-
-   Notes:
-   -----
-   * Will not be called unless there are some nsided elements in the the part.
-
-   * Providing nsided information to Ensight:
-
-     1. In USERD_get_gold_part_build_info, provide the number of nsided
-        elements in the part.
-
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of nodes per nsided element. (as if connectivity
-        length of an nsided element is one)
-
-     3. In this routine, provide the streamed connectivities for each of the
-        nsided elements.
-
-
-     Simple example:         5        6
-                            +--------+
-     3 nsided elements:    /|         \
-     (1 4-sided           / |          \
-      1 3-sided          /  |           \
-      1 7-sided)        /   |            \ 7
-                       /3   |4            +
-                      +-----+             |
-                      |     |             |
-                      |     |             |8
-                      |     |             +
-                      |     |            /
-                      |     |           /
-                      |     |          /
-                      |1    |2        /9
-                      +-----+--------+
-
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NSIDED] = 3
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      3 x 1
-
-          for element_type of Z_NSIDED:
-              conn_array[0][0] = 4           (for the 4-sided element)
-              conn_array[1][0] = 3           (for the 3-sided element)
-              conn_array[2][0] = 7           (for the 7-sided element)
-
-                           Sum  ===
-                                 14    <---------+
-                                                 |
-      3. In this routine:                        |
-           length of nsided_conn_array will be:  14
-
-              nsided_conn_array[0]  = 1      (connectivity of 4-sided element)
-              nsided_conn_array[1]  = 2
-              nsided_conn_array[2]  = 4
-              nsided_conn_array[3]  = 3
-
-              nsided_conn_array[4]  = 3      (connectivity of 3-sided element)
-              nsided_conn_array[5]  = 4
-              nsided_conn_array[6]  = 5
-
-              nsided_conn_array[7]  = 2      (connectivity of 7-sided element)
-              nsided_conn_array[8]  = 9
-              nsided_conn_array[9]  = 8
-              nsided_conn_array[10] = 7
-              nsided_conn_array[11] = 6
-              nsided_conn_array[12] = 5
-              nsided_conn_array[13] = 4
-
-
-
-
---------------------------------------------------------------------
-USERD_get_num_of_time_steps
-
-   Description:
-   -----------
-   Gets the number of time steps of data available for desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_num_of_time_steps( int timeset_number )
-
-   Returns:
-   -------
-   Number of time steps in timeset  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   (IN) timeset number = the timeset number
-
-                         For example: If USERD_get_number_of_timesets
-                                      returns 2, the valid
-                                      timeset_number's would be 1 and 2
-
-   Notes:
-   -----
-   * This should be >= 1       1 indicates a static model
-                              >1 indicates a transient model
-
-   * Num_time_steps[timeset_number] would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_files_in_dataset
-
-   Description:
-   -----------
-   Get the total number of files in the dataset.  Used for the
-   dataset query option within EnSight.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_files_in_dataset( void )
-
-   Returns:
-   -------
-   The total number of files in the dataset.
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * You can be as complete as you want about this.  If you don't
-     care about the dataset query option, return a value of 0
-     If you only want certain files, you can just include them. But,
-     you will need to supply the info in USERD_get_dataset_query_file_info
-     for each file you include here.
-
-   * Num_dataset_files would be set here
-
-
---------------------------------------------------------------------
-USERD_get_number_of_material_sets -
-
-   Description:
-   -----------
-   Get the number of material sets in the model
-
-   Specification:
-   -------------
-   int USERD_get_number_of_material_sets( void )
-
-
-   Returns:
-   -------
-   Num_material_sets = number of material sets
-                       (Zero would indicate that you have no materials
-                        to deal with in the model)
-
-                       or
-
-                       -1 if an error condition
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-  * You may want to keep this as a global for use in other routines.
-
-   ###############################################################
-   NOTE:  For EnSight 7.6, only one material set is supported
-          within EnSight.
-          Thus the only valid returns here are:
-               0 (no materials)
-               1 (for the one material set allowed)
-          or  -1 (if an error)
-
-          If the casefile has more than this, this reader will
-          read them, but EnSight will issue an error message and
-          choke on them!
-   ###############################################################
-
-  ================================================================
-  A very simple explanatory example, to use as a reference for the
-  materials routines:
-
-  Given a 2D mesh composed of 9 quad (Z_QUA04) elements, with two materials.
-  Most of the model is material 1, but the top left corner is material 9 -
-  basically as shown:
-
-
-        *--------*--------*--------*
-        |        |   /    |        |
-        |     Mat 9 /     |        |
-        |        | /      |        |
-        |        |/       |        |
-        |  e7    /   e8   |   e9   |
-        |       /|        |        |
-        |      / |        |        |
-        |     /  |        |        |
-        *----/---*--------*--------*
-        |   /    |        |        |
-        |  /     |        |        |
-        | /      |      Mat 1      |
-        |/       |        |        |
-        |   e4   |   e5   |   e6   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |   e1   |   e2   |   e3   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-
-
-  Thus, in this routine, set:
-    Num_material_sets = 1
-
-  In USERD_get_matf_set_info, set:
-    mat_set_ids[0]    = 1
-    mat_set_name[0]   = "Material Set 1"  (or whatever name desired)
-
-  In USERD_get_number_of_materials, input would be set_index = 0, and
-  would need to set:
-    Num_materials[0] = 2
-
-  For simplicity, the ids and descriptions that would be returned in
-  USERD_get_matf_var_info could be:
-    mat_ids[0] = 1
-    mat_ids[1] = 9
-    mat_desc[0] = "mat 1"   (or whatever desired)
-    mat_desc[2] = "mat 9"
-
-  The per element material ids list would need to be:
-
-     material ids:
-     -------------
-     ids_list[0] = 1  (material id 1, for elem e1)
-     ids_list[1] = 1  (     "                  e2)
-     ids_list[2] = 1  (     "                  e3)
-     ids_list[3] = -1 (negative of index into mixed-material id list, for elem e4)
-     ids_list[5] = 1  (material id 1, for elem e5)
-     ids_list[5] = 1  (     "                  e6)
-     ids_list[5] = -5 (negative of index into mixed-material id list, for elem e7)
-     ids_list[5] = -9 (     "                  e8)
-     ids_list[5] = 1  (material id 1, for elem e9)
-
-  Finally we need the mixed material ids list and the mixed materials values list,
-  which would need to be:
-
-       mixed-material ids:
-       -------------------
-   ==> 1  ids_list[0]  =  2  (the -1 in the material variable points here,
-                                      2 indicates that two materials are present)
-       2  ids_list[1]  =  1  (1st material is 1)
-       3  ids_list[2]  =  9  (2nd material is 9)
-       4  ids_list[3]  = -1  (negative of index into mixed-material val_list)
-   ==> 5  ids_list[4]  =  2  (the -5 in the material variable points here,
-                                      2 indicates that two materials are present)
-       6  ids_list[5]  =  1  (1st material is 1)
-       7  ids_list[6]  =  9  (2nd material is 9)
-       8  ids_list[7]  = -3  (negative of index into mixed-material val_list)
-   ==> 9  ids_list[8]  =  2     etc.
-       10 ids_list[9]  =  1
-       11 ids_list[10] =  9
-       12 ids_list[11] = -5
-
-       mixed-material values:
-       ----------------------
-   ==> 1 val_list[0] = 0.875 (the -1 in the  mixed-material ids_list points here,
-                                       and this is the value for material 1)
-       2 val_list[1] = 0.125 (the value for material 9)
-   ==> 3 val_list[2] = 0.125 (the -3 in the mixed-materials ids_list points here)
-       4 val_list[3] = 0.875
-   ==> 5 val_list[4] = 0.875 (the -5 in the mixed-materials ids_list points here)
-       6 val_list[5] = 0.125
-
-  So, USERD_size_matf_data would need to return
-       matf_size = 8, when called with set_id    = 1
-                                       part_id   = 1
-                                       wtyp      = Z_QUA04
-                                       mat_type  = Z_MAT_INDEX
-
-       matf_size = 12, when called with set_id   = 1
-                                        part_id  = 1
-                                        mat_type = Z_MIX_INDEX
-
-                 = 6, when called with set_id   = 1
-                                       part_id  = 1
-                                       mat_type = Z_MIX_VALUE
-
-  And, USERD_load_matf_data would need to return:
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       wtyp     = Z_QUA04
-       mat_type = Z_MAT_INDEX (indicating id list).
-
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_INDEX (indicating id list).
-
-    the float array val_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_VALUE (indicating val list).
-
-
--------------------------------------------------------------------------
-USERD_get_number_of_materials
-
-   Description:
-   -----------
-   Gets the number of materials in the material set
-
-   Specification:
-   -------------
-   int USERD_get_number_of_materials( int set_index )
-
-   Returns:
-   -------
-   Num_materials[set_index]   = Number of materials in the set
-                                 0 indicates no materials information present
-                                -1 indicates an error
-   Arguments:
-   ---------
-   (IN) set_index             = the material set index (zero based)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero
-  * You may want to keep this as a global for use in other routines.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_model_parts
-
-   Description:
-   -----------
-   Gets the total number of unstructured and structured parts
-   in the model, for which you can supply information.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_model_parts( void )
-
-   Returns:
-   -------
-   Number of parts  (>0 if okay, <=0 if problems).
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * If going to have to read down through the parts in order to
-     know how many, you may want to build a table of pointers to
-     the various parts, so you can easily get to particular parts in
-     later processes.  If you can simply read the number of parts
-     at the head of the file, then you would probably not build the
-     table at this time.
-
-   * This routine would set Numparts_available, which is equal to
-     Num_unstructured_parts + Num_structured_blocks.
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_timesets
-
-   Description:
-   -----------
-    Gets the number of timesets used in the model.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_timesets( void )
-
-   Returns:
-   -------
-   Number of timesets in the model
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-   * Num_timesets would be set here
-
-   * If you have a static model, both geometry and variables, you should
-     return a value of zero.
- 
-   * If you have a transient model, then you should return one or more.
- 
-   For example:
- 
-      Geometry    Variables                                 No. of timesets
-      ---------   ------------------------------            ---------------
-      static      static                                      0
-      static      transient, all using same timeset           1
- 
-      transient   transient, all using same timeset as geom   1
- 
-      static      transient, using 3 different timesets       3
- 
-      transient   transient, using 3 different timesets and
-                             none of them the same as the
-                             geometry timeset                 4
-          etc.
- 
-   NOTE: ALL GEOMETRY MUST USE THE SAME TIMESET!!! You will have to provide
-                                                   the timeset number to use
-                                                   for geometry in:
-                                               USERD_get_geom_timeset_number
- 
-         Variables can use the same timeset as the geometry, or can use
-         other timesets. More than one variable can use the same timeset.
- 
-   example:  changing geometry at 5 steps, 0.0, 1.0, 2.0, 3.0, 4.0
-             variable 1 provided at these same five steps
-             variable 2 provided at 3 steps, 0.5, 1.25, 3.33
- 
-        This routine should return a value of 2, because only
-        two different timesets are needed. Timeset 1 would be for the
-        geometry and variable 1 (they both use it). Timeset 2 would
-        be for variable 2, which needs its own in this case.
-
-
-
-
-
---------------------------------------------------------------------
-USERD_get_number_of_variables
-
-   Description:
-   -----------
-   Get the number of variables for which you will be providing info.
-
-   Specification:
-   -------------
-   int USERD_get_number_of_variables( void )
-
-   Returns:
-   -------
-   Number of variables (includes constant, scalar, vector and tensor types)
-                       (>=0 if okay, <0 if problem)
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-    *****************************************************************
-   * Variable numbers, by which references will be made, are implied
-     here. If you say there are 3 variables, the variable numbers
-     will be 1, 2, and 3.
-    *****************************************************************
-
-   * Num_variables would be set here
-
-
-
---------------------------------------------------------------------
-USERD_get_part_coords
-
-   Description:
-   -----------
-   Gets the coordinates for an unstructured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_coords(int part_number, float **coord_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) coord_array             = 2D float array which contains,
-                                   x,y,z coordinates of each node
-                                   in the part.
-
-       (IMPORTANT: The second dimension of this aray is 1-based!!!)
-
-                                (Array will have been allocated
-                                 3 by (number_of_nodes + 1) for the part
-                                 long - see USERD_get_gold_part_build_info)
-
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             coord_array[3][101]
-
-                           Ignore the coord_array[0][0]
-                                      coord_array[1][0]
-                                      coord_array[2][0] locations and start
-                           the node coordinates at:
-                             coord_array[0][1]
-                             coord_array[1][1]
-                             coord_array[2][1]
-
-                             coord_array[0][2]
-                             coord_array[1][2]
-                             coord_array[2][2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_element_ids_by_type
-
-   Description:
-   -----------
-   Gets the ids for the elements of a particular type for an unstructured
-   or structured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_element_ids_by_type(int part_number,
-                                          int element_type,
-                                          int *elemid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type            = One of the following (See global_extern.h)
-                                   Z_POINT      node point element
-                                   Z_BAR02      2 node bar
-                                   Z_BAR03      3 node bar
-                                   Z_TRI03      3 node triangle
-                                   Z_TRI06      6 node triangle
-                                   Z_QUA04      4 node quad
-                                   Z_QUA08      8 node quad
-                                   Z_TET04      4 node tetrahedron
-                                   Z_TET10     10 node tetrahedron
-                                   Z_PYR05      5 node pyramid
-                                   Z_PYR13     13 node pyramid
-                                   Z_PEN06      6 node pentahedron
-                                   Z_PEN15     15 node pentahedron
-                                   Z_HEX08      8 node hexahedron
-                                   Z_HEX20     20 node hexahedron
-
-                                   Z_G_POINT    ghost node point element
-                                   Z_G_BAR02    2 node ghost bar
-                                   Z_G_BAR03    3 node ghost bar
-                                   Z_G_TRI03    3 node ghost triangle
-                                   Z_G_TRI06    6 node ghost triangle
-                                   Z_G_QUA04    4 node ghost quad
-                                   Z_G_QUA08    8 node ghost quad
-                                   Z_G_TET04    4 node ghost tetrahedron
-                                   Z_G_TET10   10 node ghost tetrahedron
-                                   Z_G_PYR05    5 node ghost pyramid
-                                   Z_G_PYR13   13 node ghost pyramid
-                                   Z_G_PEN06    6 node ghost pentahedron
-                                   Z_G_PEN15   15 node ghost pentahedron
-                                   Z_G_HEX08    8 node ghost hexahedron
-                                   Z_G_HEX20   20 node ghost hexahedron
-
-   (OUT) elemid_array            = 1D array containing id of each
-                                   element of the type.
-
-                                  (Array will have been allocated
-                                   number_of_elements of the type long)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25]   when called with Z_TRI03
-
-                              conn_array[100]  when called with Z_QUA04
-
-                              conn_array[30]  when called with Z_HEX08
-
-   Notes:
-   -----
-   * Not called unless element label status is set to TRUE in
-     USERD_get_element_label_status
-
-   * Will be based on Current_time_step
-
-
-
---------------------------------------------------------------------
-USERD_get_part_elements_by_type
-
-   Description:
-   -----------
-   Gets the connectivities for the elements of a particular type in an
-   unstructured part
-
-   Specification:
-   -------------
-   int USERD_get_part_elements_by_type(int part_number,
-                                       int element_type,
-                                       int **conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number           = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (IN)  element_type          = One of the following (See global_extern.h)
-                                 Z_POINT      node point element
-                                 Z_BAR02      2 node bar
-                                 Z_BAR03      3 node bar
-                                 Z_TRI03      3 node triangle
-                                 Z_TRI06      6 node triangle
-                                 Z_QUA04      4 node quad
-                                 Z_QUA08      8 node quad
-                                 Z_TET04      4 node tetrahedron
-                                 Z_TET10     10 node tetrahedron
-                                 Z_PYR05      5 node pyramid
-                                 Z_PYR13     13 node pyramid
-                                 Z_PEN06      6 node pentahedron
-                                 Z_PEN15     15 node pentahedron
-                                 Z_HEX08      8 node hexahedron
-                                 Z_HEX20     20 node hexahedron
-
-                                 Z_G_POINT    ghost node point element
-                                 Z_G_BAR02    2 node ghost bar
-                                 Z_G_BAR03    3 node ghost bar
-                                 Z_G_TRI03    3 node ghost triangle
-                                 Z_G_TRI06    6 node ghost triangle
-                                 Z_G_QUA04    4 node ghost quad
-                                 Z_G_QUA08    8 node ghost quad
-                                 Z_G_TET04    4 node ghost tetrahedron
-                                 Z_G_TET10   10 node ghost tetrahedron
-                                 Z_G_PYR05    5 node ghost pyramid
-                                 Z_G_PYR13   13 node ghost pyramid
-                                 Z_G_PEN06    6 node ghost pentahedron
-                                 Z_G_PEN15   15 node ghost pentahedron
-                                 Z_G_HEX08    8 node ghost hexahedron
-                                 Z_G_HEX20   20 node ghost hexahedron
-
-
-   (OUT) conn_array            = 2D array containing connectivity
-                                 of each element of the type.
-
-                                (Array will have been allocated
-                                 num_of_elements of the type by
-                                 connectivity length of the type)
-
-                       ex) If number_of_elements[Z_TRI03] = 25
-                              number_of_elements[Z_QUA04] = 100
-                              number_of_elements[Z_HEX08] = 30
-                           as obtained in:
-                            USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions available
-                           for this routine will be:
-                              conn_array[25][3]   when called with Z_TRI03
-
-                              conn_array[100][4]  when called with Z_QUA04
-
-                              conn_array[30][8]   when called with Z_HEX08
-   
-   Notes:
-   -----
-   * Not called unless Num_unstructured_parts is > 0
-
-   * Will be based on Current_time_step
-
-
---------------------------------------------------------------------
-USERD_get_part_node_ids
-
-   Description:
-   -----------
-   Gets the node ids of an unstructured or structured part.
-
-   Specification:
-   -------------
-   int USERD_get_part_node_ids(int part_number, int *nodeid_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number             = The part number
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-   (OUT) nodeid_array            = 1D array containing node ids of
-                                    each node in the part.
-
-           (IMPORTANT: This array is 1-based!!!)
-
-                                   (Array will have been allocated
-                                    (number_of_nodes + 1) for the part long
-                                    see USERD_get_gold_part_build_info)
-
-                       ex) If number_of_nodes = 100
-                           as obtained in:
-                             USERD_get_gold_part_build_info
-
-                           Then the allocated dimensions of the
-                           pointer sent to this routine will be:
-                             nodeid_array[101]
-
-                           Ignore the nodeid_array[0] location and start
-                           the node ids at:
-                             nodeid_array[1]
-
-                             nodeid_array[2]
-
-                                   etc.
-
-   Notes:
-   -----
-   * Not called unless node label status is TRUE, as returned from
-     USERD_get_node_label_status
-
-   * Will be based on Current_time_step
-
-   * The ids are purely labels, used when displaying or querying node ids.
-     However, any node id < 0 will never be displayed
-
-
---------------------------------------------------------------------
-USERD_get_reader_descrip
-
-   Description:
-   -----------
-   Gets the description of the reader, so gui can give more info
-
-   Specification:
-   -------------
-   int USERD_get_reader_descrip(char descrip[Z_MAXFILENP])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) descrip  = the description of the reader (max length is MAXFILENP,
-                                                   which is 255)
-
-   Notes:
-   -----
-   * OPTIONAL ROUTINE!   You can have it or not.
-
-
-
---------------------------------------------------------------------
-USERD_get_reader_version
-
-   Description:
-   -----------
-   Gets the version number of the user defined reader
-
-   Specification:
-   -------------
-   int USERD_get_reader_version(char version_number[Z_MAX_USERD_NAME])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful (and will assume is version 1.0)
-
-   Arguments:
-   ---------
-   (OUT) version_number       = the version number of the reader
-                                (max length is Z_MAX_USERD_NAME, which
-                                 is 20)
-
-   Notes:
-   -----
-   * This needs to be "2.000" or greater. Otherwise EnSight will assume
-     this reader is API 1.0
-
-   * should set it to "2.010" for this version of the API
-
-
-
-
---------------------------------------------------------------------
-USERD_get_sol_times
-
-   Description:
-   -----------
-   Get the solution times associated with each time step for 
-   desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_sol_times(int timeset_number,
-                           float *solution_times)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) solution_times       = 1D array of solution times per time step
-
-                                  (Array will have been allocated
-                                   Num_time_steps[timeset_number] long)
-
-   Notes:
-   -----
-   * The solution times must be non-negative and increasing.
-
-
-
---------------------------------------------------------------------
-USERD_get_timeset_description -
-
-   Description:
-   -----------
-   Get the description to associate with the desired timeset.
-
-   Specification:
-   -------------
-   int USERD_get_timeset_description(int timeset_number,
-                                     char timeset_description[Z_BUFL])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  timeset_number     = the timeset number
- 
-                              For example: If USERD_get_number_of_timesets
-                                           returns 2, the valid
-                                           timeset_number's would be 1 and 2
-
-   (OUT) timeset_description  = timeset description string
-
-
-   Notes:
-   -----
-   * A string of NULLs is valid for timeset_description
-
-
-
-
---------------------------------------------------------------------
-USERD_get_var_by_component
-
-   Description:
-   -----------
-   Gets the values of a variable component.  Both unstructured and structured
-   parts use this routine.
-
-   if Z_PER_NODE:
-     Get the component value at each node for a given variable in the part.
-
-   or if Z_PER_ELEM:
-     Get the component value at each element of a specific part and type
-     for a given variable.
-
-   Specification:
-   -------------
-   int USERD_get_var_by_component(int which_variable,
-                                  int which_part,
-                                  int var_type,
-                                  int which_type,
-                                  int imag_data,
-                                  int component,
-                                  float *var_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   or:  Z_UNDEF, in which case you need not load any values into var_array
-
-
-   Arguments:
-   ---------
-   (IN)  which_variable          = The variable number
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-   (IN)  var_type                = Z_SCALAR
-                                   Z_VECTOR
-                                   Z_TENSOR   (symmetric tensor)
-                                   Z_TENSOR9  (asymmetric tensor)
-
-   (IN)  which_type
-
-            if Z_PER_NODE:         Not used
-
-            if Z_PER_ELEM:       = The element type
-                                   Z_POINT      node point element
-                                   Z_BAR02      2 node bar
-                                   Z_BAR03      3 node bar
-                                   Z_TRI03      3 node triangle
-                                   Z_TRI06      6 node triangle
-                                   Z_QUA04      4 node quad
-                                   Z_QUA08      8 node quad
-                                   Z_TET04      4 node tetrahedron
-                                   Z_TET10     10 node tetrahedron
-                                   Z_PYR05      5 node pyramid
-                                   Z_PYR13     13 node pyramid
-                                   Z_PEN06      6 node pentahedron
-                                   Z_PEN15     15 node pentahedron
-                                   Z_HEX08      8 node hexahedron
-                                   Z_HEX20     20 node hexahedron
-
-                                   Z_G_POINT    ghost node point element
-                                   Z_G_BAR02    2 node ghost bar
-                                   Z_G_BAR03    3 node ghost bar
-                                   Z_G_TRI03    3 node ghost triangle
-                                   Z_G_TRI06    6 node ghost triangle
-                                   Z_G_QUA04    4 node ghost quad
-                                   Z_G_QUA08    8 node ghost quad
-                                   Z_G_TET04    4 node ghost tetrahedron
-                                   Z_G_TET10   10 node ghost tetrahedron
-                                   Z_G_PYR05    5 node ghost pyramid
-                                   Z_G_PYR13   13 node ghost pyramid
-                                   Z_G_PEN06    6 node ghost pentahedron
-                                   Z_G_PEN15   15 node ghost pentahedron
-                                   Z_G_HEX08    8 node ghost hexahedron
-                                   Z_G_HEX20   20 node ghost hexahedron
-
-   (IN)  imag_data               = TRUE if imag component
-                                   FALSE if real component
- 
-   (IN)  component               = The component: (0       if Z_SCALAR)
-                                                  (0 - 2   if Z_VECTOR)
-                                                  (0 - 5   if Z_TENSOR)
-                                                  (0 - 8   if Z_TENSOR9)
- 
-                                 * 6 Symmetric Indicies, 0:5    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = |    22 23 | = |   1 5 | *
-                                 *     |          |   |       | *
-                                 *     |       33 |   |     2 | *
- 
-
-                                 * 9 General   Indicies, 0:8    *
-                                 * ---------------------------- *
-                                 *     | 11 12 13 |   | 0 3 4 | *
-                                 *     |          |   |       | *
-                                 * T = | 21 22 23 | = | 6 1 5 | *
-                                 *     |          |   |       | *
-                                 *     | 31 32 33 |   | 7 8 2 | *
-
-   (OUT) var_array 
-
-      -----------------------------------------------------------------------
-      (IMPORTANT: this array is 1-based for both Z_PER_NODE and Z_PER_ELEM!!!)
-      -----------------------------------------------------------------------
-
-            if Z_PER_NODE:    = 1D array containing variable component value
-                                for each node.
-
-                                (Array will have been allocated
-                                 (number_of_nodes + 1) long)
-
-                      Info stored in this fashion:
-                            var_array[0] = not used
-                            var_array[1] = var component for node 1 of part
-                            var_array[2] = var_component for node 2 of part
-                            var_array[3] = var_component for node 3 of part
-                            etc.
-
-            if Z_PER_ELEM:    = 1D array containing variable component
-                                value for each element of a particular
-                                part and type.
-                                    
-                              (Array will have been allocated
-                               (number_of_elements[which_part][which_type] + 1)
-                                long.  See USERD_get_gold_part_build_info)
-
-                  Info stored in this fashion:
-                    var_array[1] = var component for elem 1 (of part and type)
-                    var_array[2] = var component for elem 2 (of part and type)
-                    var_array[3] = var component for elem 3 (of part and type)
-                    etc.
-
-   Notes:
-   -----
-   * Not called unless Num_variables is > 0
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * Will be based on Current_time_step
-
-   * If the variable is not defined for this part, simply return with a
-     value of Z_UNDEF.  EnSight will treat the variable as undefined for
-     this part.
-
-
---------------------------------------------------------------------
-USERD_get_var_value_at_specific
-
-   Description:
-   -----------
-   if Z_PER_NODE:
-     Get the value of a particular variable at a particular node in a
-     particular part at a particular time.
-
-   or if Z_PER_ELEM:
-     Get the value of a particular variable at a particular element of
-     a particular type in a particular part at a particular time.
-
-
-   Specification:
-   -------------
-   int USERD_get_var_value_at_specific(int which_var,
-                                       int which_node_or_elem,
-                                       int which_part,
-                                       int which_elem_type,
-                                       int time_step,
-                                       float values[3],
-                                       int imag_data)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  which_var   = The variable number
-
-   (IN)  which_node_or_elem
-
-              If Z_PER_NODE:
-                = The node number.  This is not the id, but is
-                                    the index of the global node 
-                                    list (1 based), or the block's
-                                    node list (1 based).
-
-                  Thus,  coord_array[1]
-                         coord_array[2]
-                         coord_array[3]
-                              .      |
-                              .      |which_node_or_elem index
-                              .             ----
-
-
-              If Z_PER_ELEM:
-                = The element number.  This is not the id, but is
-                                       the element number index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info),
-                                        or the block's element list (1 based).
-
-                  Thus,  for which_part:
-                         conn_array[which_elem_type][0]
-                         conn_array[which_elem_type][1]
-                         conn_array[which_elem_type][2]
-                              .                      |
-                              .          which_node_or_elem index
-                              .                        ----
-
-
-   (IN)  which_part                 Since EnSight Version 7.4
-                                    -------------------------
-                                  = The part number
-
-                                    (1-based index of part table, namely:
-
-                                       1 ... Numparts_available.
-
-                                     It is NOT the part_id that
-                                     is loaded in USERD_get_gold_part_build_info)
-
-                                    Prior to EnSight Version 7.4
-                                    ----------------------------
-                                  = The part id   This is the part_id label loaded
-                                                  in USERD_get_gold_part_build_info.
-                                                  It is NOT the part table index.
-
-
-   (IN)  which_elem_type
-
-              If Z_PER_NODE, or block part:
-                = Not used
-
-              If Z_PER_ELEM:
-                = The element type.    This is the element type index
-                                       of the number_of_element array
-                                       (see USERD_get_gold_part_build_info)
-
-   (IN)  time_step   = The time step
-
-   (IN)  imag_data   = TRUE if want imaginary value.
-                       FALSE if want real value.
-
-   (OUT) values      = scalar or vector component value(s)
-                        values[0] = scalar or vector[0]
-                        values[1] = vector[1]
-                        values[2] = vector[2]
-
-
-   Notes:
-   -----
-   * This routine is used in node querys over time (or element querys over
-     time for Z_PER_ELEM variables).  If these operations are not critical
-     to you, this can be a dummy routine.
-
-   * The per_node or per_elem classification must be obtainable from the
-     variable number (a var_classify array needs to be retained)
-
-   * The time step given is for the proper variable timeset.
-
-
-----------------------------------------------------------------------
-USERD_load_matf_data
-
-   Description:
-   -----------
-   Get the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_load_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *ids_list,
-                             float *val_list)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) ids_list          = If mat_type is Z_MAT_INDEX:
-                            ---------------------------
-                             1D material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MAT_INDEX)
-
-                            If mat_type is Z_MIX_INDEX:
-                            ---------------------------
-                             1D mixed-material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MIX_INDEX)
-
-  (OUT) val_list          = 1D mixed-materials values list
-                            (only used if mat_type is Z_MIX_VALUE)
-
-                               (Float array will have been allocated
-                                the appropriate size, as returned in
-                                USERD_size_matf_data for mat_type Z_MIX_VALUE)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero,
-     or Num_materials[set_index] is zero,
-     or the appropriate size from USERD_size_matf_data is zero
-
-
-
---------------------------------------------------------------------
-USERD_set_filenames
-
-   Description:
-   -----------
-   Receives the geometry and result filenames entered in the data
-   dialog.  The user written code will have to store and use these
-   as needed. The user written code must manage its own files!!
-
-   Specification:
-   -------------
-   int USERD_set_filenames(char filename_1[],
-                           char filename_2[],
-                           char the_path[],
-                           int swapbytes)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN) filename_1   = the filename entered into the geometry
-                         field of the data dialog.
-
-   (IN) filename_2   = the filename entered into the result
-                         field of the data dialog.
-			 (If the two_fields flag in USERD_get_name_of_reader
-			  is FALSE, this will be null string)
-
-   (IN) the_path     = the path info from the data dialog.
-                       Note: filename_1 and filename_2 have already
-                            had the path prepended to them.  This
-                            is provided in case it is needed for
-                            filenames contained in one of the files
-
-   (IN) swapbytes    = TRUE if should swap bytes when reading data.
-                     = FALSE normally.
-
-   Notes:
-   -----
-   * Since you must manage everything from the input that is entered in
-     these data dialog fields, this is an important routine!
-
-   * It may be that you will need to have an executive type file that contains
-     info and other filenames within it, like EnSight6's case file.
-
-
---------------------------------------------------------------------
-USERD_set_server_number
-
-   Description:
-   -----------
-   Receives the server number of how many total servers.
-
-   Specification:
-   -------------
-   int USERD_set_server_number(int cur_serv,
-                               int tot_servs)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) cur_serv    = the current server.
-
-   (IN) tot_servs   = the total number of servers.
-
-   Notes:
-   -----
-   * Only useful if your user defined reader is being used with EnSight's
-     Server-of-Server capability.  And even then, it may or may not be
-     something that you can take advantage of.  If your data is already
-     partitioned in some manner, such that you can access the proper
-     portions using this information.
- 
-     For all non-SOS uses, this will simply be 1 of 1
-
-
-
---------------------------------------------------------------------
-USERD_set_time_set_and_step
-
-   Description:
-   -----------
-   Set the current time step in the desired timeset.  All functions that
-   need time, and that do not explicitly pass it in, will use the timeset
-   and step set by this routine, if needed.
-
-   Specification:
-   -------------
-   void USERD_set_time_set_and_step(int timeset_number,
-                                    int time_step)
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   (IN) timeset_number  = the timeset number (1 based).
- 
-                          For example:  If USERD_get_number_of_timesets
-                                        returns 2, the valid timeset_number's
-                                        would be 1 and 2.
-
-   (IN) time_step       = The current time step to set
-
-   Notes:
-   -----
-   * Current_time_step and Current_timeset would be set here
-
-
---------------------------------------------------------------------
-USERD_size_matf_data
-
-   Description:
-   -----------
-   Get the length of the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_size_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *matf_size)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) matf_size         = the length of the material id list, or
-                            mixed-material id list, or
-                            mixed-material values list
-                            for the given material set and part number
-                            (and element type if Z_MAT_INDEX)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
-
-
---------------------------------------------------------------------
-USERD_stop_part_building
-
-   Description:
-   -----------
-   This routine called when the part building dialog is closed.  It is
-   provided in case you desire to release memory, etc. that was only needed
-   during the part building process.
-
-   Specification:
-   -------------
-   void USERD_stop_part_building( void )
-
-   Returns:
-   -------
-   nothing
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-
-
----- end of doucment ----
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/README_USERD_2.03_CHANGES
+++ /dev/null
@@ -1,1374 +0,0 @@
-README_USERD_2.03
-=================
-
-At this API revision level:
-
-1. Routines to handle materials have been added.
-2. Routines to handle nsided and nfaced elements have been added
-3. A routine has modified so structured ranges can be specified
-
-****************************************************************************
-Note: The dummy_gold reader, the Ensight Gold example reader, and the
-      SILO reader have been moved to this 2.03 API level.
-****************************************************************************
-
--------------------------------
-Quick Index of Library Routines
--------------------------------
-
-The new new routines are:
--------------------------
-USERD_get_number_of_material_sets    Gets the number of material sets
-USERD_get_matf_set_info              Gets the material set indices and names
-USERD_get_number_of_materials        Gets the number of materials
-USERD_get_matf_var_info              Gets the material indices and descriptions
-USERD_size_matf_data                 Gets the length of either the
-                                        material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-USERD_load_matf_data                 Gets the material ids list,
-                                        mixed-material ids list, or
-                                        mixed-material values list
-
-USERD_get_nsided_conn                Gets the element connectivities for nsided
-                                        elements. (utilizes the number of nodes
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_nodes_per_face      Gets the number of nodes per face for nfaced
-                                        elements (utilizes the number of faces
-                                        per element obtained in
-                                        USERD_get_part_elements_by_type)
-USERD_get_nfaced_conn                Gets the element connectivities for nfaced
-                                        elements (utilizes the number of nodes
-                                        per face obtained in
-                                        USERD_get_nfaced_nodes_per_face)
-The modified routine is:
-------------------------
-USERD_get_gold_part_build_info       Gets the info needed for part building
-                                        process
-
---------------------
-Header files changes
---------------------
-global_extern.h         has appropriate changes, must use it
-global_extern_protr.h   new file, access from global_extern.h
-
-Basically the the old global_extern.h file has been split into two files now.
-
-
-
--------------------------
-Order Routines are called
--------------------------
-
-The various main operations are given basically in the order they will
-be performed.  Within each operation, the order the routines will be
-called is given.  
-
-10. To see if materials in the model
-
-        USERD_get_number_of_material_sets
-
-      If any material sets in the model (calls these once per material set):
-        USERD_get_matf_set_info
-        USERD_get_number_of_materials
-        USERD_get_matf_var_info
-
-      For each elment type of each part containing material ids, calls:
-        USERD_size_matf_data
-        USERD_load_matf_data
-
-      If there are any elements with mixed materials, when a domain or
-      interface is created, calls these again per part:
-
-        USERD_size_matf_data
-        USERD_load_matf_data
-
-6. Part building (per part created)
-
-        both unstructured and structured:
-        --------------------------------
-        USERD_set_time_set_and_step
-
-        if unstructured part:
-        --------------------
-        USERD_get_part_element_ids_by_type
-        USERD_get_part_elements_by_type
-
-          If any nsided elements:
-  
-            USERD_get_nsided_conn
-
-          If any nfaced elements:
-
-            USERD_get_nfaced_nodes_per_face
-            USERD_get_nfaced_conn
-
-        USERD_get_part_coords
-        USERD_get_part_node_ids
- 
-         .
-         .
-         .
-
-
------------------------
-Detailed Specifications
------------------------
-
-Include files:
---------------
-The following header file is required in any file containing these library
-routines. 
-
-       #include "global_extern.h"
-
-
-
-*******************************************************************************
-****************************** Special Note ***********************************
-*******************************************************************************
-
-Make sure you use the proper define in the global_extern.h header file, namely:
-#define USERD_API_203
-
-Also, Make sure the api version in the USERD_get_reader_version routine is set
-to "2.03" or larger.
-
-Make sure your reader has access to the global_extern_proto.h   This is a new
-file which is access from the new global_extern.h    
-
-*******************************************************************************
-*******************************************************************************
-
-____________________
---------------------
-New Library Routines
-____________________
---------------------
-
---------------------------------------------------------------------
-USERD_get_number_of_material_sets -
-
-   Description:
-   -----------
-   Get the number of material sets in the model
-
-   Specification:
-   -------------
-   int USERD_get_number_of_material_sets( void )
-
-
-   Returns:
-   -------
-   Num_material_sets = number of material sets
-                       (Zero would indicate that you have no materials
-                        to deal with in the model)
-
-                       or
-
-                       -1 if an error condition
-
-   Arguments:
-   ---------
-   none
-
-   Notes:
-   -----
-  * You may want to keep this as a global for use in other routines.
-
-   ###############################################################
-   NOTE:  For EnSight 7.6, only one material set is supported
-          within EnSight.
-          Thus the only valid returns here are:
-               0 (no materials)
-               1 (for the one material set allowed)
-          or  -1 (if an error)
-
-          If the casefile has more than this, this reader will
-          read them, but EnSight will issue an error message and
-          choke on them!
-   ###############################################################
-
-  ================================================================
-  A very simple explanatory example, to use as a reference for the
-  materials routines:
-
-  Given a 2D mesh composed of 9 quad (Z_QUA04) elements, with two materials.
-  Most of the model is material 1, but the top left corner is material 9 -
-  basically as shown:
-
-
-        *--------*--------*--------*
-        |        |   /    |        |
-        |     Mat 9 /     |        |
-        |        | /      |        |
-        |        |/       |        |
-        |  e7    /   e8   |   e9   |
-        |       /|        |        |
-        |      / |        |        |
-        |     /  |        |        |
-        *----/---*--------*--------*
-        |   /    |        |        |
-        |  /     |        |        |
-        | /      |      Mat 1      |
-        |/       |        |        |
-        |   e4   |   e5   |   e6   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        |   e1   |   e2   |   e3   |
-        |        |        |        |
-        |        |        |        |
-        |        |        |        |
-        *--------*--------*--------*
-
-
-  Thus, in this routine, set:
-    Num_material_sets = 1
-
-  In USERD_get_matf_set_info, set:
-    mat_set_ids[0]    = 1
-    mat_set_name[0]   = "Material Set 1"  (or whatever name desired)
-
-  In USERD_get_number_of_materials, input would be set_index = 0, and
-  would need to set:
-    Num_materials[0] = 2
-
-  For simplicity, the ids and descriptions that would be returned in
-  USERD_get_matf_var_info could be:
-    mat_ids[0] = 1
-    mat_ids[1] = 9
-    mat_desc[0] = "mat 1"   (or whatever desired)
-    mat_desc[2] = "mat 9"
-
-  The per element material ids list would need to be:
-
-     material ids:
-     -------------
-     ids_list[0] = 1  (material id 1, for elem e1)
-     ids_list[1] = 1  (     "                  e2)
-     ids_list[2] = 1  (     "                  e3)
-     ids_list[3] = -1 (negative of index into mixed-material id list, for elem e4)
-     ids_list[5] = 1  (material id 1, for elem e5)
-     ids_list[5] = 1  (     "                  e6)
-     ids_list[5] = -5 (negative of index into mixed-material id list, for elem e7)
-     ids_list[5] = -9 (     "                                                  e8)
-     ids_list[5] = 1  (material id 1, for elem e9)
-
-  Finally we need the mixed material ids list and the mixed materials values list,
-  which would need to be:
-
-       mixed-material ids:
-       -------------------
-   ==> 1  ids_list[0]  =  2  (the -1 in the material variable points here,
-                                      2 indicates that two materials are present)
-       2  ids_list[1]  =  1  (1st material is 1)
-       3  ids_list[2]  =  9  (2nd material is 9)
-       4  ids_list[3]  = -1  (negative of index into mixed-material val_list)
-   ==> 5  ids_list[4]  =  2  (the -5 in the material variable points here,
-                                      2 indicates that two materials are present)
-       6  ids_list[5]  =  1  (1st material is 1)
-       7  ids_list[6]  =  9  (2nd material is 9)
-       8  ids_list[7]  = -3  (negative of index into mixed-material val_list)
-   ==> 9  ids_list[8]  =  2     etc.
-       10 ids_list[9]  =  1
-       11 ids_list[10] =  9
-       12 ids_list[11] = -5
-
-       mixed-material values:
-       ----------------------
-   ==> 1 val_list[0] = 0.875 (the -1 in the  mixed-material ids_list points here,
-                                       and this is the value for material 1)
-       2 val_list[1] = 0.125 (the value for material 9)
-   ==> 3 val_list[2] = 0.125 (the -3 in the mixed-materials ids_list points here)
-       4 val_list[3] = 0.875
-   ==> 5 val_list[4] = 0.875 (the -5 in the mixed-materials ids_list points here)
-       6 val_list[5] = 0.125
-
-  So, USERD_size_matf_data would need to return
-       matf_size = 8, when called with set_id    = 1
-                                       part_id   = 1
-                                       wtyp      = Z_QUA04
-                                       mat_type  = Z_MAT_INDEX
-
-       matf_size = 12, when called with set_id   = 1
-                                        part_id  = 1
-                                        mat_type = Z_MIX_INDEX
-
-                 = 6, when called with set_id   = 1
-                                       part_id  = 1
-                                       mat_type = Z_MIX_VALUE
-
-  And, USERD_load_matf_data would need to return:
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       wtyp     = Z_QUA04
-       mat_type = Z_MAT_INDEX (indicating id list).
-
-    the int array ids_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_INDEX (indicating id list).
-
-    the float array val_list as shown above when called with:
-       set_id   = 1
-       part_id  = 1
-       mat_type = Z_MIX_VALUE (indicating val list).
-
-
-
--------------------------------------------------------------------------
-USERD_get_matf_set_info
-
-   Description:
-   -----------
-   Get the material set ids and names
-
-   Specification:
-   -------------
-   int USERD_get_matf_set_info(int *mat_set_ids,
-                               char **mat_set_name)
-
-   Returns: 
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) mat_set_ids  = 1D material set ids array
-
-                               (Array will have been allocated
-                                Num_material_sets long)
-
-   (OUT) mat_set_name = 2D material set name array
-
-                               (Array will have been allocated
-                                Num_material_sets by Z_BUFL long)
-
-   Notes:
-   -----
-   * Will not be called if Num_material_sets is zero
-   * See USERD_get_number_of_material_sets header for explanatory example
-
-
--------------------------------------------------------------------------
-USERD_get_number_of_materials
-
-   Description:
-   -----------
-   Gets the number of materials in the material set
-
-   Specification:
-   -------------
-   int USERD_get_number_of_materials( int set_index )
-
-   Returns:
-   -------
-   Num_materials[set_index]   = Number of materials in the set
-                                 0 indicates no materials information present
-                                -1 indicates an error
-   Arguments:
-   ---------
-   (IN) set_index             = the material set index (zero based)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero
-  * You may want to keep this as a global for use in other routines.
-
-
---------------------------------------------------------------------
-USERD_get_matf_var_info
-
-   Description:
-   -----------
-   Gets the material ids and descriptions for the material set
-
-   Specification:
-   -------------
-   int USERD_get_matf_var_info(int set_index,
-                               int *mat_ids,
-                               char **mat_desc)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  set_index               = the material set index (zero based)
-
-   (OUT) mat_ids[set_index]      = 1D integer array containing the material
-                                   ids to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] long)
-
-   (OUT) mat_desc[set_index]     = 2D char array containing the material
-                                   descriptions to associated with each material
-
-                                    (Array will have been allocated
-                                     Num_materials[set_index] by Z_BUFL long)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
---------------------------------------------------------------------
-USERD_size_matf_data
-
-   Description:
-   -----------
-   Get the length of the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_size_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *matf_size)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) matf_size         = the length of the material id list, or
-                            mixed-material id list, or
-                            mixed-material values list
-                            for the given material set and part number
-                            (and element type if Z_MAT_INDEX)
-
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero, or
-     Num_materials[set_index] is zero
-
-
-----------------------------------------------------------------------
-USERD_load_matf_data
-
-   Description:
-   -----------
-   Get the material id list, mixed-material id list, or
-   mixed-material values list for the given material set and part (and
-   element type if material id list)
-
-   Specification:
-   -------------
-   int USERD_load_matf_data( int set_index,
-                             int part_id,
-                             int wtyp,
-                             int mat_type,
-                             int *ids_list,
-                             float *val_list)
-
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-  (IN)  set_index         = the material set index (zero based)
-
-  (IN)  part_id           = the part number desired
-
-  (IN)  wtyp              = the element type        (used for Z_MAT_INDEX only)
-
-                                  Z_POINT    node point element
-                                  Z_BAR02    2 node bar
-                                  Z_BAR03    3 node bar
-                                  Z_TRI03    3 node triangle
-                                  Z_TRI06    6 node triangle
-                                  Z_QUA04    4 node quad
-                                  Z_QUA08    8 node quad
-                                  Z_TET04    4 node tetrahedron
-                                  Z_TET10   10 node tetrahedron
-                                  Z_PYR05    5 node pyramid
-                                  Z_PYR13   13 node pyramid
-                                  Z_PEN06    6 node pentahedron
-                                  Z_PEN15   15 node pentahedron
-                                  Z_HEX08    8 node hexahedron
-                                  Z_HEX20   20 node hexahedron
-                                  Z_NSIDED  nsided polygon
-                                  Z_NFACED  nfaced polyhedron
-
-                                  Z_G_POINT    ghost node point element
-                                  Z_G_BAR02    2 node ghost bar
-                                  Z_G_BAR03    3 node ghost bar
-                                  Z_G_TRI03    3 node ghost triangle
-                                  Z_G_TRI06    6 node ghost triangle
-                                  Z_G_QUA04    4 node ghost quad
-                                  Z_G_QUA08    8 node ghost quad
-                                  Z_G_TET04    4 node ghost tetrahedron
-                                  Z_G_TET10   10 node ghost tetrahedron
-                                  Z_G_PYR05    5 node ghost pyramid
-                                  Z_G_PYR13   13 node ghost pyramid
-                                  Z_G_PEN06    6 node ghost pentahedron
-                                  Z_G_PEN15   15 node ghost pentahedron
-                                  Z_G_HEX08    8 node ghost hexahedron
-                                  Z_G_HEX20   20 node ghost hexahedron
-                                  Z_G_NSIDED  ghost nsided polygon
-                                  Z_G_NFACED  ghost nfaced polyhedron
-
-  (IN)  mat_type          = Z_MAT_INDEX for material ids list
-                            Z_MIX_INDEX for mixed-material ids list
-                            Z_MIX_VALUE for mixed-material values list
-
-  (OUT) ids_list          = If mat_type is Z_MAT_INDEX:
-                            ---------------------------
-                             1D material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MAT_INDEX)
-
-                            If mat_type is Z_MIX_INDEX:
-                            ---------------------------
-                             1D mixed-material id list
-                               (Int array will have been allocated
-                                the appropriate size, as returned in
-                                 USERD_size_matf_data for mat_type Z_MIX_INDEX)
-
-  (OUT) val_list          = 1D mixed-materials values list
-                            (only used if mat_type is Z_MIX_VALUE)
-
-                               (Float array will have been allocated
-                                the appropriate size, as returned in
-                                USERD_size_matf_data for mat_type Z_MIX_VALUE)
-  
-   Notes:
-   -----
-  * See USERD_get_number_of_material_sets header for explanatory example
-  * Will not be called if Num_material_sets is zero,
-     or Num_materials[set_index] is zero,
-     or the appropriate size from USERD_size_matf_data is zero
-
-
-
---------------------------------------------------------------------
-USERD_get_nsided_conn -
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided elements
-
-   Specification:
-   -------------
-   int USERD_get_nsided_conn(int part_number,
-                             int *nsided_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number         = the part number
-
-   (OUT) nsided_conn_array   = 1D array of nsided connectivies
-  
-                               (int array will have been allocated long enough
-                                to hold all the nsided connectivities. Which is
-                                the sum of all the nodes_per_element values in
-                                the conn_array of USERD_get_part_elements_by_type)
-  
-
-   Notes:
-   -----
-   * Will not be called unless there are some nsided elements in the the part.
-
-   * Providing nsided information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nsided
-        elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of nodes per nsided element. (as if connectivity
-        length of an nsided element is one)
-  
-     3. In this routine, provide the streamed connectivities for each of the
-        nsided elements.
-  
-  
-     Simple example:         5        6
-                            +--------+
-     3 nsided elements:    /|         \
-     (1 4-sided           / |          \
-      1 3-sided          /  |           \
-      1 7-sided)        /   |            \ 7
-                       /3   |4            +
-                      +-----+             |
-                      |     |             |
-                      |     |             |8
-                      |     |             +
-                      |     |            /
-                      |     |           /
-                      |     |          /
-                      |1    |2        /9
-                      +-----+--------+
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NSIDED] = 3
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      3 x 1
-  
-          for element_type of Z_NSIDED:
-              conn_array[0][0] = 4           (for the 4-sided element)
-              conn_array[1][0] = 3           (for the 3-sided element)
-              conn_array[2][0] = 7           (for the 7-sided element)
-  
-                           Sum  ===
-                                 14    <---------+
-                                                 |
-      3. In this routine:                        |
-           length of nsided_conn_array will be:  14
-  
-              nsided_conn_array[0]  = 1      (connectivity of 4-sided element)
-              nsided_conn_array[1]  = 2
-              nsided_conn_array[2]  = 4
-              nsided_conn_array[3]  = 3
-  
-              nsided_conn_array[4]  = 3      (connectivity of 3-sided element)
-              nsided_conn_array[5]  = 4
-              nsided_conn_array[6]  = 5
-  
-              nsided_conn_array[7]  = 2      (connectivity of 7-sided element)
-              nsided_conn_array[8]  = 9
-              nsided_conn_array[9]  = 8
-              nsided_conn_array[10] = 7
-              nsided_conn_array[11] = 6
-              nsided_conn_array[12] = 5
-              nsided_conn_array[13] = 4
-
-
-
---------------------------------------------------------------------
-USERD_get_nfaced_nodes_per_face -
-
-   Description:
-   -----------
-   Gets the array containing the number of nodes per face for each face
-   of the nfaced elements.
-
-   Specification:
-   -------------
-   int USERD_get_nfaced_nodes_per_face(int part_number,
-                                       int *nfaced_npf_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number       = the part number
-
-   (OUT) nfaced_npf_array  = 1D array of nodes per face for all faces of
-                             nfaced elements
- 
-                             (int array will have been allocated long enough
-                              to hold all the nodes_per_face values. Which is
-                              the sum of all the number of faces per element
-                              values in the conn_array of
-                              USERD_get_part_elements_by_type)
-
-   Notes:
-   -----
-   * Will not be called unless there are some nfaced elements in the
-     the part
-
-   * Providing nfaced information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-  
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-  
-  
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-  
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In this routine:                       |
-           length of nfaced_npf_array will be:  12
-  
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-  
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-  
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In USERD_get_nfaced_conn:                    |
-            length of the nfaced_conn_array will be:  48
-  
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-  
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-  
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-  
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-  
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-  
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-  
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-  
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-  
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-  
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-  
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-  
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-
---------------------------------------------------------------------
-USERD_get_nfaced_conn
-
-   Description:
-   -----------
-   Gets the array containing the connectivity of nsided faces of nfaced elements
-
-   Specification:
-   -------------int
-   int USERD_get_nfaced_conn(int part_number,
-                             int *nfaced_conn_array)
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (IN)  part_number        = the part number
-
-   (OUT) nfaced_conn_array  = 1D array of nsided face connectivies of nfaced
-                              elements
-
-                              (int array will have been allocated long enough to
-                               hold all the nsided face connectivities. Which is
-                               the sum of all the nodes per face values in the
-                               nfaced_npf_array of USERD_get_nfaced_nodes_per_face)
-
-   Notes:
-   -----
- * Will not be called unless there are some nfaced elements in the part
-
- * Providing nfaced information to Ensight:
-  
-     1. In USERD_get_gold_part_build_info, provide the number of nfaced
-        polyhedral elements in the part.
-  
-     2. In USERD_get_part_elements_by_type, provide (in the conn_array),
-        the number of faces per nfaced element. (as if connectivity
-        length of an nfaced element is one)
-  
-     3. In this routine, provide the streamed number of nodes per face
-        for each of the faces of the nfaced elements.
-  
-  
-     Simple example:         11        10   12
-                            +--------+-----+
-     2 nfaced elements:    /|        |\   /|
-     (1 7-faced           / |        | \ / |
-      1 5-sided)         /  |        |  +9 |
-                        /   |        | /|  |
-                       /7   |      8 /  |  |
-                      +-----------+/ |  |  |
-                      |     |5    |  |4 |  |6
-                      |     +-----|--+--|--+
-                      |    /      |   \ | /
-                      |   /       |    \|/3
-                      |  /        |     +
-                      | /         |    /
-                      |/1         |2 /
-                      +-----------+/
-  
-      1. In USERD_get_gold_part_build_info:
-              number_of_elements[Z_NFACED] = 2
-                                             .
-                                            /|\
-                                             |
-      2. In USERD_get_part_elements_by_type:
-          length of conn_array will be:      2 x 1
-          for element_type of Z_NFACED:
-              conn_array[0][0] = 7           (for the 7-faced element)
-              conn_array[1][0] = 5           (for the 5-faced element)
-  
-                                ==
-                           Sum  12    <---------+
-                                                |
-      3. In USERD_get_faced_nodes_per_face:     |
-           length of nfaced_npf_array will be:  12
-  
-            nfaced_npf_array[0]  = 5  (5-noded top face of 7-faced element)
-            nfaced_npf_array[1]  = 5  (5-noded bot face of 7-faced element)
-            nfaced_npf_array[2]  = 4  (4-noded front face of 7-faced element)
-            nfaced_npf_array[3]  = 4  (4-noded left face of 7-faced element)
-            nfaced_npf_array[4]  = 4  (4-noded back face of 7-faced element)
-            nfaced_npf_array[5]  = 4  (4-noded right front face of 7-faced element)
-            nfaced_npf_array[6]  = 4  (4-noded right back face of 7-faced element)
-  
-            nfaced_npf_array[7]  = 3  (3-noded top face of 5-faced element)
-            nfaced_npf_array[8]  = 3  (3-noded bot face of 5-faced element)
-            nfaced_npf_array[9]  = 4  (4-noded back face of 5-faced element)
-            nfaced_npf_array[10] = 4  (4-noded right face of 5-faced element)
-            nfaced_npf_array[11] = 4  (4-noded left front face of 5-faced element)
-  
-                                   ==
-                             Sum   48   <-------------+
-                                                      |
-      4. In this function:                            |
-            length of the nfaced_conn_array will be:  48
-  
-            nsided_conn_array[0] = 7   (conn of 5-noded top face of 7-faced elem)
-            nsided_conn_array[1] = 8
-            nsided_conn_array[2] = 9
-            nsided_conn_array[3] = 10
-            nsided_conn_array[4] = 11
-  
-            nsided_conn_array[5] = 1   (conn of 5-noded bot face of 7-faced elem)
-            nsided_conn_array[6] = 5
-            nsided_conn_array[7] = 4
-            nsided_conn_array[8] = 3
-            nsided_conn_array[9] = 2
-  
-            nsided_conn_array[10] = 1  (conn of 4-noded front face of 7-faced elem)
-            nsided_conn_array[11] = 2
-            nsided_conn_array[12] = 8
-            nsided_conn_array[13] = 7
-  
-            nsided_conn_array[14] = 5  (conn of 4-noded left face of 7-faced elem)
-            nsided_conn_array[15] = 1
-            nsided_conn_array[16] = 7
-            nsided_conn_array[17] = 11
-  
-            nsided_conn_array[18] = 4  (conn of 4-noded back face of 7-faced elem)
-            nsided_conn_array[19] = 5
-            nsided_conn_array[20] = 11
-            nsided_conn_array[21] = 10
-  
-            nsided_conn_array[22] = 2  (conn of 4-noded right front face of 7-faced)
-            nsided_conn_array[23] = 3
-            nsided_conn_array[24] = 9
-            nsided_conn_array[25] = 8
-  
-            nsided_conn_array[26] = 3  (conn of 4-noded right back face of 7-faced)
-            nsided_conn_array[27] = 4
-            nsided_conn_array[28] = 10
-            nsided_conn_array[29] = 9
-  
-            nsided_conn_array[30] = 9  (conn of 3-noded top face of 5-faced elem)
-            nsided_conn_array[32] = 12
-            nsided_conn_array[32] = 10
-  
-            nsided_conn_array[33] = 3  (conn of 3-noded bot face of 5-faced elem)
-            nsided_conn_array[34] = 4
-            nsided_conn_array[35] = 6
-  
-            nsided_conn_array[36] = 6  (conn of 4-noded back face of 5-faced elem)
-            nsided_conn_array[37] = 4
-            nsided_conn_array[38] = 10
-            nsided_conn_array[39] = 12
-  
-            nsided_conn_array[40] = 3  (conn of 4-noded right face of 5-faced elem)
-            nsided_conn_array[41] = 6
-            nsided_conn_array[42] = 12
-            nsided_conn_array[43] = 9
-  
-            nsided_conn_array[44] = 4  (conn of 4-noded left front face of 5-faced)
-            nsided_conn_array[45] = 3
-            nsided_conn_array[46] = 9
-            nsided_conn_array[47] = 10
-
-
-________________________
-------------------------
-Modified Library Routine
-________________________
-------------------------
-
---------------------------------------------------------------------
-USERD_get_gold_part_build_info
-
-   Description:
-   -----------
-   Gets the info needed for part building process
-
-   Specification:
-   -------------
-   int
-   USERD_get_gold_part_build_info(int *part_id,
-                                  int *part_types,
-                                  char *part_description[Z_BUFL],
-                                  int *number_of_nodes,
-                                  int *number_of_elements[Z_MAXTYPE],
-                                  int *ijk_dimensions[9],
-                                  int *iblanking_options[6])
-
-   Returns:
-   -------
-   Z_OK  if successful
-   Z_ERR if not successful
-
-   Arguments:
-   ---------
-   (OUT) part_id                = Array containing the external part
-                                  ids for each of the model parts.
- 
-                                  IMPORTANT:
-                                   Parts numbers must be >= 1, because
-                                   of the way they are used in the GUI
- 
-              *******************************************
-               The ids provided here are the numbers by
-               which the parts will be referred to in the
-               GUI (if possible). They are basically
-               labels as far as you are concerned.
- 
-               Note: The part numbers you pass to routines
-               which receive a part_number or block_number
-               or which_part as an argument are the 1-based
-               table index of the parts!
- 
-               example:  If Numparts_available = 3
- 
-                         Table index        part_id
-                         -----------        -------
-                          1                  13
-                          2                  57
-                          3                  125
- 
-                          ^                   ^
-                          |                   |
-                          |                    These are placed in:
-                          |                      part_id[0] = 13
-                          |                      part_id[1] = 57
-                          |                      part_id[2] = 125
-                          |                    for GUI labeling purposes.
-                          |
-                           These implied table indices are the part_number,
-                           block_number, or which_part numbers that you would
-                           pass to routines like:
- 
-                          USERD_get_part_coords(int part_number,...
-                          USERD_get_part_node_ids(int part_number,...
-                          USERD_get_part_elements_by_type(int part_number,...
-                          USERD_get_part_element_ids_by_type(int part_number,...
-                          USERD_get_block_coords_by_component(int block_number,...
-                          USERD_get_block_iblanking(int block_number,...
-                          USERD_get_block_ghost_flags(int block_number,...
-                          USERD_get_ghosts_in_block_flag(int block_number)
-                          USERD_get_border_availability( int part_number,...
-                          USERD_get_border_elements_by_type( int part_number,...
-                          USERD_get_var_by_component(int which_variable,
-                                                     int which_part,...
-                          USERD_get_var_value_at_specific(int which_var,
-                                                          int which_node_or_elem,
-                                                          int which_part,...
-              ********************************************
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) part_types             = Array containing one of the
-                                  following for each model part:
- 
-                                        Z_UNSTRUCTURED or
-                                        Z_STRUCTURED  or
-                                        Z_IBLANKED
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) part_description       = Array containing a description
-                                  for each of the model parts
- 
-                                   (Array will have been allocated
-                                    Numparts_available by Z_BUFL
-                                    long)
- 
-   (OUT) number_of_nodes        = Number of unstructured nodes in the part
- 
-                                   (Array will have been allocated
-                                    Numparts_available long)
- 
-   (OUT) number_of_elements     = 2D array containing number of
-                                  each type of element for each
-                                  unstructured model part.
-                                  ------------
-                                  Possible types are:
- 
-                                 Z_POINT   =  point
-                                 Z_BAR02   =  2-noded bar
-                                 Z_BAR03   =  3-noded bar
-                                 Z_TRI03   =  3-noded triangle
-                                 Z_TRI06   =  6-noded triangle
-                                 Z_QUA04   =  4-noded quadrilateral
-                                 Z_QUA08   =  8-noded quadrilateral
-                                 Z_TET04   =  4-noded tetrahedron
-                                 Z_TET10   = 10-noded tetrahedron
-                                 Z_PYR05   =  5-noded pyramid
-                                 Z_PYR13   = 13-noded pyramid
-                                 Z_PEN06   =  6-noded pentahedron
-                                 Z_PEN15   = 15-noded pentahedron
-                                 Z_HEX08   =  8-noded hexahedron
-                                 Z_HEX20   = 20-noded hexahedron
- 
-    Starting at API 2.01:
-    ====================
-                                 Z_G_POINT    ghost node point element
-                                 Z_G_BAR02    2 node ghost bar
-                                 Z_G_BAR03    3 node ghost bar
-                                 Z_G_TRI03    3 node ghost triangle
-                                 Z_G_TRI06    6 node ghost triangle
-                                 Z_G_QUA04    4 node ghost quad
-                                 Z_G_QUA08    8 node ghost quad
-                                 Z_G_TET04    4 node ghost tetrahedron
-                                 Z_G_TET10   10 node ghost tetrahedron
-                                 Z_G_PYR05    5 node ghost pyramid
-                                 Z_G_PYR13   13 node ghost pyramid
-                                 Z_G_PEN06    6 node ghost pentahedron
-                                 Z_G_PEN15   15 node ghost pentahedron
-                                 Z_G_HEX08    8 node ghost hexahedron
-                                 Z_G_HEX20   20 node ghost hexahedron
- 
-    Starting at API 2.02:
-    ====================
-                                 Z_NSIDED     n node nsided polygon
-                                 Z_NFACED     n face nfaced polyhedron
-                                 Z_G_NSIDED   n node ghost nsided polygon
-                                 Z_G_NFACED   n face ghost nfaced polyhedron
- 
-                                (Ignored unless Z_UNSTRUCTURED type)
- 
-                                   (Array will have been allocated
-                                    Numparts_available by
-                                    Z_MAXTYPE long)
- 
-   (OUT) ijk_dimensions         = 2D array containing ijk dimension info
-                                  for structured blocks
- 
-                                  For Z_UNSTRUCTURED - is ignored
- 
-                                  For Z_STRUCTURED or Z_IBLANKED
- 
-        Prior to version 2.03:
-        ----------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 3 long)
- 
-                              ijk_dimensions[][0] = I dimension
-                              ijk_dimensions[][1] = J dimension
-                              ijk_dimensions[][2] = K dimension
- 
- 
-        Starting at version 2.03:
-        ------------------------
-                                   (Array will have been allocated
-                                    Numparts_available by 9 long)
- 
-                              There are two ways to do this:
-                              ------------------------------
-                              1. The simple one, without ranges.
- 
-                                   This is good for all structured models
-                                   that will NOT be used in EnSight's
-                                   Server of Servers
- 
-                                   Simply provide the ijk dimensions in the
-                                   first three slots and place a -1 in
-                                   the 4th slot.  (The remaining slots will
-                                   be ignored).
- 
-                              Thus,
-                              ijk_dimensions[][0] = I dimension of block
-                              ijk_dimensions[][1] = J dimension of block
-                              ijk_dimensions[][2] = K dimension of block
-                              ijk_dimensions[][3] = -1
- 
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][4] = -1
-                              |       |       |
-                              |       |       |
-                            2 *-------*-------*
-                              |       |       |
-                              |       |       |
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
- 
-                              2. Using ranges.
- 
-                                  This one can be used anytime, but MUST
-                                  be used if EnSight's Server of Servers
-                                  is to be used!
- 
-                                  The first 3 slots contain the ijk dimension
-                                  of the complete block (of which this may be
-                                  a portion).  The last 6 slots contain the
-                                  ijk min and max ranges within the complete.
- 
-                              Thus,
-                              ijk_dimensions[][0] = I dim of complete block
-                              ijk_dimensions[][1] = J dim of complete block
-                              ijk_dimensions[][2] = K dim of complete block
- 
-                              ijk_dimensions[][3] = Imin of portion (1-based)
-                              ijk_dimensions[][4] = Imax of portion (1-based)
-                              ijk_dimensions[][5] = Jmin of portion (1-based)
-                              ijk_dimensions[][6] = Jmax of portion (1-based)
-                              ijk_dimensions[][7] = Kmin of portion (1-based)
-                              ijk_dimensions[][8] = Kmax of portion (1-based)
- 
- 
-                              example1: (Model has one part, a simple 2D block,
-                                         and want whole thing)
- 
-                        (J planes)
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[0][3] = 1
-                              |       |       |    ijk_dimension[0][4] = 3
-                              |       |       |    ijk_dimension[0][5] = 1
-                            2 *-------*-------*    ijk_dimension[0][6] = 4
-                              |       |       |    ijk_dimension[0][7] = 1
-                              |       |       |    ijk_dimension[0][8] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
-                              example2: (Want to have the block represented
-                                         in two portions - 2 parts)
- 
-                        (J planes)                 top portion
-                            4 *-------*-------*
-                              |       |       |    ijk_dimension[0][0] = 3
-                              |       |       |    ijk_dimension[0][1] = 4
-                              |       |       |    ijk_dimension[0][2] = 1
-                            3 *-------*-------*
-                              .       .       .    ijk_dimension[0][4] = 1
-                              .       .       .    ijk_dimension[0][4] = 3
-                              .       .       .    ijk_dimension[0][4] = 3
-                            2 .................    ijk_dimension[0][4] = 4
-                              .       .       .    ijk_dimension[0][4] = 1
-                              .       .       .    ijk_dimension[0][4] = 1
-                              .       .       .
-                            1 .................
-                              1       2       3  (I planes)
- 
- 
-                        (J planes)                 bottom portion
-                            4 .................
-                              .       .       .    ijk_dimension[1][0] = 3
-                              .       .       .    ijk_dimension[2][1] = 4
-                              .       .       .    ijk_dimension[3][2] = 1
-                            3 *-------*-------*
-                              |       |       |    ijk_dimension[1][4] = 1
-                              |       |       |    ijk_dimension[1][4] = 3
-                              |       |       |    ijk_dimension[1][4] = 1
-                            2 *-------*-------*    ijk_dimension[1][4] = 3
-                              |       |       |    ijk_dimension[1][4] = 1
-                              |       |       |    ijk_dimension[1][4] = 1
-                              |       |       |
-                            1 *-------*-------*
-                              1       2       3  (I planes)
- 
- 
-        And note that if you were partioning this block for
-        EnSight's Server of Servers, you would only have one part,
-        instead of two.  Each SOS server would return its appropriate
-        ranges in the last 6 slots. The first 3 slots would remain constant.
- 
- 
-   (OUT) iblanking_options      = 2D array containing iblanking
-                                  options possible for each
-                                  structured model part.
-                                  ----------
-                                  (Ignored unless Z_IBLANKED type)
- 
-                                  (Array will have been allocated
-                                   Numparts_available by 6 long)
- 
-       iblanking_options[][Z_EXT]     = TRUE if external (outside)
-                        [][Z_INT]     = TRUE if internal (inside)
-                        [][Z_BND]     = TRUE if boundary
-                        [][Z_INTBND]  = TRUE if internal boundary
-                        [][Z_SYM]     = TRUE if symmetry surface
-
-
-   Notes:
-   -----
-   If you haven't built a table of pointers to the different parts,
-   you might want to do so here as you gather the needed info.
- 
-   This will be based on Current_time_step
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_bkup.H
+++ /dev/null
@@ -1,16 +0,0 @@
-//======================================================================
-//    backup is not implemented
-//======================================================================
-int USERD_bkup
-(
-    FILE *archive_file,
-    int backup_type)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_bkup" << endl 
-        << flush;
-#endif
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_exit_routine.H
+++ /dev/null
@@ -1,15 +0,0 @@
-// Do nothing
-void USERD_exit_routine
-(
-    void
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_exit_routine" << endl 
-        << flush;
-#endif
-
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_border_availability.H
+++ /dev/null
@@ -1,19 +0,0 @@
-
-// Not used
-
-int USERD_get_border_availability
-(
-    int part_number,
-    int number_of_elements[Z_MAXTYPE]
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_border_availability for part_number " 
-        << part_number << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_border_elements_by_type.H
+++ /dev/null
@@ -1,21 +0,0 @@
-
-// Not called if USERD_border_availability returns Z_ERR
-
-int USERD_get_border_elements_by_type
-(
-    int part_number,
-    int element_type,
-    int **conn_array,
-    short *parent_element_type,
-    int *parnet_element_type
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_border_elements_by_type" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_changing_geometry_status.H
+++ /dev/null
@@ -1,13 +0,0 @@
-//======================================================================
-int USERD_get_changing_geometry_status(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_changing_geometry_status" << endl << flush;
-#endif
-
-    // Choose the most general option
-    return Z_CHANGE_CONN;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_constant_val.H
+++ /dev/null
@@ -1,17 +0,0 @@
-
-//======================================================================
-// Not in use
-//======================================================================
-float USERD_get_constant_val
-(
-    int which_var,
-    int imag_data
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_constant_val" << endl << flush;
-#endif
-    return 0.0;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_dataset_query_file_info.H
+++ /dev/null
@@ -1,10 +0,0 @@
-//======================================================================
-// NOT SUPPORTED... yet, if ever!
-//======================================================================
-int USERD_get_dataset_query_file_info(Z_QFILES *qfiles)
-{
-    // just return OK
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_descrip_lines.H
+++ /dev/null
@@ -1,34 +0,0 @@
-//======================================================================
-int USERD_get_descrip_lines
-(
-    int which_type,
-    int which_var,
-    int imag_data,
-    char line1[Z_BUFL],
-    char line2[Z_BUFL]
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_descrip_lines" << endl 
-        << flush;
-#endif
-
-    if (which_type == Z_GEOM)
-    {
-        strncpy(line1, meshName, Z_BUFL);
-        strncpy(line2, "", Z_BUFL);
-    }
-    else
-    {
-        strncpy(line1, "WHERE IS THIS LINE USED I WONDER???", Z_BUFL);
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_descrip_lines" << endl 
-        << flush;
-#endif
-    return Z_OK;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_element_label_status.H
+++ /dev/null
@@ -1,13 +0,0 @@
-//======================================================================
-//  if TRUE: set in USERD_get_element_ids_for_part
-//======================================================================
-int USERD_get_element_label_status(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_element_label_status" << endl << flush;
-#endif
-    return TRUE;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_geom_timeset_number.H
+++ /dev/null
@@ -1,16 +0,0 @@
-int USERD_get_geom_timeset_number
-(
-    void
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_geom_timeset_number" << endl 
-        << flush;
-#endif
-
-    Geom_timeset_number = 1;
-
-    return Geom_timeset_number;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_gold_part_build_info.H
+++ /dev/null
@@ -1,158 +0,0 @@
-//======================================================================
-// this is based on the current time step.
-//======================================================================
-int USERD_get_gold_part_build_info
-(
-    int *part_numbers,
-    int *part_types,
-    char *part_descriptions[Z_BUFL],
-    int *number_of_nodes,
-    int *number_of_elements[Z_MAXTYPE],
-    int *ijk_dimensions[3],
-    int *iblanking_options[6]
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_gold_part_build_info" << endl << flush;
-#endif
-
-    //#   include "checkForNewMesh.H"
-
-    const cellShapeList& cellShapes = meshPtr->cellShapes();
-    const cellList& cells = meshPtr->cells();
-
-    label nCells = cells.size();
-
-    // all parts are unstructured
-    for (label n = 0; n<Numparts_available; n++)
-    {
-        part_numbers[n] = n + 1;
-        part_types[n]   = Z_UNSTRUCTURED;
-    }
-
-    strncpy(part_descriptions[0], meshName, Z_BUFL);
-
-    for(label i=0; i<nPatches; i++)
-    {
-        word patchName(meshPtr->boundary()[i].name());
-        strncpy(part_descriptions[i+1], patchName.c_str(), Z_BUFL);
-    }
-
-    label nHex08 = 0;
-    label nPen06 = 0;
-    label nPyr05 = 0;
-    label nTet04 = 0;
-    label nFaced = 0;
-
-    for (label n=0; n<nCells; n++)
-    {
-        label nFacesInCell = cells[n].size();
-        labelList points = cellShapes[n];
-
-        if ((nFacesInCell == 6) && (points.size() == 8))
-        {
-            nHex08++;
-        }
-        else if ((nFacesInCell == 4) && (points.size() == 4))
-        {
-            nTet04++;
-        }
-        else if (nFacesInCell == 5)
-        {
-            if (points.size() == 6)
-            {
-                nPen06++;
-            }
-            else if (points.size() == 5)
-            {
-                nPyr05++;
-            }
-            else
-            {
-                nFaced++;
-            }
-        }
-        else
-        {
-            nFaced++;
-        }
-    }
-
-    for (label n=0; n < Z_MAXTYPE; n++)
-    {
-        for (label i=0; i<Numparts_available; i++)
-        {
-            number_of_elements[i][n] = 0;
-        }
-    }
-
-    number_of_elements[0][Z_TET04] = nTet04;
-    number_of_elements[0][Z_PYR05] = nPyr05;
-    number_of_elements[0][Z_HEX08] = nHex08;
-    number_of_elements[0][Z_PEN06] = nPen06;
-    number_of_elements[0][Z_NFACED] = nFaced;
-
-    /*
-    Info << "nTet04 = " << nTet04 << endl;
-    Info << "nPyr05 = " << nPyr05 << endl;
-    Info << "nHex08 = " << nHex08 << endl;
-    Info << "nPen06 = " << nPen06 << endl;
-    Info << "nFaced = " << nFaced << endl;
-        */
-
-    number_of_nodes[0] = meshPtr->nPoints();
-
-    const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-    for(label i=0; i<nPatches; i++)
-    {
-        label nTri03 = 0;
-        label nQuad04 = 0;
-        label nPoly = 0;
-
-        forAll(bMesh[i], n)
-        {
-            label nPoints = bMesh[i][n].size();
-
-            if (nPoints == 3)
-            {
-                nTri03++;
-            }
-            else  if (nPoints == 4)
-            {
-                nQuad04++;
-            }
-            else
-            {
-                nPoly++;
-            }
-        }
-
-        number_of_elements[i+1][Z_TRI03] = nTri03;
-        number_of_elements[i+1][Z_QUA04] = nQuad04;
-        number_of_elements[i+1][Z_NSIDED] = nPoly;
-
-        number_of_nodes[i+1] = bMesh[i].points().size();
-    }
-
-    if (Numparts_available > nPatches+1)
-    {
-        strncpy
-        (
-            part_descriptions[nPatches+1],
-            cloud::prefix.c_str(),
-            Z_BUFL
-        );
-        number_of_elements[nPatches+1][Z_POINT] = sprayPtr->size();
-        number_of_nodes[nPatches+1] = sprayPtr->size();
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_gold_part_build_info" << endl << flush;
-#endif
-
-    return Z_OK;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_gold_variable_info.H
+++ /dev/null
@@ -1,125 +0,0 @@
-//======================================================================
-//  variable 1 - var[0] , i.e variables are zero based
-//======================================================================
-int USERD_get_gold_variable_info
-(
-    char **var_description,
-    char **var_filename,
-    int *var_type,
-    int *var_classify,
-    int *var_complex,
-    char **var_ifilename,
-    float *var_freq,
-    int *var_contran,
-    int *var_timeset
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_gold_variable_info" << endl 
-        << flush;
-#endif
-
-    label offset = Num_variables - nSprayVariables;
-
-    // scalars first ...
-    for (label n=0; n<offset; n++)
-    {
-        if (isScalar[var2field[n]])
-        {
-            var_type[n]     = Z_SCALAR;
-            var_classify[n] = Z_PER_ELEM;
-            var_complex[n]  = FALSE;
-            var_timeset[n]  = 1;
-            strncpy
-            (
-                var_description[n],
-                fieldNames[var2field[n]].c_str(),
-                Z_BUFL
-            );
-        }
-    }
-
-    // ... and then vectors
-    for (label n=0; n<offset; n++)
-    {
-        if (isVector[var2field[n]])
-        {
-            var_type[n]     = Z_VECTOR;
-            var_classify[n] = Z_PER_ELEM;
-            var_complex[n]  = FALSE;
-            var_timeset[n]  = 1;
-            strncpy
-            (
-                var_description[n],
-                fieldNames[var2field[n]].c_str(),
-                Z_BUFL
-            );
-        }
-    }
-
-    // ... and tensors (NB! all tensors are treated as asymmetric)
-    for (label n=0; n<offset; n++)
-    {
-        if (isTensor[var2field[n]])
-        {
-            var_type[n]     = Z_TENSOR9;
-            var_classify[n] = Z_PER_ELEM;
-            var_complex[n]  = FALSE;
-            var_timeset[n]  = 1;
-            strncpy
-            (
-                var_description[n],
-                fieldNames[var2field[n]].c_str(),
-                Z_BUFL
-            );
-        }
-    }
-
-    if (Numparts_available > nPatches+1)
-    {
-
-        label Ns = lagrangianScalarNames.size();
-
-        for (label n=0; n<Ns; n++)
-        {
-            var_type[offset + n] = Z_SCALAR;
-            var_classify[offset + n] = Z_PER_ELEM;
-            var_complex[offset + n] = FALSE;
-            var_timeset[offset + n] = 1;
-            word name = parcelPrepend + lagrangianScalarNames[n];
-            strncpy
-            (
-                var_description[offset + n],
-                name.c_str(),
-                Z_BUFL
-            );
-        }
-
-        for (label n=0; n<lagrangianVectorNames.size(); n++)
-        {
-            var_type[offset + Ns + n] = Z_VECTOR;
-            var_classify[offset + Ns + n] = Z_PER_ELEM;
-            var_complex[offset + Ns + n] = FALSE;
-            var_timeset[offset + Ns  + n] = 1;
-            word name = parcelPrepend + lagrangianVectorNames[n];
-            strncpy
-            (
-                var_description[offset + Ns + n],
-                name.c_str(),
-                Z_BUFL
-            );
-        }
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_gold_variable_info" << endl 
-        << flush;
-#endif
-
-    return Z_OK;
-}
-
-
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_matf_set_info.H
+++ /dev/null
@@ -1,16 +0,0 @@
-
-int USERD_get_matf_set_info
-(
-    int *mat_set_ids,
-    char **mat_set_name
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_matf_set_info" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_matf_var_info.H
+++ /dev/null
@@ -1,17 +0,0 @@
-
-int USERD_get_matf_var_info
-(
-    int set_index,
-    int *mat_ids,
-    char **mat_desc
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_matf_var_info" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_maxsize_info.H
+++ /dev/null
@@ -1,103 +0,0 @@
-int USERD_get_maxsize_info
-(
-    int *max_number_of_nodes,
-    int *max_number_of_elements[Z_MAXTYPE],
-    int *max_ijk_dimensions[3]
-)
-{
-    return Z_ERR; 
-
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_maxsize_info" << endl;
-#endif
-
-    label maxNPoints = 0;
-    label maxNParcels = 0;
-
-    label nPen06Max = 0;
-    label nHex08Max = 0;
-    label nPyr05Max = 0;
-    label nTet04Max = 0;
-
-    Info<< "Checking all time steps for EnSight memory allocation purpose. This can take some time." << endl;
-
-    for (label timeI=1; timeI < timeDirs.size(); ++timeI)
-    {
-
-        label nPen06 = 0;
-        label nHex08 = 0;
-        label nPyr05 = 0;
-        label nTet04 = 0;
-
-        runTimePtr->setTime(timeDirs[timeI], timeI);
-
-        Info<< "Checking time = " << runTimePtr->timeName() << endl;
-
-        const cellShapeList& cells = meshPtr->cellShapes();
-        
-        const label nPoints = meshPtr->nPoints();
-        const label nCells  = cells.size();
-        
-        maxNPoints = max(maxNPoints, nPoints);
-
-        for (label n=0; n<nCells;n++)
-        {
-            label nFaces = cells[n].nFaces();
-            const labelList& points = cells[n];
-
-            if ((nFaces == 6) && (points.size() == 8))
-            {
-                nHex08++;
-            }
-            else if ((nFaces == 5) && (points.size() == 6))
-            {
-                nPen06++;
-            }
-            else if ((nFaces == 5) && (points.size() == 5))
-            {
-                nPyr05++;
-            }
-            else if ((nFaces == 4) && (points.size() == 4))
-            {
-                nTet04++;
-            }
-        }
-
-        nPen06Max = max(nPen06Max, nPen06);
-        nHex08Max = max(nHex08Max, nHex08);
-        nPyr05Max = max(nPyr05Max, nPyr05);
-        nTet04Max = max(nTet04Max, nTet04);
-
-        if (Numparts_available > 1)
-        {
-            // Get the maximum number of spray parcels
-            // and store it
-            Cloud<passiveParticle> lagrangian(*meshPtr);
-
-            if (lagrangian.size() > nMaxParcels)
-            {
-                nMaxParcels = lagrangian.size();
-            }
-        }
-    }
-
-    max_number_of_nodes[0] = maxNPoints;
-    max_number_of_elements[0][Z_HEX08] = nHex08Max;
-    max_number_of_elements[0][Z_PEN06] = nPen06Max;
-    max_number_of_elements[0][Z_PYR05] = nPyr05Max;
-    max_number_of_elements[0][Z_TET04] = nTet04Max;
-
-    if (Numparts_available > 1)
-    {
-        max_number_of_nodes[1] = maxNParcels;
-        max_number_of_elements[1][Z_POINT] = maxNParcels;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info<< "Leaving: USERD_get_maxsize_info" << endl;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_model_extents.H
+++ /dev/null
@@ -1,17 +0,0 @@
-
-// Not used. Let EnSight do the job.
-
-int USERD_get_model_extents
-(
-    float extents[6]
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_model_extents" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_name_of_reader.H
+++ /dev/null
@@ -1,20 +0,0 @@
-//======================================================================
-//  Setting name in the gui, and specifying one or two input fields
-//======================================================================
-int USERD_get_name_of_reader
-(
-    char reader_name[Z_MAX_USERD_NAME],
-    int *two_fields
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_name_of_reader" << endl << flush;
-#endif
-
-    strncpy(reader_name, readerName, Z_MAX_USERD_NAME);
-    *two_fields = FALSE;
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_nfaced_conn.H
+++ /dev/null
@@ -1,81 +0,0 @@
-
-int USERD_get_nfaced_conn
-(
-    int part_number,
-    int *nfaced_conn_array
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_nfaced_conn" 
-        << ", part_number = " << part_number
-        << endl 
-        << flush;
-#endif
-
-    if (part_number == 1)
-    {
-        label nPoint = 0;
-        const cellShapeList& cellShapes = meshPtr->cellShapes();
-        const cellList& cells = meshPtr->cells();
-        const faceList& faces = meshPtr->faces();
-        label nCells = cellShapes.size();
-
-        for (label n=0; n<nCells; n++)
-        {
-            label nFacesInCell = cells[n].size();
-            labelList points = cellShapes[n];
-            if ((nFacesInCell == 6) && (points.size() == 8))
-            {}
-            else if ((nFacesInCell == 4) && (points.size() == 4))
-            {}
-            else if (nFacesInCell == 5)
-            {
-                if (points.size() == 6)
-                {}
-                else if (points.size() == 5)
-                {}
-                else
-                {
-                    for(label i=0; i<nFacesInCell; i++)
-                    {
-                        label facei = cells[n][i];
-                        label nPoints = faces[facei].size();
-                        for(label j=0; j<nPoints; j++)
-                        {
-                            nfaced_conn_array[nPoint++] = faces[facei][j] + 1;
-                        }
-                    }
-                }
-            }
-            else
-            {
-                for(label i=0; i<nFacesInCell; i++)
-                {
-                    label facei = cells[n][i];
-                    label nPoints = faces[facei].size();
-                    for(label j=0; j<nPoints; j++)
-                    {
-                        nfaced_conn_array[nPoint++] = faces[facei][j] + 1;
-                    }
-                }
-            }
-        }
-        
-    }
-    else if (part_number < nPatches+2)
-    {
-        
-    }
-    else
-    {
-        return Z_ERR;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Exiting: USERD_get_nfaced_conn" << endl 
-        << flush;
-#endif
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_nfaced_nodes_per_face.H
+++ /dev/null
@@ -1,76 +0,0 @@
-
-int USERD_get_nfaced_nodes_per_face
-(
-    int part_number,
-    int *nfaced_npf_array
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_nfaced_nodes_per_face" 
-        << ", part_number = " << part_number
-        << endl 
-        << flush;
-#endif
-
-    if (part_number == 1)
-    {
-        const cellShapeList& cellShapes = meshPtr->cellShapes();
-        const cellList& cells = meshPtr->cells();
-        const faceList& faces = meshPtr->faces();
-
-        label nCells = cellShapes.size();
-        label nFaced = 0;
-        for (label n=0; n<nCells; n++)
-        {
-            label nFacesInCell = cells[n].size();
-            labelList points = cellShapes[n];
-            label nPoints = points.size();
-
-            if ((nFacesInCell == 6) && (nPoints == 8))
-            {}
-            else if ((nFacesInCell == 4) && (nPoints == 4))
-            {}
-            else if (nFacesInCell == 5)
-            {
-                if (nPoints == 6)
-                {}
-                else if (nPoints == 5)
-                {}
-                else
-                {
-                    for(label i=0; i<nFacesInCell; i++)
-                    {
-                        label facei = cells[n][i];
-                        label nFacePoints = faces[facei].size();
-                        nfaced_npf_array[nFaced++] = nFacePoints;
-                    }
-                }
-            }
-            else
-            {
-                for(label i=0; i<nFacesInCell; i++)
-                {
-                    label facei = cells[n][i];
-                    label nFacePoints = faces[facei].size();
-                    nfaced_npf_array[nFaced++] = nFacePoints;
-                }
-            }
-        }
-        
-    }
-    else if (part_number < nPatches+2)
-    {
-        return Z_ERR;
-    }
-    else
-    {
-        return Z_ERR;
-    }
-#ifdef ENSIGHTDEBUG
-    Info << "Exiting: USERD_get_nfaced_nodes_per_face" << endl 
-        << flush;
-#endif
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_node_label_status.H
+++ /dev/null
@@ -1,14 +0,0 @@
-//======================================================================
-// if TRUE: set in USERD_get_global_node_ids
-//======================================================================
-int USERD_get_node_label_status(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_node_label_status" << endl << flush;
-#endif
-
-    return TRUE;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_nsided_conn.H
+++ /dev/null
@@ -1,51 +0,0 @@
-
-int USERD_get_nsided_conn
-(
-    int part_number,
-    int *nsided_conn_array 
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_nsided_conn" 
-        << ", part_number = " << part_number
-        << endl 
-        << flush;
-#endif
-    if (part_number == 1)
-    {
-        Info << "************* EEEEEEEEERRRRRRRRRRRRRRRRRR *************** " << endl << flush;
-
-    }
-    else if (part_number < nPatches+2)
-    {
-        //const cellList& cells = meshPtr->cells();
-        //const faceList& faces = meshPtr->faces();
-
-        label patchi = part_number - 2;
-        const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-        label np = 0;
-        forAll(bMesh[patchi], facei)
-        {
-            label nPoints = bMesh[patchi][facei].size();
-            if ((nPoints != 3) && (nPoints != 4))
-            {
-                for(label i=0; i<nPoints; i++)
-                {
-                    nsided_conn_array[np++] = bMesh[patchi][facei][i] + 1;
-                }
-            }
-        }
-    }
-    else if (part_number == nPatches+2)
-    {
-        return Z_ERR;
-    }
-#ifdef ENSIGHTDEBUG
-    Info << "Exiting: USERD_get_nsided_conn" << endl 
-        << flush;
-#endif
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_num_of_time_steps.H
+++ /dev/null
@@ -1,17 +0,0 @@
-//======================================================================
-// don't use multiple time sets...NN
-//======================================================================
-int USERD_get_num_of_time_steps
-(
-    int timeset_number
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_num_of_time_steps" << endl 
-        << flush;
-#endif
-
-    return Num_time_steps;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_of_files_in_dataset.H
+++ /dev/null
@@ -1,15 +0,0 @@
-//======================================================================
-// 
-//======================================================================
-int USERD_get_number_of_files_in_dataset(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_files_in_dataset" << endl << flush;
-#endif
-
-    // use 1 insted of 0 which gives an un-necessary warning.
-    Num_dataset_files = 1;
-    return Num_dataset_files;;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_of_material_sets.H
+++ /dev/null
@@ -1,16 +0,0 @@
-
-int USERD_get_number_of_material_sets
-( 
-    void 
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_material_sets" << endl 
-        << flush;
-#endif
-
-    // No materials
-    return 0; 
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_of_materials.H
+++ /dev/null
@@ -1,16 +0,0 @@
-
-int USERD_get_number_of_materials
-(
-    int set_index
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_materials" << endl 
-        << flush;
-#endif
-
-    // No materials
-    return 0;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_of_model_parts.H
+++ /dev/null
@@ -1,11 +0,0 @@
-
-int USERD_get_number_of_model_parts(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_model_parts" << endl << flush;
-#endif
-
-    return Numparts_available;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_of_variables.H
+++ /dev/null
@@ -1,11 +0,0 @@
-//======================================================================
-int USERD_get_number_of_variables(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_variables" << endl << flush;
-#endif
-
-    return Num_variables;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_number_timesets.H
+++ /dev/null
@@ -1,15 +0,0 @@
-int USERD_get_number_of_timesets
-(
-    void
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_number_of_timesets" << endl 
-        << flush;
-#endif
-
-    Num_timesets = 1;
-    return  Num_timesets;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_part_coords.H
+++ /dev/null
@@ -1,79 +0,0 @@
-// Note: coord_array is 1-based.
-
-int USERD_get_part_coords
-(
-    int part_number,
-    float **coord_array
-)
-{
-
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_part_coords" << endl << 
-        "part_number = " << part_number << endl << flush;
-#endif
-
-    if (part_number == 1)
-    {
-
-        //#       include "checkForNewMesh.H"
-
-        const vectorField& points = meshPtr->points();
-        label nPoints = points.size();
-        
-        for (label indx=0; indx<nPoints; indx++)
-        {
-            coord_array[0][indx+1] = (float)points[indx].x();
-            coord_array[1][indx+1] = (float)points[indx].y();
-            coord_array[2][indx+1] = (float)points[indx].z();
-        }
-    }
-    else if (part_number < nPatches+2)
-    {
-
-        //#       include "checkForNewMesh.H"
-
-        label patchi = part_number-2;
-        const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-        const vectorField& points = bMesh[patchi].points();
-        label nPoints = points.size();
-        
-        for (label indx=0; indx<nPoints; indx++)
-        {
-            coord_array[0][indx+1] = (float)points[indx].x();
-            coord_array[1][indx+1] = (float)points[indx].y();
-            coord_array[2][indx+1] = (float)points[indx].z();
-        }
-
-    }
-    else if (part_number == nPatches+2)
-    {
-
-        label indx = 1;
-
-        for
-        (
-            Cloud<passiveParticle>::iterator elmnt = sprayPtr->begin();
-            elmnt != sprayPtr->end();
-            ++elmnt
-        )
-        {
-            coord_array[0][indx] = (float)elmnt().position().x();
-            coord_array[1][indx] = (float)elmnt().position().y();
-            coord_array[2][indx] = (float)elmnt().position().z();
-            indx++;
-        }
-
-    }
-    else
-    {
-        return Z_ERR;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_part_coords" << endl << flush;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_part_element_ids_by_type.H
+++ /dev/null
@@ -1,164 +0,0 @@
-int USERD_get_part_element_ids_by_type
-(
-    int part_number,
-    int element_type,
-    int *elemid_array
-)
-{
-
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_part_element_ids_by_type" << endl 
-        << "part_number = " << part_number << endl 
-        << "element_type = " << element_type << endl << flush;
-#endif
-
-    if (part_number == 1)
-    {
-        const cellShapeList& cellShapes = meshPtr->cellShapes();
-        const cellList& cells = meshPtr->cells();
-
-        label nCells = cells.size();
-
-        label nPen06 = 0;
-        label nHex08 = 0;
-        label nPyr05 = 0;
-        label nTet04 = 0;
-        label nFaced = 0;
-
-        if (element_type == Z_HEX08)
-        {
-            for (label n=0; n<nCells; n++)
-            {
-                label nFaces = cells[n].size();
-                labelList points = cellShapes[n];
-                
-                if ((nFaces == 6) && (points.size() == 8))
-                {
-                    elemid_array[nHex08++] = n + 1;
-                }
-            }
-        }
-        else if (element_type == Z_PEN06)
-        {
-            for (label n=0; n<nCells; n++)
-            {
-                label nFaces = cells[n].size();
-                labelList points = cellShapes[n];
-                
-                if ((nFaces == 5) && (points.size() == 6))
-                {
-                    elemid_array[nPen06++] = n + 1;
-                }
-            }
-        }
-        else if (element_type == Z_PYR05)
-        {
-            for (label n=0; n<nCells; n++)
-            {
-                label nFaces = cells[n].size();
-                labelList points = cellShapes[n];
-                
-                if ((nFaces == 5) && (points.size() == 5))
-                {
-                    elemid_array[nPyr05++] = n + 1;
-                }
-            }
-        }
-        else if (element_type == Z_TET04)
-        {
-            for (label n=0; n<nCells; n++)
-            {
-                label nFaces = cells[n].size();
-                labelList points = cellShapes[n];
-                
-                if ((nFaces == 4) && (points.size() == 4))
-                {
-                    elemid_array[nTet04++] = n + 1;
-                }
-            }
-        }
-        else if (element_type == Z_NFACED)
-        {
-            for (label n=0; n<nCells; n++)
-            {
-                label nFaces = cells[n].size();
-                labelList points = cellShapes[n];
-                if ((nFaces == 6) && (points.size() == 8))
-                {}
-                else if ((nFaces == 5) && (points.size() == 6))
-                {}
-                else if ((nFaces == 5) && (points.size() == 5))
-                {}
-                else if ((nFaces == 4) && (points.size() == 4))
-                {}
-                else
-                {
-                    elemid_array[nFaced++] = n + 1;
-                }
-
-            }
-        }
-    }
-    else if (part_number < nPatches+2)
-    {
-     
-        const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-        label patchi = part_number - 2;
-
-        label nTri03 = 0;
-        label nQuad04 = 0;
-        label nPoly = 0;
-
-        if (element_type == Z_TRI03)
-        {
-            forAll(bMesh[patchi], facei)
-            {
-                if (bMesh[patchi][facei].size() == 3)
-                {
-                    elemid_array[nTri03++] = facei + 1;
-                }
-            }
-        }
-        else if (element_type == Z_QUA04)
-        {
-            forAll(bMesh[patchi], facei)
-            {
-                if (bMesh[patchi][facei].size() == 4)
-                {
-                    elemid_array[nQuad04++] = facei + 1;
-                }
-            }            
-        }
-        else if (element_type == Z_NSIDED)
-        {
-            forAll(bMesh[patchi], facei)
-            {
-                label nPoints = bMesh[patchi][facei].size();
-                if ((nPoints != 3) && (nPoints != 4))
-                {
-                    elemid_array[nPoly++] = facei + 1;
-                }
-            }
-        }
-
-    }
-    else if (part_number == nPatches+2)
-    {
-        for (label n=0; n<sprayPtr->size(); n++)
-        {
-            elemid_array[n] = n + 1;
-        }
-    }
-    else
-    {
-        return Z_ERR;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_part_element_ids_by_type" << endl << flush;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_part_elements_by_type.H
+++ /dev/null
@@ -1,254 +0,0 @@
-int USERD_get_part_elements_by_type
-(
-    int part_number,
-    int element_type,
-    int **conn_array
-)
-{
-#   ifdef ENSIGHTDEBUG
-    Info<< "Entering: USERD_get_part_elements_by_type" << nl
-        << "part_number = " << part_number << nl
-        << "element_type = " << element_type;
-    if (element_type == Z_HEX08)
-    {
-        Info << " Z_HEX08";
-    }
-    else if (element_type == Z_PEN06)
-    {
-        Info << " Z_PEN06";
-    }
-    else if (element_type == Z_PYR05)
-    {
-        Info << " Z_PYR05";
-    }
-    else if (element_type == Z_TET04)
-    {
-        Info << " Z_TET04";
-    }
-    else if (element_type == Z_TRI03)
-    {
-        Info << " Z_TRI03";
-    }
-    else if (element_type == Z_QUA04)
-    {
-        Info << " Z_QUA04";
-    }
-    else if (element_type == Z_NFACED)
-    {
-        Info << " Z_NFACED";
-    }
-    else if (element_type == Z_NSIDED)
-    {
-        Info << " Z_NSIDED";
-    }
-    else
-    {
-        Info << " unknown";
-    }
-    Info << endl << flush;
-#   endif
-
-    if (part_number == 1)
-    {
-        const cellShapeList& cellShapes = meshPtr->cellShapes();
-        
-        //================================
-        // hexahedron
-        //================================
-        if (element_type == Z_HEX08)
-        {
-            const cellModel& hex = *(cellModeller::lookup("hex"));
-
-            label nHex08 = 0;
-            forAll(cellShapes, celli)
-            {
-                const cellShape& cellShape = cellShapes[celli];
-                const cellModel& cellModel = cellShape.model();
-                
-                if (cellModel == hex)
-                {
-                    forAll(cellShape, ip)
-                    {
-                        conn_array[nHex08][ip] = cellShape[ip] + 1;
-                    }
-                    nHex08++;
-                }
-            }
-        }
-        //================================
-        // pentahedron
-        //================================
-        else if (element_type == Z_PEN06)
-        {
-            const cellModel& prism = *(cellModeller::lookup("prism"));
-
-            label nPen06 = 0;
-            forAll(cellShapes, celli)
-            {
-                const cellShape& cellShape = cellShapes[celli];
-                const cellModel& cellModel = cellShape.model();
-                
-                if (cellModel == prism)
-                {
-                    forAll(cellShape, ip)
-                    {
-                        conn_array[nPen06][ip] = cellShape[ip] + 1;
-                    }
-                    nPen06++;
-                }
-            }
-        }
-        //================================
-        // pyramid
-        //================================
-        else if (element_type == Z_PYR05)
-        {
-            const cellModel& pyr = *(cellModeller::lookup("pyr"));
-
-            label nPyr05 = 0;
-            forAll(cellShapes, celli)
-            {
-                const cellShape& cellShape = cellShapes[celli];
-                const cellModel& cellModel = cellShape.model();
-                
-                if (cellModel == pyr)
-                {
-                    forAll(cellShape, ip)
-                    {
-                        conn_array[nPyr05][ip] = cellShape[ip] + 1;
-                    }
-                    nPyr05++;
-                }
-            }
-        }
-        //================================
-        // tetrahedron
-        //================================
-        else if (element_type == Z_TET04)
-        {
-            const cellModel& tet = *(cellModeller::lookup("tet"));
-
-            label nTet04 = 0;
-            forAll(cellShapes, celli)
-            {
-                const cellShape& cellShape = cellShapes[celli];
-                const cellModel& cellModel = cellShape.model();
-                
-                if (cellModel == tet)
-                {
-                    forAll(cellShape, ip)
-                    {
-                        conn_array[nTet04][ip] = cellShape[ip] + 1;
-                    }
-                    nTet04++;
-                }
-            }
-        }
-        //================================
-        // polyhedra
-        //================================
-        else
-        {
-            label nCells = cellShapes.size();
-            label nFaced = 0;
-            const cellList cells = meshPtr->cells();
-
-            for (label n=0; n<nCells; n++)
-            {
-                label nFacesInCell = cells[n].size();
-                labelList points = cellShapes[n];
-                if ((nFacesInCell == 6) && (points.size() == 8))
-                {}
-                else if ((nFacesInCell == 4) && (points.size() == 4))
-                {}
-                else if (nFacesInCell == 5)
-                {
-                    if (points.size() == 6)
-                    {}
-                    else if (points.size() == 5)
-                    {}
-                    else
-                    {
-                        conn_array[nFaced++][0] = nFacesInCell;
-                    }
-                }
-                else
-                {
-                    conn_array[nFaced++][0] = nFacesInCell;
-                }
-            }
-        }
-    }
-    else if (part_number < nPatches+2)
-    {
-        label patchi = part_number - 2;
-        const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-        label nTri03 = 0;
-        label nQuad04 = 0;
-        if (element_type == Z_TRI03)
-        {
-            forAll(bMesh[patchi], n)
-            {
-                label nPoints = bMesh[patchi][n].size();
-                if (nPoints == 3)
-                {
-                    for(label i=0; i<nPoints; i++)
-                    {
-                        label ip = bMesh[patchi][n][i];
-                        conn_array[nTri03][i] = ip + 1;
-                    }
-                    nTri03++;
-                }
-            }
-        }
-        else if (element_type == Z_QUA04)
-        {
-            forAll(bMesh[patchi], n)
-            {
-                label nPoints = bMesh[patchi][n].size();
-                if (nPoints == 4)
-                {
-                    for(label i=0; i<nPoints; i++)
-                    {
-                        label ip = bMesh[patchi][n][i];
-                        conn_array[nQuad04][i] = ip + 1;
-                    }
-                    nQuad04++;
-                }
-            }
-
-        }
-        else if (element_type == Z_NSIDED)
-        {
-            label nPoly = 0;
-            forAll(bMesh[patchi], n)
-            {
-                label nPoints = bMesh[patchi][n].size();
-                if ((nPoints != 3) && (nPoints != 4))
-                {
-                    conn_array[nPoly++][0] = nPoints;
-                }
-            }
-        }
-    }
-    else if (part_number == nPatches+2)
-    {
-        for (label n=0; n<sprayPtr->size(); n++)
-        {
-            conn_array[n][0] = n + 1;
-        }
-    }
-    else
-    {
-        return Z_ERR;
-    }
-
-#   ifdef ENSIGHTDEBUG
-    Info<< "Leaving: USERD_get_part_elements_by_type" << endl;
-#   endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_part_node_ids.H
+++ /dev/null
@@ -1,62 +0,0 @@
-int USERD_get_part_node_ids
-(
-    int part_number,
-    int *nodeid_array
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_part_node_ids" << endl 
-        << "part_number = " << part_number << endl 
-        << flush;
-#endif
-
-    if (part_number == 1)
-    {
-        for (label indx=0; indx<Num_global_nodes; indx++)
-        {
-            nodeid_array[indx] = indx + 1;
-        }
-    }
-    else if  (part_number < nPatches+2)
-    {
-
-        label patchi = part_number-2;
-        const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-        const vectorField& points = bMesh[patchi].points();
-
-        label nPoints = points.size();
-        
-        for (label indx=0; indx<nPoints; indx++)
-        {
-            nodeid_array[indx] = indx + 1;
-        }
-
-    }
-    else if  (part_number == nPatches+2)
-    {
-        label indx = 0;
-        for
-        (
-            Cloud<passiveParticle>::iterator elmnt = sprayPtr->begin();
-            elmnt != sprayPtr->end();
-            ++elmnt
-        )
-        {
-             nodeid_array[indx] = indx + 1;
-             indx++;
-        }
-    }
-    else
-    {
-        return Z_ERR;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_part_node_ids" << endl 
-        << flush;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_reader_version.H
+++ /dev/null
@@ -1,20 +0,0 @@
-int USERD_get_reader_version
-(
-    char version_number[Z_MAX_USERD_NAME]
-)
-{    
-
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_reader_version" << endl;
-#endif
-
-    strncpy(version_number, readerVersion, Z_MAX_USERD_NAME);
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_reader_version" << endl;
-#endif
-    
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_sol_times.H
+++ /dev/null
@@ -1,46 +0,0 @@
-//======================================================================
-// Negative values of the time is not allowed in EnSight.
-// So for engines, where the time is CAD's we need to correct
-// this so that all CAD's are positive. NN
-//======================================================================
-int USERD_get_sol_times
-(
-    int timeset_number,
-    float *solution_times
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info<< "Entering: USERD_get_sol_times\n" << timeDirs << endl;
-#endif
-
-    for (label n=0; n<Num_time_steps;n++)
-    {
-        solution_times[n] = timeDirs[n+1].value();
-    }
-
-    if (timeDirs[1].value() < 0)
-    {
-        scalar addCAD = 360.0;
-        while (timeDirs[1].value() + addCAD < 0.0)
-        {
-            addCAD += 360.0;
-        }
-        for (label n=0; n<Num_time_steps;n++)
-        {
-            solution_times[n] += addCAD;
-
-            Info << "Time[" << n << "] = " << timeDirs[n+1].value()
-                << " was corrected to " << solution_times[n]  << endl;
-        }
-
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info<< "Leaving: USERD_get_sol_times" << endl;
-#endif
-
-    return Z_OK;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_timeset_description.H
+++ /dev/null
@@ -1,28 +0,0 @@
-int USERD_get_timeset_description
-(
-    int timeset_number,
-    char timeset_description[Z_BUFL]
-)
-{
-
-#ifdef ENSIGHTDEBUG
-    Info<< "Entering: USERD_get_timeset_description" << endl;
-#endif
-
-    if (timeDirs[1].value() < 0)
-    {
-        strncpy(timeset_description, "CAD", Z_BUFL);
-    }
-    else
-    {
-        strncpy(timeset_description, "seconds", Z_BUFL);
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info<< "Leaving: USERD_get_timeset_description" << endl;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_var_by_component.H
+++ /dev/null
@@ -1,105 +0,0 @@
-int USERD_get_var_by_component
-(
-    int which_variable,
-    int which_part,
-    int var_type,
-    int which_type,
-    int imag_data,
-    int component,
-    float *var_array
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_var_by_component" << endl
-        << "which_variable = " << which_variable << endl
-        << "which_part = " << which_part << endl
-        << "var_type = " << var_type << endl
-        << "which_type = " << which_type << endl
-        << "component = " << component << endl
-        << flush;
-#endif
-
-    label nVar = which_variable - 1;
-
-    Time& runTime = *runTimePtr;
-
-    fvMesh& mesh = *meshPtr;
-    const cellShapeList& cells = mesh.cellShapes();
-
-    label nCells = cells.size();
-
-    if (var_type == Z_SCALAR)
-    {
-        if (which_part == 1)
-        {
-#           include "getFieldScalar.H"
-        }
-        else if (which_part < nPatches+2)
-        {
-#           include "getPatchFieldScalar.H"
-        }
-        else if (which_part == nPatches+2)
-        {
-#           include "getLagrangianScalar.H"
-        }
-        else
-        {
-            return Z_ERR;
-        }
-    }
-    else if (var_type == Z_VECTOR)
-    {
-        if (which_part == 1)
-        {
-#           include "getFieldVector.H"
-        }
-        else if (which_part < nPatches+2)
-        {
-#           include "getPatchFieldVector.H"
-        }
-        else if (which_part == nPatches+2)
-        {
-#           include "getLagrangianVector.H"
-        }
-        else
-        {
-            return Z_ERR;
-        }
-
-    }
-    else if (var_type == Z_TENSOR9)
-    {
-        // all tensor are treated as asymmetric tensors here
-
-        if (which_part == 1)
-        {
-#           include "getFieldTensor.H"
-        }
-        else if (which_part < nPatches+2)
-        {
-#           include "getPatchFieldTensor.H"
-        }
-        else if (which_part == nPatches+2)
-        {
-            return Z_UNDEF;
-        }
-        else
-        {
-            return Z_ERR;
-        }
-
-    }
-    else
-    {
-        return Z_UNDEF;
-    }
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_var_by_component" << endl
-        << flush;
-#endif
-
-    return Z_OK;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_get_var_value_at_specific.H
+++ /dev/null
@@ -1,73 +0,0 @@
-//======================================================================
-int USERD_get_var_value_at_specific
-(
-    int which_var,
-    int which_node_or_elem,
-    int which_part,
-    int which_elem_type,
-    int time_step,
-    float values[3],
-    int imag_data
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_get_var_value_at_specific" << endl 
-        << flush;
-#endif
-    // Not sure if it is 0 or 1 based
-
-    label nNode = which_node_or_elem;
-    label nVar = which_var - 1;
-
-    fvMesh& mesh = *meshPtr;
-
-    if (nVar < Num_variables - nSprayVariables)
-    {
-        Time& runTime = *runTimePtr;
-
-        IOobject fieldObject
-        (
-            fieldNames[var2field[nVar]],
-            runTime.timeName(),
-            mesh,
-            IOobject::MUST_READ,
-            IOobject::NO_WRITE
-        );
-
-        if (isScalar[nVar])
-        {
-            volScalarField scalarField(fieldObject,mesh);
-            values[0] = scalarField[nNode];
-        }
-        else if (isVector[nVar])
-        {
-            volVectorField vectorField(fieldObject,mesh);
-            values[0] = vectorField[nNode].x();
-            values[1] = vectorField[nNode].y();
-            values[2] = vectorField[nNode].z();
-        }
-        else
-        {
-            Info<< "ERROR in USERD_get_variable_value_at_specific. "
-                << "No available variable???"
-                << endl;
-            return Z_ERR;
-        }
-    }
-    else
-    {
-        Info<< "This functionality is not implemented yet."
-            << endl;
-        return Z_ERR;
-    }
-
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_get_var_value_at_specific" << endl 
-        << flush;
-#endif
-    return Z_OK;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_load_matf_data.H
+++ /dev/null
@@ -1,20 +0,0 @@
-
-int USERD_load_matf_data
-(
-    int set_index,
-    int part_id,
-    int wtyp,
-    int mat_type,
-    int *ids_list,
-    float *val_list 
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_load_matf_data" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_set_filenames.H
+++ /dev/null
@@ -1,211 +0,0 @@
-//======================================================================
-//  Setting filenames
-//======================================================================
-int USERD_set_filenames
-(
-    char filename_1[],
-    char filename_2[],
-    char the_path[],
-    int swapbytes
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_set_filenames" << endl << flush;
-#endif
-
-    char tmp[100];
-
-    label lRoot = strlen(the_path);
-    label lCase = strlen(filename_1);
-
-    bool cleared = false;
-
-    while (!cleared)
-    {
-        lRoot = strlen(the_path);
-        lCase = strlen(filename_1);
-
-        // remove the last '/' from rootDir
-        if (the_path[lRoot-1] == '/')
-        {
-            the_path[lRoot-1] = (char)NULL;
-        }
-        else
-        {
-            cleared = true;
-        }
-    }
-
-    rootDir = the_path;
-
-    // the path is pre-pended to filename_1
-    // 1 is the 'Geometry' : 2 the 'Result' which is null here
-    // since two_field is FALSE
-    for (label i=0; i<lCase-lRoot;i++)
-    {
-        tmp[i] = filename_1[i+1+lRoot];
-    }
-    caseDir = tmp;
-
-    if (!isDir(rootDir/caseDir))
-    {
-       Info<< rootDir/caseDir << " is not a valid directory."
-           << endl;
-       return Z_ERR;
-    }
-
-    // construct the global pointers to the database and mesh
-
-    delete meshPtr;
-    delete runTimePtr;
-
-    runTimePtr = new Time
-    (
-        Time::controlDictName,
-        rootDir,
-        caseDir
-    );
-
-    Time& runTime = *runTimePtr;
-
-    meshPtr = new fvMesh
-    (
-        IOobject
-        (
-            fvMesh::defaultRegion,
-            runTime.timeName(),
-            runTime
-        )
-    );
-
-    // set the available number of time-steps
-    timeDirs = Foam::Time::findTimes(rootDir/caseDir);
-
-    Num_time_steps = timeDirs.size() - 1;
-
-    nPatches = meshPtr->boundaryMesh().size();
-
-    // set the number of fields and store their names
-    // a valid field must exist for all time-steps
-    runTime.setTime(timeDirs[timeDirs.size()-1], timeDirs.size()-1);
-    IOobjectList objects(*meshPtr, runTime.timeName());
-
-    fieldNames = objects.names();
-
-    // because of the spray being a 'field' ...
-    // get the availabe number of variables and
-    // check for type (scalar/vector/tensor)
-
-    label nVar = 0;
-    wordList scalars = objects.names(scalarName);
-
-    for (label n=0; n<fieldNames.size(); n++)
-    {
-        bool isitScalar = false;
-        forAll(scalars,i)
-        {
-            if (fieldNames[n] == scalars[i])
-            {
-                isitScalar = true;
-                var2field[nVar++] = n;
-            }
-        }
-        isScalar[n] = isitScalar;
-    }
-
-    wordList vectors = objects.names(vectorName);
-
-    for (label n=0; n<fieldNames.size(); n++)
-    {
-        bool isitVector = false;
-        forAll(vectors,i)
-        {
-            if (fieldNames[n] == vectors[i])
-            {
-                isitVector = true;
-                var2field[nVar++] = n;
-            }
-        }
-        isVector[n] = isitVector;
-    }
-
-    wordList tensors = objects.names(tensorName);
-
-    for (label n=0; n<fieldNames.size(); n++)
-    {
-        bool isitTensor = false;
-        forAll(tensors,i)
-        {
-            if (fieldNames[n] == tensors[i])
-            {
-                isitTensor = true;
-                var2field[nVar++] = n;
-            }
-        }
-        isTensor[n] = isitTensor;
-    }
-
-    bool lagrangianNamesFound = false;
-    label n = 0;
-    while (!lagrangianNamesFound && n < Num_time_steps)
-    {
-        runTime.setTime(timeDirs[n+1], n+1);
-
-        Cloud<passiveParticle> lagrangian(*meshPtr);
-
-        n++;
-        if (lagrangian.size())
-        {
-            lagrangianNamesFound = true;
-        }
-    }
-
-    IOobject sprayHeader
-    (
-        "positions",
-        runTime.timeName(),
-        cloud::prefix,
-        runTime,
-        IOobject::NO_READ,
-        IOobject::NO_WRITE,
-        false
-    );
-
-    if (sprayHeader.headerOk())
-    {
-        Info << "[Found lagrangian]" << endl;
-
-        delete sprayPtr;
-
-        sprayPtr = new Cloud<passiveParticle>(*meshPtr);
-
-        IOobjectList objects(*meshPtr, runTime.timeName(), cloud::prefix);
-
-        lagrangianScalarNames =
-            (const wordList&)objects.names(sprayScalarFieldName);
-        lagrangianVectorNames =
-            (const wordList&)objects.names(sprayVectorFieldName);
-
-        isSpray[fieldNames.size()] = true;
-
-        nSprayVariables += lagrangianScalarNames.size();
-        nSprayVariables += lagrangianVectorNames.size();
-
-        Num_unstructured_parts++;
-    }
-
-    Current_time_step = Num_time_steps;
-    runTime.setTime(timeDirs[Current_time_step], Current_time_step);
-
-    Num_variables = nVar + nSprayVariables;
-    Numparts_available = Num_unstructured_parts + Num_structured_parts + nPatches;
-
-#ifdef ENSIGHTDEBUG
-    Info << "Leaving: USERD_set_filenames" << endl << flush;
-#endif
-
-    return Z_OK;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_set_server_number.H
+++ /dev/null
@@ -1,14 +0,0 @@
-void USERD_set_server_number
-(
-    int cur_serv,
-    int tot_serv
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_set_server_number" << endl 
-        << flush;
-#endif
-
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_set_time_set_and_step.H
+++ /dev/null
@@ -1,59 +0,0 @@
-//======================================================================
-void USERD_set_time_set_and_step
-(
-    int timeset_number,
-    int time_step
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_set_time_set_and_step" << endl << flush;
-#endif
-    // update the global pointers and variables
-    // to the current time-step
-
-    // at exit time_step < 0
-    if (time_step >= 0)
-    {
-        Time& runTime = *runTimePtr;
-        Current_time_step = time_step;
-        // add 1, since the first timestep is 'constant'
-
-        if (time_step == 0)
-        {
-            runTime.setTime
-            (
-                timeDirs[Current_time_step],
-                Current_time_step
-            );
-        }
-        else
-        {
-            runTime.setTime
-            (
-                timeDirs[Current_time_step + 1],
-                Current_time_step + 1
-            );
-        }
-
-        meshPtr->readUpdate();
-
-        if (time_step == 0)
-        {
-            runTime.setTime
-            (
-                timeDirs[Current_time_step + 1],
-                Current_time_step + 1
-            );
-        }
-
-        if (Numparts_available > nPatches+1)
-        {
-            delete sprayPtr;
-            sprayPtr = new Cloud<passiveParticle>(*meshPtr);
-        }
-    }
-}
-
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_size_matf_data.H
+++ /dev/null
@@ -1,19 +0,0 @@
-
-int USERD_size_matf_data
-(
-    int set_index,
-    int part_id,
-    int wtyp,
-    int mat_type,
-    int *matf_size 
-)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_size_matf_data" << endl 
-        << flush;
-#endif
-
-    return Z_ERR;
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_stop_part_building.H
+++ /dev/null
@@ -1,10 +0,0 @@
-// Not in use
-void USERD_stop_part_building(void)
-{
-#ifdef ENSIGHTDEBUG
-    Info << "Entering: USERD_stop_part_building" << endl << flush;
-#endif
-
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/USERD_structured_data.H
+++ /dev/null
@@ -1,64 +0,0 @@
-int USERD_get_block_vector_values_by_component
-(
-    int block_number,
-    int which_vector,
-    int which_component,
-    float *vector_array
-)
-{
-  return(Z_OK);
-}
-
-int USERD_get_block_coords_by_component
-(
-    int block_number,
-    int which_component,
-    float *coord_array
-)
-{
-  return(Z_OK);
-}
-
-
-int USERD_get_block_iblanking
-(
-    int block_number,
-    int *iblank_array
-)
-{
-  return(Z_OK);
-}
-
-int USERD_get_block_scalar_values
-(
-    int block_number,
-    int which_scalar,
-    float *scalar_array
-)
-{
-  return(Z_OK);
-}
-int USERD_get_ghosts_in_model_flag( void )
-{
-  return(Z_OK);
-}
-
-int USERD_get_ghosts_in_block_flag
-(
-    int block_number
-)
-{
-  return(Z_OK);
-}
-
-int USERD_get_block_ghost_flags
-(
-    int block_number,
-    int *ghost_flags
-)
-{
-  return(Z_OK);
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/files.cmake
+++ /dev/null
@@ -1,35 +0,0 @@
-#-------------------------------------------------------------------------------
-#               ______                _     ____          __  __
-#              |  ____|             _| |_  / __ \   /\   |  \/  |
-#              | |__ _ __ ___  ___ /     \| |  | | /  \  | \  / |
-#              |  __| '__/ _ \/ _ ( (| |) ) |  | |/ /\ \ | |\/| |
-#              | |  | | |  __/  __/\_   _/| |__| / ____ \| |  | |
-#              |_|  |_|  \___|\___|  |_|   \____/_/    \_\_|  |_|
-#
-#                   FreeFOAM: The Cross-Platform CFD Toolkit
-#
-# Copyright (C) 2008-2012 Michael Wild <themiwi@users.sf.net>
-#                         Gerber van der Graaf <gerber_graaf@users.sf.net>
-#-------------------------------------------------------------------------------
-# License
-#   This file is part of FreeFOAM.
-#
-#   FreeFOAM is free software: you can redistribute it and/or modify it
-#   under the terms of the GNU General Public License as published by the
-#   Free Software Foundation, either version 3 of the License, or (at your
-#   option) any later version.
-#
-#   FreeFOAM is distributed in the hope that it will be useful, but WITHOUT
-#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-#   for more details.
-#
-#   You should have received a copy of the GNU General Public License
-#   along with FreeFOAM.  If not, see <http://www.gnu.org/licenses/>.
-#-------------------------------------------------------------------------------
-
-set(SRCS
-  libuserd.C
-  ${FORCE_LINK_GENERIC_PATCH_FIELDS})
-
-# ------------------------- vim: set sw=2 sts=2 et: --------------- end-of-file
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getFieldScalar.H
+++ /dev/null
@@ -1,143 +0,0 @@
-
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volScalarField scalarField
-(
-    fieldObject,
-    mesh
-);
-
-const cellShapeList& cellShapes = meshPtr->cellShapes();
-
-// hexa's
-if (which_type == Z_HEX08)
-{
-    const cellModel& hex = *(cellModeller::lookup("hex"));
-    //const cellModel& wedge = *(cellModeller::lookup("wedge"));
-
-    label counter = 1;
-    for (label celli=0; celli<nCells; celli++)
-    {
-        const cellShape& cellShape = cellShapes[celli];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == hex) // || (cellModel == wedge))
-        {
-            var_array[counter++] = scalarField[celli];
-        }
-    }
-}
-
-// penta's
-if (which_type == Z_PEN06)
-{
-    const cellModel& prism = *(cellModeller::lookup("prism"));
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == prism)
-        {
-            var_array[counter++] = scalarField[n];
-        }
-    }
-}
-
-// pyramids's
-if (which_type == Z_PYR05)
-{
-    const cellModel& pyr = *(cellModeller::lookup("pyr"));
-            
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-        
-        if (cellModel == pyr)
-        {
-            var_array[counter++] = scalarField[n];
-        }
-    }
-}
-
-// tet's
-if (which_type == Z_TET04)
-{
-    const cellModel& tet = *(cellModeller::lookup("tet"));
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == tet)
-        {
-            var_array[counter++] = scalarField[n];
-        }
-    }
-}
-
-if (which_type == Z_NFACED)
-{
-    const cellList& cells = meshPtr->cells();
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const labelList& points = cellShapes[n];
-        label nFacesInCell = cells[n].size();
-
-        if ((nFacesInCell == 6) && (points.size() == 8))
-        {}
-        else if ((nFacesInCell == 4) && (points.size() == 4))
-        {}
-        else if (nFacesInCell == 5)
-        {
-            if (points.size() == 6)
-            {}
-            else if (points.size() == 5)
-            {}
-            else
-            {
-                var_array[counter++] = scalarField[n];
-            }
-        }
-        else
-        {
-            var_array[counter++] = scalarField[n];
-        }
-    }
-
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getFieldTensor.H
+++ /dev/null
@@ -1,144 +0,0 @@
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volTensorField tf
-(
-    fieldObject,
-    mesh
-);
-
-const cellShapeList& cellShapes = meshPtr->cellShapes();
-
-// hexa's
-if (which_type == Z_HEX08)
-{
-    const cellModel& hex = *(cellModeller::lookup("hex"));
-    //const cellModel& wedge = *(cellModeller::lookup("wedge"));
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == hex) // || (cellModel == wedge))
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-// penta's
-if (which_type == Z_PEN06)
-{
-    const cellModel& prism = *(cellModeller::lookup("prism"));
-
-    label counter = 1;    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-        
-        if (cellModel == prism)
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-// pyramids's
-if (which_type == Z_PYR05)
-{
-    const cellModel& pyr = *(cellModeller::lookup("pyr"));
-
-    label counter = 1;    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == pyr)
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-
-// penta's
-if (which_type == Z_TET04)
-{
-    const cellModel& tet = *(cellModeller::lookup("tet"));
-
-    label counter = 1;
-    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == tet)
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-if (which_type == Z_NFACED)
-{
-    const cellList& cells = meshPtr->cells();
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const labelList& points = cellShapes[n];
-        label nFacesInCell = cells[n].size();
-
-        if ((nFacesInCell == 6) && (points.size() == 8))
-        {}
-        else if ((nFacesInCell == 4) && (points.size() == 4))
-        {}
-        else if (nFacesInCell == 5)
-        {
-            if (points.size() == 6)
-            {}
-            else if (points.size() == 5)
-            {}
-            else
-            {
-#               include "tensorConversion.H"
-            }
-        }
-        else
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getFieldVector.H
+++ /dev/null
@@ -1,143 +0,0 @@
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volVectorField vectorField
-(
-    fieldObject,
-    mesh
-);
-
-const cellShapeList& cellShapes = meshPtr->cellShapes();
-
-// hexa's
-if (which_type == Z_HEX08)
-{
-    const cellModel& hex = *(cellModeller::lookup("hex"));
-    //const cellModel& wedge = *(cellModeller::lookup("wedge"));
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-        
-        if (cellModel == hex) // || (cellModel == wedge))
-        {
-            var_array[counter++] = vectorField[n][component];
-        }
-    }
-}
-
-// penta's
-if (which_type == Z_PEN06)
-{
-    const cellModel& prism = *(cellModeller::lookup("prism"));
-
-    label counter = 1;    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == prism)
-        {
-            var_array[counter++] = vectorField[n][component];
-        }
-    }
-}
-
-// pyramids's
-if (which_type == Z_PYR05)
-{
-    const cellModel& pyr = *(cellModeller::lookup("pyr"));
-
-    label counter = 1;    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-        
-        if (cellModel == pyr)
-        {
-            var_array[counter++] = vectorField[n][component];
-        }
-    }
-}
-
-
-// tet's
-if (which_type == Z_TET04)
-{
-    const cellModel& tet = *(cellModeller::lookup("tet"));
-
-    label counter = 1;    
-    for (label n=0; n<nCells; n++)
-    {
-        const cellShape& cellShape = cellShapes[n];
-        const cellModel& cellModel = cellShape.model();
-
-        if (cellModel == tet)
-        {
-            var_array[counter++] = vectorField[n][component];
-        }
-    }
-}
-
-if (which_type == Z_NFACED)
-{
-    const cellList& cells = meshPtr->cells();
-
-    label counter = 1;
-    for (label n=0; n<nCells; n++)
-    {
-        const labelList& points = cellShapes[n];
-        label nFacesInCell = cells[n].size();
-
-        if ((nFacesInCell == 6) && (points.size() == 8))
-        {}
-        else if ((nFacesInCell == 4) && (points.size() == 4))
-        {}
-        else if (nFacesInCell == 5)
-        {
-            if (points.size() == 6)
-            {}
-            else if (points.size() == 5)
-            {}
-            else
-            {
-                var_array[counter++] = vectorField[n][component];
-            }
-        }
-        else
-        {
-            var_array[counter++] = vectorField[n][component];
-        }
-    }
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getLagrangianScalar.H
+++ /dev/null
@@ -1,37 +0,0 @@
-
-// Not sure if this is necessary anymore
-nVar -= Num_variables - nSprayVariables;
-
-if (nVar >= 0)
-{
-    word name = lagrangianScalarNames[nVar];
-
-    IOField<scalar> s
-    (
-        IOobject
-        (
-            name,
-            runTime.timeName(),
-            cloud::prefix,
-            mesh,
-            IOobject::MUST_READ,
-            IOobject::NO_WRITE
-        )
-    );
-
-    if (s.size())
-    {
-        for (label n = 0; n < s.size(); n++)
-        {
-            var_array[n+1] = s[n];
-        }
-    }
-}
-else
-{
-    // Info << "getLagrangianScalar: nVar = " << nVar << endl;
-    return Z_UNDEF;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getLagrangianVector.H
+++ /dev/null
@@ -1,49 +0,0 @@
-
-// Not sure if this is necessary anymore
-
-nVar -= Num_variables - nSprayVariables + lagrangianScalarNames.size();
-
-if (nVar >= 0)
-{
-    word name = lagrangianVectorNames[nVar];
-
-    IOField<vector> v
-    (
-        IOobject
-        (
-            name,
-            runTime.timeName(),
-            cloud::prefix,
-            mesh,
-            IOobject::MUST_READ,
-            IOobject::NO_WRITE
-        )
-    );
-
-    if (v.size())
-    {
-        for (label n = 0; n < v.size(); n++)
-        {
-            if (component == 0)
-            {
-                var_array[n+1] = v[n].x();
-            }
-            else if (component == 1)
-            {
-                var_array[n+1] = v[n].y();
-            }
-            else if (component == 2)
-            {
-                var_array[n+1] = v[n].z();
-            }
-        }
-    }
-}
-else
-{
-    // Info<< "getLagrangianVector: nVar = " << nVar << endl;
-    return Z_UNDEF;
-}
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getPatchFieldScalar.H
+++ /dev/null
@@ -1,78 +0,0 @@
-label patchi = which_part - 2;
-
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volScalarField sf
-(
-    fieldObject,
-    mesh
-);
-
-const scalarField& sfb = sf.boundaryField()[patchi];
-const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-if (which_type == Z_TRI03)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if (nPoints == 3)
-        {
-            var_array[counter++] = sfb[facei];
-        }
-    }
-}
-
-if (which_type == Z_QUA04)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if (nPoints == 4)
-        {
-            var_array[counter++] = sfb[facei];
-        }
-    }
-}
-
-if (which_type == Z_NSIDED)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if ((nPoints != 3) && (nPoints != 4))
-        {
-            var_array[counter++] = sfb[facei];
-        }
-    }
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getPatchFieldTensor.H
+++ /dev/null
@@ -1,78 +0,0 @@
-label patchi = which_part - 2;
-
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volTensorField sf
-(
-    fieldObject,
-    mesh
-);
-
-const tensorField& tf = sf.boundaryField()[patchi];
-const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-if (which_type == Z_TRI03)
-{
-    label counter = 1;
-    for (label n=0; n<tf.size(); n++)
-    {
-        label nPoints = bMesh[patchi][n].size();
-        if (nPoints == 3)
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-if (which_type == Z_QUA04)
-{
-    label counter = 1;
-    for (label n=0; n<tf.size(); n++)
-    {
-        label nPoints = bMesh[patchi][n].size();
-        if (nPoints == 4)
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-if (which_type == Z_NSIDED)
-{
-    label counter = 1;
-    for (label n=0; n<tf.size(); n++)
-    {
-        label nPoints = bMesh[patchi][n].size();
-        if ((nPoints != 3) && (nPoints != 4))
-        {
-#           include "tensorConversion.H"
-        }
-    }
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/getPatchFieldVector.H
+++ /dev/null
@@ -1,78 +0,0 @@
-label patchi = which_part - 2;
-
-if (nVar >= Num_variables - nSprayVariables)
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObjectPtr
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::NO_READ
-);
-
-if (!fieldObjectPtr.headerOk())
-{
-    return Z_UNDEF;
-}
-
-IOobject fieldObject
-(
-    fieldNames[var2field[nVar]],
-    runTime.timeName(),
-    mesh,
-    IOobject::MUST_READ,
-    IOobject::NO_WRITE
-);
-
-volVectorField sf
-(
-    fieldObject,
-    mesh
-);
-
-const vectorField& sfb = sf.boundaryField()[patchi];
-const polyBoundaryMesh& bMesh = meshPtr->boundaryMesh();
-
-if (which_type == Z_TRI03)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if (nPoints == 3)
-        {
-            var_array[counter++] = sfb[facei][component];
-        }
-    }
-}
-
-if (which_type == Z_QUA04)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if (nPoints == 4)
-        {
-            var_array[counter++] = sfb[facei][component];
-        }
-    }
-}
-
-if (which_type == Z_NSIDED)
-{
-    label counter = 1;
-    for (label facei=0; facei<sfb.size(); facei++)
-    {
-        label nPoints = bMesh[patchi][facei].size();
-        if ((nPoints != 3) && (nPoints != 4))
-        {
-            var_array[counter++] = sfb[facei][component];
-        }
-    }
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/globalFoam.H
+++ /dev/null
@@ -1,55 +0,0 @@
-//======================================================================
-// Global variables
-const int maxNames = 1000;
-
-// define the name to be displayed in the window.
-static char readerName[]           = "OpenFOAM";
-static char meshName[]             = "cells";
-static char readerVersion[]        = "2.03";
-
-// everything is one part in foam, except the spray
-static int Num_unstructured_parts  = 1;
-static int Num_structured_parts    = 0;
-static int Numparts_available      = 1;
-static int nPatches                = 0;
-
-static int Num_timesets            = 1;
-static int Geom_timeset_number     = 1;
-static int Num_time_steps          = 1;
-static int Num_global_nodes        = 0;
-static int Num_variables           = 0;
-static int Num_dataset_files       = 0;
-static int Current_time_step       = 0;
-
-static label nSprayVariables       = 0;
-static label nMaxParcels           = 0;
-
-static bool isScalar[maxNames];
-static bool isVector[maxNames];
-static bool isTensor[maxNames];
-static bool isSpray[maxNames];
-
-static word scalarName             = "volScalarField";
-static word vectorName             = "volVectorField";
-static word tensorName             = "volTensorField";
-static word sprayScalarFieldName   = "scalarField";
-static word sprayVectorFieldName   = "vectorField";
-static word sprayTensorFieldName   = "tensorField";
-static word parcelPrepend          = "parcel_";
-static word pointPrepend           = "point_";
-
-static fileName rootDir;
-static fileName caseDir;
-
-static instantList timeDirs;
-
-static List<word> fieldNames;
-static List<word> lagrangianScalarNames;
-static List<word> lagrangianVectorNames;
-static label var2field[maxNames];
-
-static Time *runTimePtr = 0;
-static fvMesh *meshPtr = 0;
-static Cloud<passiveParticle> *sprayPtr = 0;
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/global_extern.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/*--------------------------------------------------------------*/
-/* Header file for EnSight External Reader DSO Library Routines */
-/*--------------------------------------------------------------*/
-/*  *************************************************************
- *   Copyright 1998 Computational Engineering International, Inc.
- *   All Rights Reserved.
- *
- *        Restricted Rights Legend
- *
- *   Use, duplication, or disclosure of this
- *   software and its documentation by the
- *   Government is subject to restrictions as
- *   set forth in subdivision [(b)(3)(ii)] of
- *   the Rights in Technical Data and Computer
- *   Software clause at 52.227-7013.
- *  *************************************************************
- */
-#ifndef GLOBAL_EXTERN_H
-#define GLOBAL_EXTERN_H
-
-/*--------------------------------
- * Set the reader version define
- * (only one can be set at a time)
- *--------------------------------*/
-#define USERD_API_203
-
-/*----------------------------------------
- * Set this appropriately:
- *  DO_ENSIGHT  if using for EnSight itself
- *  DO_READER   if using in a reader
- *----------------------------------------*/
-#if 1
-#define DO_READER
-#else
-#define DO_ENSIGHT
-#endif
-
-/*---------------------------------------*/
-/* True/False and Error conditions, etc. */
-/*---------------------------------------*/
-#define Z_ERR                  (-1)          /*Error return value.*/
-#define Z_OK                    (1)          /*Success return value.*/
-#define Z_UNDEF                 (2)          /*Undefined return value.*/
-
-#define Z_NOT_IMPLEMENTED       (3)          /*Routine not implemented*/
-                                             /*(currently only checked for */
-                                             /* get_var_value_at_specific routine)*/ 
-#ifndef TRUE
-# define TRUE                   (1)
-# define FALSE                  (0)
-#endif
-
-#define Z_BUFL                 (80)          /* Typical string length */
-
-#define Z_COMPX                 (0)          /* x component */
-#define Z_COMPY                 (1)          /* y component */
-#define Z_COMPZ                 (2)          /* z component */
-
-#define Z_STATIC                (0)          /* static geometry          */
-#define Z_CHANGE_COORDS         (1)          /* coordinate changing only */
-#define Z_CHANGE_CONN           (2)          /* conectivity changing     */
-
-#define Z_GEOM                  (0)          /* Geometry type */
-#define Z_VARI                  (1)          /* Variable type */
-
-#define Z_SAVE_ARCHIVE          (0)          /* Save archive    */
-#define Z_REST_ARCHIVE          (1)          /* Restore archive */
-
-#define Z_MAX_USERD_NAME        (20)         /* max length of reader name */
-
-#define Z_PER_NODE              (4)          /* At Nodes Variable classif.   */
-#define Z_PER_ELEM              (1)          /* At Elements Variable classif.*/
-
-#define Z_MAX_SETS              (300)
-
-#ifndef GLOBALDEFS_H
-/*-----------------------------------*/
-/* Unstructured coordinate structure */
-/*-----------------------------------*/
-typedef struct {
-  float xyz[3];
-}CRD;
-#endif
-
-/*----------------*/ 
-/* Variable Types */
-/*----------------*/ 
-enum z_var_type
-{
-  Z_CONSTANT,
-  Z_SCALAR,
-  Z_VECTOR,
-  Z_TENSOR,
-  Z_TENSOR9,
-  MAX_Z_VAR_TYPES
-};
-
-/*---------------
- * Element Types
- *---------------
- * If you mess with these, you must also
- * change the get_z_maxtype
- *            to_z_elem_type
- *            to_int_elem_type routines
- * in userd_read.c
- *----------------------------------------*/
-#if (defined USERD_API_100 || defined USERD_API_200) && defined DO_READER
-enum z_elem_types {
-  Z_POINT,         /* 00:  1 node point element */
-  Z_BAR02,         /* 01:  2 node bar           */
-  Z_BAR03,         /* 02:  3 node bar           */
-  Z_TRI03,         /* 03:  3 node triangle      */
-  Z_TRI06,         /* 04:  6 node triangle      */
-  Z_QUA04,         /* 05:  4 node quad          */
-  Z_QUA08,         /* 06:  8 node quad          */
-  Z_TET04,         /* 07:  4 node tetrahedron   */
-  Z_TET10,         /* 08: 10 node tetrahedron   */
-  Z_PYR05,         /* 09:  5 node pyramid       */
-  Z_PYR13,         /* 10: 13 node pyramid       */
-  Z_PEN06,         /* 11:  6 node pentahedron   */
-  Z_PEN15,         /* 12: 15 node pentahedron   */
-  Z_HEX08,         /* 13:  8 node hexahedron    */
-  Z_HEX20,         /* 14: 20 node hexahedron    */
-  Z_MAXTYPE
-};
-
-#elif defined USERD_API_201 && defined DO_READER
-enum z_elem_types {
-  Z_POINT,         /* 00:  1 node point element              */
-  Z_G_POINT,       /* 01:  1 node point element (ghost call) */
-  Z_BAR02,         /* 02:  2 node bar                        */
-  Z_G_BAR02,       /* 03:  2 node bar           (ghost cell) */
-  Z_BAR03,         /* 04:  3 node bar                        */
-  Z_G_BAR03,       /* 05:  3 node bar           (ghost cell) */
-  Z_TRI03,         /* 06:  3 node triangle                   */
-  Z_G_TRI03,       /* 07:  3 node triangle      (ghost cell) */
-  Z_TRI06,         /* 08:  6 node triangle                   */
-  Z_G_TRI06,       /* 09:  6 node triangle      (ghost cell) */
-  Z_QUA04,         /* 10:  4 node quad                       */
-  Z_G_QUA04,       /* 11:  4 node quad          (ghost cell) */
-  Z_QUA08,         /* 12:  8 node quad                       */
-  Z_G_QUA08,       /* 13:  8 node quad          (ghost cell) */
-  Z_TET04,         /* 14:  4 node tetrahedron                */
-  Z_G_TET04,       /* 15:  4 node tetrahedron   (ghost cell) */
-  Z_TET10,         /* 16: 10 node tetrahedron                */
-  Z_G_TET10,       /* 17: 10 node tetrahedron   (ghost cell) */
-  Z_PYR05,         /* 18:  5 node pyramid                    */
-  Z_G_PYR05,       /* 19:  5 node pyramid       (ghost cell) */
-  Z_PYR13,         /* 20: 13 node pyramid                    */
-  Z_G_PYR13,       /* 21: 13 node pyramid       (ghost cell) */
-  Z_PEN06,         /* 22:  6 node pentahedron                */
-  Z_G_PEN06,       /* 23:  6 node pentahedron   (ghost cell) */
-  Z_PEN15,         /* 24: 15 node pentahedron                */
-  Z_G_PEN15,       /* 25: 15 node pentahedron   (ghost cell) */
-  Z_HEX08,         /* 26:  8 node hexahedron                 */
-  Z_G_HEX08,       /* 27:  8 node hexahedron    (ghost cell) */
-  Z_HEX20,         /* 28: 20 node hexahedron                 */
-  Z_G_HEX20,       /* 29: 20 node hexahedron    (ghost cell) */
-  Z_MAXTYPE
-};
-
-#else
-enum z_elem_types {
-  Z_POINT,         /* 00:  1 node point element              */
-  Z_G_POINT,       /* 01:  1 node point element (ghost call) */
-  Z_BAR02,         /* 02:  2 node bar                        */
-  Z_G_BAR02,       /* 03:  2 node bar           (ghost cell) */
-  Z_BAR03,         /* 04:  3 node bar                        */
-  Z_G_BAR03,       /* 05:  3 node bar           (ghost cell) */
-  Z_TRI03,         /* 06:  3 node triangle                   */
-  Z_G_TRI03,       /* 07:  3 node triangle      (ghost cell) */
-  Z_TRI06,         /* 08:  6 node triangle                   */
-  Z_G_TRI06,       /* 09:  6 node triangle      (ghost cell) */
-  Z_QUA04,         /* 10:  4 node quad                       */
-  Z_G_QUA04,       /* 11:  4 node quad          (ghost cell) */
-  Z_QUA08,         /* 12:  8 node quad                       */
-  Z_G_QUA08,       /* 13:  8 node quad          (ghost cell) */
-  Z_TET04,         /* 14:  4 node tetrahedron                */
-  Z_G_TET04,       /* 15:  4 node tetrahedron   (ghost cell) */
-  Z_TET10,         /* 16: 10 node tetrahedron                */
-  Z_G_TET10,       /* 17: 10 node tetrahedron   (ghost cell) */
-  Z_PYR05,         /* 18:  5 node pyramid                    */
-  Z_G_PYR05,       /* 19:  5 node pyramid       (ghost cell) */
-  Z_PYR13,         /* 20: 13 node pyramid                    */
-  Z_G_PYR13,       /* 21: 13 node pyramid       (ghost cell) */
-  Z_PEN06,         /* 22:  6 node pentahedron                */
-  Z_G_PEN06,       /* 23:  6 node pentahedron   (ghost cell) */
-  Z_PEN15,         /* 24: 15 node pentahedron                */
-  Z_G_PEN15,       /* 25: 15 node pentahedron   (ghost cell) */
-  Z_HEX08,         /* 26:  8 node hexahedron                 */
-  Z_G_HEX08,       /* 27:  8 node hexahedron    (ghost cell) */
-  Z_HEX20,         /* 28: 20 node hexahedron                 */
-  Z_G_HEX20,       /* 29: 20 node hexahedron    (ghost cell) */
-  Z_NSIDED,        /* 30:  n node polygon                    */
-  Z_G_NSIDED,      /* 31:  n node polygon       (ghost cell) */
-  Z_NFACED,        /* 32:  n faced polyhedron                */
-  Z_G_NFACED,      /* 33:  n faced polyhedron   (ghost cell) */
-  Z_MAXTYPE
-};
-
-#endif
-
-enum z_node_ids_opt
-{
-  Z_NO_NODE_IDS,
-  Z_ASSIGN_NODE_IDS,
-  Z_GIVEN_NODE_IDS
-};
-
-enum z_element_ids_opt
-{
-  Z_NO_ELEMENT_IDS,
-  Z_ASSIGN_ELEMENT_IDS,
-  Z_GIVEN_ELEMENT_IDS
-};
-
-
-/*-------------------------------*/
-/* Unstructured/Structured types */
-/*-------------------------------*/
-enum z_structured_defs
-{
-  Z_UNSTRUCTURED,         /* for unstructured part */
-  Z_STRUCTURED,           /* for structured (non-iblanked) part */
-  Z_IBLANKED,             /* for structured iblanked part */
-  Z_MAXMESHTYPES
-};
-
-/*----------------------------*/
-/* Structured Iblanking types */
-/*----------------------------*/
-enum z_iblank_domain
-{
-  Z_EXT,                  /* Exterior */
-  Z_INT,                  /* Interior */
-  Z_BND,                  /* Boundary */
-  Z_INTBND,               /* Internal boundary/baffle */
-  Z_SYM,                  /* Symmetry surface */
-  Z_NO_OF_IBLANK_DOMAIN_ITEMS
-};
-
-
-/*-----------------------------------*/
-/* Dataset Query file info Structure */
-/*-----------------------------------*/
-#define Z_MAXFILENP    255  /* Max file name and path.*/
-#define Z_MAXTIMLEN     40  /* Max time str length */
-#define Z_BUFLEN        82  /* Allocated length of the f_desc strings */
-typedef struct {
-    char name[Z_MAXFILENP];
-    long sizeb;
-    char timemod[Z_MAXTIMLEN];
-    int num_d_lines;
-    char **f_desc;
-} Z_QFILES;
-
-/*-------------------------------------------
- * Mixed Material enum
- *
- * (Must be comparable to material_file_index
- *  in mat_defs.h of EnSight server)
- *--------------------------------------------*/
-enum  z_material_file_index
-{
-  Z_MAT_INDEX,
-  Z_MIX_INDEX,
-  Z_MIX_VALUE,
-  Z_NUM_MAT_FILES
-};
-
-
-/*----------------------------------------------------------
- * For readers, we need to include the prototype header file
- *----------------------------------------------------------*/
-#if defined DO_READER
-#include "global_extern_proto.h"
-#endif
-     
-/*--------------------------------------------------------------------*/
-#endif /*GLOBAL_EXTERN_H*/
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/global_extern_proto.h
+++ /dev/null
@@ -1,384 +0,0 @@
-/*--------------------------------------------------------------*/
-/* Prototype Header file for EnSight External Reader            */
-/* DSO Library Routines                                         */
-/*                                                              */
-/* intended to be included from global_extern.h only            */
-/*--------------------------------------------------------------*/
-/*  *************************************************************
- *   Copyright 1998 Computational Engineering International, Inc.
- *   All Rights Reserved.
- *
- *        Restricted Rights Legend
- *
- *   Use, duplication, or disclosure of this
- *   software and its documentation by the
- *   Government is subject to restrictions as
- *   set forth in subdivision [(b)(3)(ii)] of
- *   the Rights in Technical Data and Computer
- *   Software clause at 52.227-7013.
- *  *************************************************************
- */
-#ifndef GLOBAL_EXTERN_PROTO_H
-#define GLOBAL_EXTERN_PROTO_H
-
-#ifdef WIN32
-#define W32IMPORT __declspec( dllimport )
-#define W32EXPORT __declspec( dllexport )
-#else
-#define W32IMPORT extern
-#define W32EXPORT extern
-#endif
-
-/*----------------------
- * Same in All Versions
- *----------------------*/
-W32IMPORT int
-USERD_get_number_of_model_parts( void );
-
-W32IMPORT int
-USERD_get_block_coords_by_component(int block_number,
-                                    int which_component,
-                                    float *coord_array);
-
-W32IMPORT int
-USERD_get_block_iblanking(int block_number,
-                          int *iblank_array);
-
-W32IMPORT int
-USERD_get_block_scalar_values(int block_number,
-                              int which_scalar,
-                              float *scalar_array);
-
-W32IMPORT int
-USERD_get_block_vector_values_by_component(int block_number,
-                                           int which_vector,
-                                           int which_component,
-                                           float *vector_array);
-
-W32IMPORT int
-USERD_get_name_of_reader(char reader_name[Z_MAX_USERD_NAME],
-                         int *two_fields);
-     
-W32IMPORT int
-USERD_get_reader_descrip(char descrip[Z_MAXFILENP]);
-
-W32IMPORT int
-USERD_set_filenames(char filename_1[],
-                    char filename_2[],
-                    char the_path[],
-                    int swapbytes);
-     
-W32IMPORT int
-USERD_get_number_of_files_in_dataset( void );
-
-W32IMPORT int
-USERD_get_dataset_query_file_info(Z_QFILES *qfiles);
-     
-W32IMPORT int
-USERD_get_changing_geometry_status( void );
-
-W32IMPORT int
-USERD_get_node_label_status( void );
-
-W32IMPORT int
-USERD_get_element_label_status( void );
-
-W32IMPORT int
-USERD_get_number_of_variables( void );
-
-W32IMPORT void
-USERD_stop_part_building( void );
-
-W32IMPORT int
-USERD_bkup(FILE *archive_file,
-           int backup_type);
-
-
-
-/*-----------------------
- * For Version 1.000 Only
- *-----------------------*/
-#if defined USERD_API_100
-
-W32IMPORT int
-USERD_get_number_of_global_nodes( void );
-     
-W32IMPORT int
-USERD_get_global_coords(CRD *coord_array);
-     
-W32IMPORT int
-USERD_get_global_node_ids(int *nodeid_array);
-     
-W32IMPORT int
-USERD_get_element_connectivities_for_part(int part_number,
-                                          int **conn_array[Z_MAXTYPE]);
-
-W32IMPORT int
-USERD_get_element_ids_for_part(int part_number,
-                               int *elemid_array[Z_MAXTYPE]);
-
-W32IMPORT int
-USERD_get_vector_values(int which_vector,
-                        int which_part,
-                        int which_type,
-                        float *vector_array);
-     
-W32IMPORT int
-USERD_get_part_build_info(int *part_id,
-                          int *part_types,
-                          char *part_descriptions[Z_BUFL],
-                          int *number_of_elements[Z_MAXTYPE],
-                          int *ijk_dimensions[3],
-                          int *iblanking_options[6]);
-
-W32IMPORT int
-USERD_get_scalar_values(int which_scalar,
-                        int which_part,
-                        int which_type,
-                        float *scalar_array);
-
-W32IMPORT int
-USERD_get_variable_info(char **var_description,
-                        char **var_filename,
-                        int *var_type,
-                        int *var_classify);
-
-W32IMPORT int
-USERD_get_description_lines(int which_type,
-                            int which_var,
-                            char line1[Z_BUFL],
-                            char line2[Z_BUFL]);
-
-W32IMPORT int
-USERD_get_variable_value_at_specific(int which_var,
-                                     int which_node_or_elem,
-                                     int which_part,
-                                     int which_elem_type,
-                                     int time_step,
-                                     float values[3]);
-
-W32IMPORT float
-USERD_get_constant_value(int which_var);
-
-W32IMPORT int
-USERD_get_solution_times(float *solution_times);
-W32IMPORT void
-USERD_set_time_step(int time_step);
-
-W32IMPORT int
-USERD_get_number_of_time_steps(void);
-
-#endif
-
-
-/*----------------------
- * New For Version 2.000
- *----------------------*/
-#if !defined USERD_API_100
-
-W32IMPORT int
-USERD_get_part_coords(int part_number,
-                      float **coord_array);
-
-W32IMPORT int
-USERD_get_part_node_ids(int part_number,
-                        int *nodeid_array);
-     
-W32IMPORT int
-USERD_get_part_elements_by_type(int part_number,
-                                int element_type,
-                                int **conn_array);
-W32IMPORT int
-USERD_get_part_element_ids_by_type(int part_number,
-                                   int element_type,
-                                   int *elemid_array);
-     
-W32IMPORT int
-USERD_get_reader_version(char version_number[Z_MAX_USERD_NAME]);
-
-W32IMPORT int
-USERD_get_reader_release(char version_number[Z_MAX_USERD_NAME]);
-
-W32IMPORT int
-USERD_get_var_by_component(int which_variable,
-                           int which_part,
-                           int var_type,
-                           int which_type,
-                           int complex,
-                           int component,
-                           float *var_array);
-
-W32IMPORT int
-USERD_get_maxsize_info(int *max_number_of_nodes,
-                       int *max_number_of_elements[Z_MAXTYPE],
-                       int *max_ijk_dimensions[3]);
-
-W32IMPORT void
-USERD_exit_routine( void );
-
-W32IMPORT int
-USERD_get_gold_variable_info(char **var_description,
-                             char **var_filename,
-                             int *var_type,
-                             int *var_classify,
-                             int *var_complex,
-                             char **var_ifilename,
-                             float *var_freq,
-                             int *var_contran,
-                             int *var_timeset);
-W32IMPORT int
-USERD_get_model_extents( float extents[6] );
-
-W32IMPORT int
-USERD_get_descrip_lines(int which_type,
-                        int which_var,
-                        int imag_data,
-                        char line1[Z_BUFL],
-                        char line2[Z_BUFL]);
-
-W32IMPORT int
-USERD_get_var_value_at_specific(int which_var,
-                                int which_node_or_elem,
-                                int which_part,
-                                int which_elem_type,
-                                int time_step,
-                                float values[3],
-                                int imag_data);
-
-W32IMPORT float
-USERD_get_constant_val(int which_var, int imag_data);
-
-W32IMPORT int
-USERD_get_geom_timeset_number(void);
-
-W32IMPORT int
-USERD_get_number_of_timesets(void);
-
-W32IMPORT int
-USERD_get_timeset_description(int timeset_number,
-                              char timeset_description[Z_BUFL]);
-
-W32IMPORT int
-USERD_get_sol_times(int timeset_number,
-                    float *solution_times);
-W32IMPORT void
-USERD_set_time_set_and_step(int timeset_number,
-                            int time_step);
-W32IMPORT int
-USERD_get_num_of_time_steps(int timeset_number);
-
-W32IMPORT int
-USERD_get_border_availability(int part_number,
-                              int number_of_elements[Z_MAXTYPE]);
-
-W32IMPORT int
-USERD_get_border_elements_by_type(int part_number,
-                                  int element_type,
-                                  int **conn_array,
-                                  short *parent_element_type,
-                                  int *parent_element_num);
-
-W32IMPORT void
-USERD_set_server_number(int serv_num,
-                        int tot_servs);
-
-#endif
-
-
-/*----------------------
- * New For Version 2.010
- *----------------------*/
-#if defined USERD_API_201 || defined USERD_API_202 || defined USERD_API_203
-W32IMPORT int
-USERD_get_ghosts_in_model_flag( void );
-
-W32IMPORT int
-USERD_get_ghosts_in_block_flag(int block_number);
-
-W32IMPORT int
-USERD_get_block_ghost_flags(int block_number,
-                            int *ghost_flags);
-#endif
-
-/*--------------------------
- * Modified at Version 2.030
- *--------------------------*/
-#if defined USERD_API_201 || defined USERD_API_202
-
-W32IMPORT int
-USERD_get_gold_part_build_info(int *part_id,
-                               int *part_types,
-                               char *part_descriptions[Z_BUFL],
-                               int *number_of_nodes,
-                               int *number_of_elements[Z_MAXTYPE],
-                               int *ijk_dimensions[3],
-                               int *iblanking_options[6]);
-#endif
-
-#if defined USERD_API_203
-W32IMPORT int
-USERD_get_gold_part_build_info(int *part_id,
-                               int *part_types,
-                               char *part_descriptions[Z_BUFL],
-                               int *number_of_nodes,
-                               int *number_of_elements[Z_MAXTYPE],
-                               int *ijk_dimensions[9],
-                               int *iblanking_options[6]);
-#endif
-
-
-/*----------------------
- * New For Version 2.030
- *----------------------*/
-#if defined USERD_API_203
-W32IMPORT int
-USERD_get_number_of_material_sets( void );
-
-W32IMPORT int
-USERD_get_matf_set_info(int *mat_set_ids,
-                        char **mat_set_name);
-
-W32IMPORT int
-USERD_get_number_of_materials( int set_index );
-
-W32IMPORT int
-USERD_get_matf_var_info(int set_index,
-                        int *mat_ids,
-                        char **mat_desc);
-
-W32IMPORT int
-USERD_size_matf_data(int set_index,
-                     int part_id,
-                     int wtyp,
-                     int mat_type,
-                     int *matf_size );
-
-W32IMPORT int
-USERD_load_matf_data( int set_index,
-                      int part_id,
-                      int wtyp,
-                      int mat_type,
-                      int *ids_list,
-                      float *val_list );
-
-W32IMPORT int
-USERD_get_nsided_conn( int part_number,
-                       int *nsided_conn_array );
-
-W32IMPORT int
-USERD_get_nfaced_nodes_per_face( int part_number,
-                                 int *nfaced_npf_array );
-
-W32IMPORT int
-USERD_get_nfaced_conn( int part_number,
-                       int *nfaced_conn_array );
-
-
-#endif
-
-     
-/*--------------------------------------------------------------------*/
-#endif /*GLOBAL_EXTERN_PROTO_H*/
-
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/libuserd.C
+++ /dev/null
@@ -1,140 +0,0 @@
-/*---------------------------------------------------------------------------*\
-  =========                 |
-  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
-   \\    /   O peration     |
-    \\  /    A nd           | Copyright (C) 1991-2010 OpenCFD Ltd.
-     \\/     M anipulation  |
--------------------------------------------------------------------------------
-License
-    This file is part of OpenFOAM.
-
-    OpenFOAM is free software: you can redistribute it and/or modify it
-    under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-    for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
-
-Application
-    libuserd-foam
-
-Description
-    EnSight library module to read OpenFOAM data directly without translation
-
-    It can currently handle most cell types.
-
-    See also: README_USERD_2.0
-    24 Sep 2001: NN - Added support for Ensight API 2.0
-    02 Sep 2002: NN - Added support for ghost cells
-    14 Mar 2004: NN - Added patches to the parts
-
-\*---------------------------------------------------------------------------*/
-
-#include <stdio.h>
-
-#include <finiteVolume/fvCFD.H>
-#include <OpenFOAM/IOobjectList.H>
-#include <lagrangian/Cloud.H>
-#include <lagrangian/passiveParticle.H>
-#include <finiteVolume/fvMesh.H>
-#include <OpenFOAM/cellModeller.H>
-#include "globalFoam.H"
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-extern "C"
-{
-
-#include "global_extern.h"
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-// same API as in 1.0
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-#include "USERD_bkup.H"
-#include "USERD_get_name_of_reader.H"
-#include "USERD_set_filenames.H"
-#include "USERD_get_number_of_model_parts.H"
-#include "USERD_get_changing_geometry_status.H"
-#include "USERD_get_dataset_query_file_info.H"
-#include "USERD_get_element_label_status.H"
-#include "USERD_get_node_label_status.H"
-#include "USERD_get_number_of_files_in_dataset.H"
-#include "USERD_get_number_of_variables.H"
-#include "USERD_stop_part_building.H"
-
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-// slightly changed with 2.0 from 1.0
-// (to handle complex variables -  not used by FOAM anyway)
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-#include "USERD_get_constant_val.H"
-#include "USERD_get_descrip_lines.H"
-#include "USERD_get_var_value_at_specific.H"
-#include "USERD_get_gold_variable_info.H"
-
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-// critical changes with 2.0 from 1.0
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-#include "USERD_get_gold_part_build_info.H"
-#include "USERD_get_num_of_time_steps.H"
-#include "USERD_get_sol_times.H"
-#include "USERD_set_time_set_and_step.H"
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-// new additions with 2.0 from 1.0
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-#include "USERD_get_var_by_component.H"
-#include "USERD_get_part_coords.H"
-#include "USERD_get_part_node_ids.H"
-#include "USERD_get_part_elements_by_type.H"
-#include "USERD_get_part_element_ids_by_type.H"
-
-#include "USERD_exit_routine.H"
-#include "USERD_get_model_extents.H"
-#include "USERD_get_reader_version.H"
-#include "USERD_get_number_timesets.H"
-#include "USERD_get_timeset_description.H"
-#include "USERD_get_geom_timeset_number.H"
-
-#include "USERD_get_border_availability.H"
-#include "USERD_get_border_elements_by_type.H"
-
-#include "USERD_get_maxsize_info.H"
-#include "USERD_set_server_number.H"
-
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-// new additions with 2.03 from 2.02
-// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
-
-#include "USERD_get_number_of_material_sets.H"
-#include "USERD_get_matf_set_info.H"
-#include "USERD_get_number_of_materials.H"
-#include "USERD_get_matf_var_info.H"
-#include "USERD_size_matf_data.H"
-#include "USERD_load_matf_data.H"
-#include "USERD_get_nsided_conn.H"
-#include "USERD_get_nfaced_nodes_per_face.H"
-#include "USERD_get_nfaced_conn.H"
-
-//**********************************************************************
-//======================================================================
-// STRUCTURED DATA STUFF - not used in foam
-//======================================================================
-//**********************************************************************
-
-#include "USERD_structured_data.H"
-
-}
-
-// ************************************************************************ //
--- a/applications/utilities/postProcessing/graphics/ensightFoamReader/tensorConversion.H
+++ /dev/null
@@ -1,38 +0,0 @@
-if (component == 0)
-{
-    var_array[counter++] = tf[n].xx();
-}
-else if (component == 1)
-{
-    var_array[counter++] = tf[n].yy();
-}
-else if (component == 2)
-{
-    var_array[counter++] = tf[n].zz();
-}
-else if (component == 3)
-{
-    var_array[counter++] = tf[n].xy();
-}
-else if (component == 4)
-{
-    var_array[counter++] = tf[n].xz();
-}
-else if (component == 5)
-{
-    var_array[counter++] = tf[n].yz();
-}
-else if (component == 6)
-{
-    var_array[counter++] = tf[n].yx();
-}
-else if (component == 7)
-{
-    var_array[counter++] = tf[n].zx();
-}
-else if (component == 8)
-{
-    var_array[counter++] = tf[n].zy();
-}
-
-// ************************ vim: set sw=4 sts=4 et: ************************ //
